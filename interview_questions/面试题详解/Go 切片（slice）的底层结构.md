# 面试题：Go 切片（slice）的底层结构

## 一、基础认知：切片是什么？
**切片（slice）** 是 Go 语言提供的一种**动态数组**类型，它建立在数组之上，提供了**可变长度**的序列视图。切片本身**不存储数据**，只是对底层数组的一个引用（视图），因此修改切片元素会直接影响底层数组。

### 1. 直观示例
```go
func main() {
    arr := [5]int{1, 2, 3, 4, 5} // 固定长度数组
    s := arr[1:4]                // 创建切片 s，引用 arr[1], arr[2], arr[3]
    s[0] = 99                    // 修改切片元素
    fmt.Println(arr)             // 输出：[1 99 3 4 5] —— 底层数组被修改
}
```
**核心价值**：切片提供了动态扩容、方便的截取操作，是 Go 中最常用的数据结构之一。



## 二、底层结构：`reflect.SliceHeader`
切片在 Go  runtime 中的底层表示是一个 **`reflect.SliceHeader`** 结构体（或者 `runtime.slice`），包含三个字段：

```go
type SliceHeader struct {
    Data uintptr // 指向底层数组的指针
    Len  int     // 切片长度（len() 返回值）
    Cap  int     // 切片容量（cap() 返回值，即 Data 开始到数组末尾的长度）
}
```

**各字段含义**：
- **Data**：指向底层数组的起始地址（指针）；
- **Len**：切片中元素的数量（访问 `s[i]` 时，`i` 必须 `< len(s)`）；
- **Cap**：从切片的起始元素到底层数组末尾的元素数量（决定了不重新分配内存时最多能 `append` 多少元素）。

> **类比**：可以把切片看作是对底层数组的一个“窗口”，`Len` 是窗口的可见宽度，`Cap` 是窗口最大可扩展到的宽度（受底层数组长度限制）。



## 三、核心机制：切片的创建与扩容

### 1. 创建切片的三种方式
1. **从数组或切片截取**  
   ```go
   arr := [5]int{1, 2, 3, 4, 5}
   s1 := arr[1:3]   // len=2, cap=4（底层数组从 arr[1] 到 arr[4]）
   s2 := s1[1:2]    // len=1, cap=3（底层数组不变）
   ```

2. **使用 `make` 创建**  
   ```go
   s := make([]int, 3, 5) // len=3, cap=5
   ```
   - 会创建一个长度为 5 的底层数组，并让切片指向它的前 3 个元素。

3. **使用字面量创建**  
   ```go
   s := []int{1, 2, 3} // len=3, cap=3
   ```
   - 编译器会先创建一个数组，再创建切片指向该数组。



### 2. 切片的 append 与扩容机制
`append` 是切片动态增长的关键，但需要注意：
- 如果 `len(s) < cap(s)`，直接在原有底层数组上追加元素，**不会新建数组**；
- 如果 `len(s) == cap(s)`，会触发**扩容**：分配一块更大的新数组，将旧数组元素复制过去，再追加新元素。

**扩容策略（Go 1.18+）**：
- 如果新容量 **小于 256**，则新容量 = **旧容量 × 2**；
- 如果新容量 **大于等于 256**，则新容量 = **旧容量 × 1.25**（四舍五入）；
- 扩容后容量会**向上取整到下一个内存对齐的规格**（如 8、16、32、64...）。

**示例**：
```go
s := make([]int, 0, 1)
s = append(s, 1) // len=1, cap=1（未扩容）
s = append(s, 2) // len=2, cap=2（扩容 ×2）
s = append(s, 3) // len=3, cap=4（扩容 ×2）
s = append(s, 4) // len=4, cap=4（未扩容）
s = append(s, 5) // len=5, cap=8（扩容 ×2）
```



## 四、关键特性：切片的几个重要行为

### 1. 切片是引用类型，但不是指针类型
- 切片本身是一个 **值类型**（拷贝的是 `SliceHeader` 三个字段），但它**引用**了底层数组；
- 传递切片到函数时，会复制 `Data/Len/Cap`，但 `Data` 指针仍指向同一个底层数组，因此修改元素会影响原切片；
- 但如果在函数内 `append` 导致扩容，新切片会指向新数组，外部原切片不受影响。

**示例**：
```go
func modify(s []int) {
    s[0] = 99      // 影响外部切片
    s = append(s, 100) // 若触发扩容，s 指向新数组，外部不受影响
}

func main() {
    s := []int{1, 2, 3}
    modify(s)
    fmt.Println(s) // 输出：[99 2 3]
}
```


### 2. 切片截取与共享底层数组
- 切片截取 `s[low:high]` 会创建一个新的切片，但**共用同一个底层数组**；
- 修改新切片的元素会影响原切片，除非发生扩容。

**示例**：
```go
s1 := []int{1, 2, 3, 4}
s2 := s1[1:3]
s2[0] = 99
fmt.Println(s1) // [1 99 3 4]
```



### 3. nil 切片与空切片
- **nil 切片**：`Data=nil, Len=0, Cap=0`（未初始化的切片）；
- **空切片**：`Len=0, Cap=0`，但 `Data` 指向一个空数组（非 nil）；
- 两者 `len` 和 `cap` 都是 0，在 `append` 时都会分配新数组；
- 区别在于底层指针是否为 nil。

**示例**：
```go
var s1 []int      // nil 切片
s2 := make([]int, 0) // 空切片
s3 := []int{}     // 空切片
```



## 五、适用场景
- **动态数据集合**：长度不确定的元素序列；
- **作为函数参数传递**：高效传递大数组（避免拷贝整个数组）；
- **滑动窗口**：利用切片截取实现滑动窗口算法；
- **缓冲区**：网络编程、文件读写中的缓冲区。



## 六、面试延伸：加分考点

### 1. 切片和数组的区别
| 对比维度 | 数组 | 切片 |
|----------|------|------|
| 长度 | 固定（声明时确定） | 可变（`append` 动态扩容） |
| 类型 | `[N]T`（长度是类型的一部分） | `[]T`（长度不是类型的一部分） |
| 内存 | 直接存储数据 | 引用底层数组（间接存储） |
| 传递成本 | 拷贝整个数组（O(N)） | 拷贝 SliceHeader（O(1)） |



### 2. 为什么切片作为函数参数可以修改原数据？
因为切片传递的是 `SliceHeader` 的副本，但 `Data` 指针指向同一个底层数组，所以修改元素会影响原切片。  
只有当 `append` 导致扩容时，副本的 `Data` 才会指向新数组，与原切片“脱钩”。


### 3. 切片的扩容策略有什么特点？
- 小切片（容量 < 256）每次翻倍；
- 大切片（容量 ≥ 256）每次增加 25%；
- 扩容后的容量会做内存对齐，以提高分配效率。


## 七、总结：面试答题模板（直接套用）
> Go 切片是基于底层数组的动态视图，底层结构是一个包含 Data/Len/Cap 的 SliceHeader。  
> Data 指向底层数组，Len 是当前元素个数，Cap 是最大可用元素个数。  
> 创建方式有三种：数组截取、make、字面量。  
> append 操作在容量不足时触发扩容，小切片翻倍，大切片增加 25%，并做内存对齐。  
> 切片是引用类型，传递时拷贝的是 SliceHeader，但修改元素会影响原数组，除非扩容导致重新分配。  
> 切片与数组的主要区别在于长度是否固定、类型是否包含长度、传递成本等。  
> 常见注意点：nil 切片与空切片的区别、共享底层数组的副作用、扩容机制的性能影响。
