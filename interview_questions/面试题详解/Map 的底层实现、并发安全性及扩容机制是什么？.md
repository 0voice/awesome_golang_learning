## Map 的底层实现、并发安全性及扩容机制是什么？
先帮大家理清解答思路：先拆解 Map 底层数据结构（核心是哈希表），再分析并发场景下的问题，最后讲扩容的触发条件和执行逻辑，层层递进更易理解~

### 一、Map 底层实现：哈希表（数组 + 链表 / 红黑树）
Go 的 Map 本质是哈希表，用“数组 + 链表 / 红黑树”解决哈希冲突，结构像“桶装葡萄”：

#### 1. 基础结构
- 顶层是`hmap`结构体（保存全局信息），包含数组指针`buckets`、元素数量`count`、扩容阈值`loadFactor`等；
- 底层是`bmap`数组（即“桶”），每个`bmap`能存 8 个键值对，超出后用链表挂载，链表长度超 6 时自动转红黑树（提升查询效率，从 O(n)→O(logn)）。

#### 2. 查询流程
```go
// 举例：map["name"] = "Jett"
```
1. 对`key`做哈希计算，得到哈希值；
2. 取哈希值低几位 → 定位到`bmap`数组的索引（找“桶”）；
3. 取哈希值高几位 → 在`bmap`内部匹配`key`（找“葡萄”）；
4. 找到后返回对应的`value`，没找到则返回零值。

### 二、并发安全性：非线程安全！这些坑要避
Go 原生 Map 不支持并发读写，多协程操作会直接`panic`，原因是底层没有加锁，并发修改会破坏哈希表结构。

#### 1. 问题复现
```go
func main() {
    m := make(map[int]int)
    // 协程1写
    go func() {
        for i := 0; i < 1000; i++ {
            m[i] = i
        }
    }()
    // 协程2读
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println(m[i])
        }
    }()
    time.Sleep(1*time.Second)
}
// 运行结果：fatal error: concurrent map read and map write
```

#### 2. 解决方案
- 用`sync.Map`（Go 1.9 + 新增，内置锁，支持并发读写）；
- 自己加锁：`sync.Mutex`（互斥锁）或`sync.RWMutex`（读写锁，读多写少场景更高效）。

### 三、扩容机制：什么时候扩？怎么扩？
当 Map 元素太多，“桶”装不下时会自动扩容，核心是解决哈希冲突，保证查询效率。

#### 1. 触发条件
- 条件 1：`count / 桶数量 > 6.5`（负载因子超阈值，桶太满）；
- 条件 2：溢出链表长度超 25（冲突太多，链表太长）。

#### 2. 扩容两种方式
- **翻倍扩容**：当负载因子超 6.5 时，新桶数量 = 旧桶数量 ×2，同时重新哈希所有键值对，分配到新桶（耗时但彻底解决拥挤）；
- **等量扩容**：当溢出链表太长但负载因子不高时，新桶数量 = 旧桶数量，仅重新整理键值对到新桶（解决“桶内碎片”，比如大量删除元素后，桶内空位置多但溢出链表长的情况）。

#### 3. 扩容特点
- **渐进式扩容**：不会一次性把所有键值对迁移完，而是每次操作 Map 时迁移一部分，避免单次扩容耗时太长，影响程序响应。

### 💡 面试小贴士
被问 Map 时，除了答底层 / 并发 / 扩容，还可以主动提：
- Map 的 key 为什么不能是切片？（因为切片不可比较，哈希计算需要 key 可比较）；
- sync.Map 的实现原理？（用“读写分离”，读用原子操作，写加锁，适合读多写少场景）。

这样回答更全面，面试官会觉得你理解很深入~
