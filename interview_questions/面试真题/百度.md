## 百度
### 1. 异步的协程如果报错了怎么办，怎么处理这种问题
- 协程内通过 `defer + recover` 捕获 panic，避免程序崩溃：在协程启动函数中添加 `defer func() { if err := recover(); err != nil { 处理错误 } }()`。
- 错误传递：通过 channel 将错误发送到主协程集中处理，或使用 `context` 传递错误状态。
- 日志记录：捕获错误时详细记录堆栈信息，便于排查（如结合 `log.Printf("%+v", err)`）。


### 2. 如果进程内存占满了，怎么在代码层面追踪，怎么在linux查看
- **代码层面**：使用 `pprof` 分析堆内存分配（`net/http/pprof` 暴露接口，通过 `go tool pprof` 查看），定位内存泄漏点（如未释放的全局缓存、goroutine 泄漏）；在关键位置打印内存使用（`runtime.ReadMemStats`）。
- **Linux 查看**：`top -p 进程ID` 查看内存占用；`pmap -x 进程ID` 分析内存分布；`ps aux | grep 进程名` 查看 RSS/VSS 指标；`cat /proc/进程ID/status` 查看详细内存信息（如 HeapUsage）。


### 3. 进程端口号被占用了，怎么查看
- Linux 中：`lsof -i :端口号` 直接查看占用端口的进程（PID 和进程名）；`netstat -tunlp | grep 端口号` 显示监听该端口的进程（需 root 权限）；`ss -tunlp | grep 端口号` 类似 netstat，更高效。
- 找到 PID 后，可用 `kill -9 PID` 终止进程。


### 4. kafka幂等性
- 指生产者发送消息时，即使重试，Broker 也只会持久化一次消息，避免重复写入。
- 实现：通过 `enable.idempotence=true` 开启，Kafka 为每个生产者分配 PID，每条消息附加序列号，Broker 依据 PID+序列号去重，确保同一消息仅被处理一次。
- 局限：仅保证单分区、单会话内的幂等，跨分区或生产者重启后需配合事务机制。


### 5. redis连续执行多个set和get会有什么问题
- **网络开销大**：每次操作单独发送命令，频繁的网络往返耗时（尤其客户端与 Redis 远程连接时）。
- **性能损耗**：Redis 单线程处理，过多命令会增加处理压力，且无法利用批量操作的优化。
- 解决：使用管道（pipeline）批量发送命令，减少网络交互；或用 `MSET`/`MGET` 替代多个单命令。


### 6. redis批处理
- **管道（pipeline）**：客户端将多个命令缓冲后一次性发送，Redis 批量执行并返回结果，减少网络往返（适用于非事务性命令）。
- **事务（MULTI/EXEC）**：将命令放入队列，`EXEC` 原子执行，中间不会插入其他命令（但不支持回滚，仅保证原子性）。
- **脚本（Lua）**：通过 `EVAL` 执行 Lua 脚本，实现复杂逻辑的原子执行（如结合多个命令计算结果），减少网络和执行开销。


### 7. go代码判断问题，断言和slice方面的
- **断言**：`x.(T)` 用于判断接口类型是否为 T，失败会 panic；安全方式是 `v, ok := x.(T)`，通过 ok 判断是否断言成功，避免 panic。
- **slice**：判断是否为空用 `len(s) == 0`（而非 `s == nil`，nil 切片 len 也为 0）；访问越界会 panic；切片扩容可能导致底层数组更换，需注意引用关系。


### 8. 什么时候会触发panic，应对panic的机制
- **触发场景**：数组越界、空指针引用、类型断言失败、向关闭的 channel 发送数据、调用 `panic()` 手动触发等。
- **应对机制**：使用 `defer + recover` 捕获 panic（`recover()` 仅在 defer 中有效），可记录错误并恢复程序执行；对于不可恢复的错误，可捕获后优雅退出（如关闭资源后 `os.Exit(1)`）。


### 9. mysql查询语句时间很长怎么办
- 用 `EXPLAIN` 分析执行计划，查看是否走索引、扫描行数、是否使用临时表/文件排序。
- 优化索引：添加缺失索引，删除冗余索引，避免函数/表达式操作索引列（如 `WHERE SUBSTR(name,1,3)='abc'` 无法走索引）。
- 改写 SQL：拆分复杂查询，优化子查询为 JOIN，分页查询优化（如 `LIMIT 100000,10` 改为基于主键定位）。
- 调整参数：增大 `innodb_buffer_pool_size` 提高缓存命中率，优化 `join_buffer_size` 等连接参数。
- 长期优化：分库分表，读写分离，冷热数据分离。


### 10. binlog是什么，及binlog的延时问题
- **binlog**：MySQL 的二进制日志，记录所有 DDL 和 DML 操作（除查询语句），用于数据恢复、主从复制。默认不开启，需在配置中设置 `log_bin=ON`。
- **延时问题**：主库写入 binlog 后，从库通过 IO 线程拉取并写入 relay log，SQL 线程执行，过程中可能因网络延迟、从库负载高、大事务等导致延时。
- 解决：优化网络带宽，从库配置更高性能硬件，限制大事务，开启半同步复制（至少一个从库确认接收 binlog 后才返回成功）。

### 11. TCP、UDP区别
- **连接性**：TCP是面向连接的协议（需三次握手握手建立连接）；UDP是无连接的，直接发送数据。
- **可靠性**：TCP通过序列号、确认重传、拥塞控制等保证数据可靠交付；UDP不保证可靠性，可能丢包、乱序。
- **效率**：TCP因可靠性机制开销大，传输效率低；UDP无额外开销，实时性好。
- **适用场景**：TCP用于对可靠性要求高的场景（如HTTP、文件传输）；UDP用于实时性要求高的场景（如视频通话、DNS）。


### 12. TCP三次握手
- 第一次：客户端发送SYN报文（同步序列编号），请求建立连接。
- 第二次：服务器收到SYN，回复SYN+ACK报文（同步+确认），确认客户端请求并发起自身同步。
- 第三次：客户端收到SYN+ACK，回复ACK报文（确认），服务器收到后连接建立。
- 目的：确保双方收发能力正常，协商初始序列号，避免历史无效连接干扰。


### 13. Golang channel
- 用于Goroutine间通信的管道，可传递数据或作为同步信号。
- 分为无缓冲（发送/接收需同步）和有缓冲（缓冲区满/空时阻塞）两种。
- 底层基于`hchan`结构体，包含缓冲区、等待队列、锁等，通过加锁保证并发安全。
- 支持`close()`关闭，关闭后发送会panic，接收返回零值+`false`；可配合`select`实现非阻塞操作。


### 14. Golang GC
- 并发、非分代、三色标记清除垃圾回收器，核心是减少STW（Stop The World）时间。
- 流程：准备阶段（STW，初始化状态）→ 并发标记（与用户协程并行，标记存活对象）→ 标记终止（STW，处理剩余对象）→ 并发清理（回收未标记对象）。
- 优化机制：混合写屏障（标记期间跟踪对象引用变化）、辅助标记（用户协程协助标记），确保低延迟。


### 15. Redis 渐进式扩容
- 哈希表扩容时，不一次性完成所有数据迁移，而是分多次进行，避免阻塞主线程。
- 触发条件：负载因子（键数量/槽位数量）超过阈值（默认1）。
- 过程：创建新哈希表，每次处理请求时迁移少量数据（如10个槽），直到旧表数据全部迁移到新表，释放旧表内存。
- 优势：避免扩容时的性能抖动，保证Redis高可用性。


### 16. Redis 为什么用TCP
- TCP提供可靠传输，确保命令和数据不丢失、不重复、按序到达，符合Redis作为数据存储的可靠性需求。
- Redis采用请求-响应模式，需要明确的交互确认，TCP的连接特性适配这种通信模式。
- 相比UDP，TCP的流控机制可避免Redis服务器被过量请求压垮，更适合处理复杂命令和批量操作。


### 17. Redis 持久化策略，怎么选择
- **RDB**：定时生成内存快照（二进制文件），优点是恢复快、开销小；缺点是可能丢失最近数据。
- **AOF**：记录所有写命令到日志，优点是数据安全性高（可每秒刷盘）；缺点是日志文件大、恢复慢。
- **选择依据**：  
  - 数据安全性要求高（如金融数据）：用AOF（`appendfsync everysec`）。  
  - 追求性能且可容忍少量数据丢失：用RDB。  
  - 兼顾安全与性能：开启RDB+AOF混合模式（AOF重写时融入RDB内容）。


### 18. Redis 缓存三件套
- **缓存穿透**：查询不存在的数据，穿透缓存直击数据库。解决：缓存空值、布隆过滤器过滤无效请求。
- **缓存击穿**：热点key过期瞬间，大量请求直击数据库。解决：互斥锁（如Redis的`SETNX`）、热点key永不过期。
- **缓存雪崩**：大量key同时过期或缓存集群宕机，请求全部压向数据库。解决：key过期时间加随机值、缓存集群高可用、服务熔断降级。


### 19. Epoll为什么快
- **事件驱动**：仅关注活跃的文件描述符（FD），无需轮询全部FD，减少无效操作。
- **内核级优化**：通过红黑树管理FD，事件就绪时直接回调，效率高于select/poll的数组遍历。
- **用户态与内核态交互少**：使用共享内存传递事件列表，避免大量数据拷贝。
- 支持水平触发（LT）和边缘触发（ET），ET模式下一次事件处理完所有数据，减少系统调用。


### 20. MySQL 隔离级别，如何解决幻读
- **隔离级别**：  
  - 读未提交（Read Uncommitted）：允许读未提交数据，有脏读、不可重复读、幻读。  
  - 读已提交（Read Committed）：只能读已提交数据，解决脏读，仍有不可重复读、幻读。  
  - 可重复读（Repeatable Read）：事务内读取数据一致，解决脏读、不可重复读，InnoDB默认级别。  
  - 串行化（Serializable）：事务串行执行，解决所有问题，性能最差。  
- **解决幻读**：InnoDB在可重复读级别通过MVCC（多版本并发控制）+ 间隙锁（锁定范围区间）防止幻读，确保事务期间看不到新插入的数据。


### 21. Kafka如何保证消息不丢失
- **生产者**：开启`acks=all`（所有ISR副本确认接收），设置重试次数（`retries>0`），避免网络波动导致的丢失。
- **Broker**：设置`min.insync.replicas>1`（至少2个副本同步数据），分区副本机制（多副本存储），防止单点故障。
- **消费者**：关闭自动提交（`enable.auto.commit=false`），处理完消息后手动提交offset，避免未处理完成却标记为已消费。
- 其他：定期备份数据，监控副本同步状态，避免ISR副本数量不足。

### 22. Redis都有哪些用途
- 缓存系统：存储热点数据，减轻数据库压力（如用户信息、商品详情）。
- 计数器：利用`INCR`实现高并发计数（如文章阅读量、接口调用次数）。
- 分布式锁：通过`SETNX`或`Redlock`实现跨服务资源互斥访问。
- 消息队列：用List的`LPUSH`/`RPOP`实现简单队列，或Stream实现更复杂的消息传递。
- 排行榜：基于ZSet的`ZADD`/`ZRANK`实现实时排名（如游戏积分、销量排行）。
- 会话存储：存储用户登录状态（如Session共享），支持分布式系统。
- 地理位置服务：通过GEO数据结构实现附近的人、POI搜索等功能。


### 23. Redis的数据结构你了解过有哪些
- String（字符串）：二进制安全，可存储文本、数字等，支持增删改查、计数等操作。
- Hash（哈希）：键值对集合，适合存储对象（如用户属性），支持单独操作字段。
- List（列表）：有序字符串集合，支持两端插入/删除，可实现队列、栈。
- Set（集合）：无序去重集合，支持交集、并集、差集等运算（如好友关系）。
- ZSet（有序集合）：带分数的Set，按分数排序，支持范围查询（如排行榜）。
- Bitmap（位图）：二进制位操作，适合存储布尔值序列（如用户签到、在线状态）。
- HyperLogLog：用于基数统计（如独立访客数），占用空间小。
- Geospatial（地理空间）：存储经纬度，支持距离计算、范围查询。


### 24. 解释一下跳表
- 跳表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，实现快速查询。
- 结构特点：由多层链表组成，底层是完整的有序链表，上层是稀疏索引；每层节点按key有序，高层节点是低层节点的子集。
- 查询过程：从最高层开始，若当前节点的下一个节点key大于目标，则降一层继续查找，直到找到目标或到达底层。
- 优势：平均查询/插入/删除复杂度为O(log n)，实现简单（相比红黑树），适合Redis的ZSet（兼顾排序和范围查询）。


### 25. MySQL的执行过程
1. 连接管理：客户端通过TCP连接MySQL，服务器验证身份（用户名/密码），分配连接线程。
2. 查询缓存（8.0版本已移除）：检查查询是否命中缓存，命中则直接返回结果。
3. 语法解析：对SQL进行词法/语法分析，生成解析树。
4. 预处理：检查解析树合法性（如表/字段是否存在），生成预处理树。
5. 查询优化：优化器选择最优执行计划（如索引选择、连接顺序），生成执行计划。
6. 执行器：按执行计划调用存储引擎接口，执行查询并返回结果。
7. 结果返回：将数据格式化后返回客户端，同时释放连接资源（或放入连接池）。


### 26. Innodb引擎使用的什么数据结构作为索引，为什么选这个数据结构
- InnoDB使用**B+树**作为索引的数据结构。
- 选择原因：
  - **有序性**：B+树是有序的平衡树，支持范围查询和排序，适合数据库的查询场景（如`WHERE`、`ORDER BY`）。
  - **磁盘友好**：B+树的非叶子节点仅存储索引键，叶子节点存储数据或主键（聚簇索引），层级少（通常3-4层），减少磁盘IO次数。
  - **聚簇索引特性**：叶子节点直接存储行数据，查询时无需回表（相比MyISAM的非聚簇索引），提高查询效率。
  - **稳定性**：B+树是平衡树，避免了二叉查找树在极端情况下退化为链表的问题，保证查询效率稳定。

### 27. 如果大量数据写入mysql会发生什么
- **写入性能下降**：大量写入会导致磁盘IO繁忙，尤其随机写入时磁头频繁移动，吞吐量下降；InnoDB的事务日志（redo log）和数据刷盘压力增大，可能触发频繁的fsync操作。
- **锁竞争加剧**：写入操作会加行锁或表锁，大量并发写入可能导致锁等待、死锁概率增加，影响其他读写操作。
- **缓冲池利用率降低**：新写入数据占用缓冲池（innodb_buffer_pool），可能挤出热点读数据，导致缓存命中率下降，读性能受影响。
- **binlog生成激增**：大量写入会产生庞大的binlog日志，增加主从复制的传输和应用压力，可能导致从库延迟。
- **临时表与排序压力**：若写入伴随复杂索引更新（如二级索引），可能产生大量临时表和排序操作，消耗CPU和内存资源。


### 28. 主从复制
- **概念**：MySQL主从复制是将主库的DDL和DML操作通过binlog同步到从库，实现数据一致的高可用方案，支持一主多从、级联复制等架构。
- **流程**：
  1. 主库：开启binlog，将所有写操作记录到binlog日志。
  2. 从库：IO线程连接主库，请求并读取binlog，写入本地relay log（中继日志）。
  3. 从库：SQL线程读取relay log，解析并执行其中的操作，同步数据到从库。
- **作用**：分担读压力（从库负责查询）、实现数据备份、故障转移（主库故障时切换到从库）。


### 29. 主从复制延迟的原因
- **网络延迟**：主库binlog传输到从库时，网络带宽不足或波动导致传输缓慢。
- **主库写入压力大**：主库高并发写入产生大量binlog，从库IO线程来不及同步。
- **从库性能不足**：从库硬件配置（CPU、内存、磁盘）低于主库，SQL线程执行binlog速度慢，尤其处理大事务时。
- **大事务影响**：主库执行长事务（如批量插入/更新），生成大型binlog，从库需耗时解析执行，导致延迟累积。
- **锁冲突**：从库SQL线程执行时遇锁等待（如从库有慢查询占用锁），阻塞同步进程。
- **参数配置不当**：主库binlog刷盘策略（如sync_binlog=0）导致binlog写入延迟，或从库innodb_buffer_pool_size过小影响执行效率。  

### 30. Go 和 Java 的区别
| 维度               | Go                                      | Java                                    |
|--------------------|-----------------------------------------|----------------------------------------|
| **类型与语法**     | 静态类型，语法简洁（无类/继承，接口隐式实现），支持值类型/引用类型分离 | 静态类型，基于类与继承，语法较繁琐，万物皆对象（基本类型需装箱） |
| **并发模型**       | 基于 Goroutine（轻量协程，初始栈 2KB）+ Channel，用户态调度，支持百万级并发 | 基于内核线程，重量级（栈 MB 级），依赖线程池，并发数量受限 |
| **内存管理**       | 自带并发 GC（三色标记+混合写屏障），STW 时间短，无手动管理 | 分代 GC（年轻代/老年代），STW 时间相对较长，需 JVM 调优 |
| **编译与部署**     | 编译为静态二进制文件，无依赖（无需虚拟机），启动毫秒级 | 编译为字节码，需 JVM 运行，部署依赖 JRE，启动较慢 |
| **生态与场景**     | 侧重云原生、高并发服务（如 K8s、Etcd），工具链轻量 | 生态庞大（Spring 全家桶），适合企业级应用、后端服务，兼容性强 |


### 31. 缓存穿透、雪崩、击穿的定义及解决方法
| 问题类型   | 定义                                                                 | 解决方法                                                                 |
|------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| **缓存穿透** | 查询不存在的数据，穿透缓存直击数据库，导致数据库压力激增               | 1. 缓存空值（设置短期过期）；2. 布隆过滤器过滤无效请求；3. 接口层参数校验（如非法 ID 拦截） |
| **缓存雪崩** | 大量缓存 Key 同时过期，或缓存集群宕机，请求全部压向数据库             | 1. Key 过期时间加随机值（避免集中过期）；2. 缓存集群高可用（如 Redis 哨兵/集群）；3. 服务熔断降级（限制数据库请求） |
| **缓存击穿** | 热点 Key 过期瞬间，大量请求同时直击数据库                             | 1. 互斥锁（如 Redis SETNX，只让一个请求更新缓存）；2. 热点 Key 永不过期（后台异步更新）；3. 提前预热热点数据 |


### 32. MySQL 回表查询，如何避免回表
- **回表定义**：当查询的列不在索引中时，需先通过索引找到主键，再通过主键索引（聚簇索引）查询完整行数据，这个“二次查询”过程就是回表。
- **避免方法**：
  1. **覆盖索引**：将查询所需列全部加入索引（如联合索引 `(a,b,c)` 覆盖 `SELECT a,b,c`），查询时直接从索引获取数据，无需回表；
  2. **主键查询优先**：若查询条件含主键，直接通过聚簇索引获取数据，无回表；
  3. **避免 select ***：只查询需要的列，减少非索引列的依赖，降低回表概率。


### 33. `count(*)`、`count(1)`、`count(0)` 的区别
- **功能一致**：三者最终结果均为“统计总行数”，包括 NULL 值行（与 `count(列名)` 不同，后者会排除列值为 NULL 的行）。
- **执行差异**：
  1. `count(*)`：MySQL 优化器会优先选择“成本最低的索引”（如聚簇索引）统计行数，无需扫描具体列；
  2. `count(1)`/`count(0)`：会扫描全表或索引，但无需读取列值（用 1/0 替代），执行效率与 `count(*)` 基本一致（优化器会将其视为等价操作）；
- **结论**：日常使用中 `count(*)` 更通用，优化器对其支持最好，三者性能无显著差异。


### 34. MongoDB 索引是什么结构
MongoDB 的索引默认基于 **B 树** 实现（具体为 B+ 树的变种，核心特性与 B+ 树一致）。  
- 特点：非叶子节点存储索引键，叶子节点存储文档的物理地址（或主键 `_id`）；  
- 适配场景：MongoDB 文档为非结构化数据，B 树的有序性和多层索引结构，能高效支持范围查询、排序等操作，且适配磁盘 IO 特性（减少层级，降低 IO 次数）。


### 35. B+ 树和 B 树的区别
| 特性               | B 树                                      | B+ 树                                    |
|--------------------|-------------------------------------------|----------------------------------------|
| **数据存储位置**   | 非叶子节点和叶子节点均存储数据（键+值）   | 仅叶子节点存储数据（键+值），非叶子节点只存索引键 |
| **叶子节点关联**   | 叶子节点无关联，是独立的                 | 叶子节点通过指针有序链接，支持范围查询高效遍历 |
| **查询效率**       | 查找数据可能在非叶子节点终止，效率不稳定  | 必须遍历到叶子节点，查询效率稳定（均为 O(log n)） |
| **磁盘 IO 成本**   | 非叶子节点存数据，单个节点容量小，层级可能更多，IO 次数多 | 非叶子节点仅存键，单个节点容量大，层级少，IO 次数少 |
| **适用场景**       | 内存数据库（如 MongoDB 早期版本）         | 磁盘数据库（如 MySQL InnoDB、Redis ZSet） |


### 36. 树越高会带来什么问题
- **磁盘 IO 次数增加**：树的层级对应“从磁盘读取节点的次数”（每一层一个节点需一次 IO），层级越高，需读取的节点越多，IO 耗时累积（磁盘 IO 比内存访问慢 5-6 个数量级）；
- **查询效率下降**：IO 次数增加直接导致查询耗时变长，尤其数据库索引基于磁盘存储时，层级过高会显著降低查询性能；
- **维护成本升高**：插入/删除数据时，需调整树的结构（如 B+ 树的分裂/合并），层级越高，调整涉及的节点越多，操作复杂度和耗时增加。


### 37. 每一次从树往下找会带来什么消耗
核心消耗是 **磁盘 IO 开销**，具体包括：  
1. **磁盘寻址耗时**：磁头需要移动到目标磁盘扇区，机械硬盘寻址耗时约 5-10ms（占比最高）；  
2. **数据传输耗时**：将磁盘节点的数据读入内存，取决于磁盘带宽（如 SATA 硬盘约 100-200MB/s）；  
3. **内存处理耗时**：在内存中比较节点内的索引键，确定下一层节点位置，耗时极短（纳秒级），可忽略；  
综上，每一层查找的主要消耗是磁盘 IO，这也是数据库索引优先选择 B+ 树（层级少）的核心原因。


### 38. 邮箱怎么建立索引，身份证怎么建立索引
#### （1）邮箱建立索引
- **索引类型**：优先建立 **普通 B+ 树索引**（适合等值查询、前缀查询）。  
- **设计要点**：  
  1. 邮箱格式固定（如 `user@domain.com`），无需分词，直接对完整邮箱字符串建索引；  
  2. 若需支持“按域名查询”（如查 `@xxx.com` 的所有用户），可建立 **前缀索引**（如 `index_email_domain (email(20))`，覆盖常见域名长度），避免全表扫描；  
  3. 避免过度索引：若邮箱仅用于登录（等值查询），单索引足够，无需多列联合索引。

#### （2）身份证建立索引
- **索引类型**：建立 **普通 B+ 树索引**（身份证号是唯一字符串，适合等值/范围查询）。  
- **设计要点**：  
  1. 身份证号长度固定（18 位，含数字和字母 `X`），按完整字符串建索引，支持精准查询（如查某个人的身份证）；  
  2. 若需支持“按出生地（前 6 位）”“出生日期（7-14 位）”查询，可建立 **函数索引**（如 `index_idcard_birth (SUBSTRING(idcard,7,8))`），避免对原字段修改；  
  3. 唯一性：若业务中身份证号唯一，可建立 **唯一索引**，避免重复数据插入，同时查询效率略高于普通索引。
