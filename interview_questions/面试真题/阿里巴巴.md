## 阿里巴巴
### 1. DNS的作用？DNS的解析流程？
- **作用**：将域名（如www.example.com）解析为对应的IP地址，实现域名到IP的映射，方便用户记忆和使用网络。
- **解析流程**：
  1. 本地域名服务器查询：先检查本地缓存，若有结果直接返回；
  2. 根域名服务器查询：本地无缓存时，向根服务器请求，根服务器返回顶级域名服务器地址；
  3. 顶级域名服务器查询：向顶级域名服务器（如.com）请求，返回权威域名服务器地址；
  4. 权威域名服务器查询：向权威服务器请求，获取域名对应的IP地址；
  5. 结果返回与缓存：将IP地址返回给客户端，并在本地域名服务器缓存结果。


### 2. 下一跳路由转发数据包的过程？
1. 路由器接收数据包，提取目的IP地址；
2. 查看路由表，根据最长前缀匹配原则确定下一跳IP地址和输出接口；
3. 更新数据包的TTL（减1），若TTL为0则丢弃并返回超时信息；
4. 重新计算IP头部校验和；
5. 将数据包从输出接口转发到下一跳路由器，重复上述过程直至到达目的主机。


### 3. go GMP模型是什么？线程与协程的区别？协程调度过程？P、M的数量问题？
- **GMP模型**：Go的调度模型，由G（Goroutine，协程）、M（Machine，系统线程）、P（Processor，逻辑处理器）组成，P是G和M的桥梁，负责管理G队列和绑定M。
- **线程与协程的区别**：线程是内核调度单位，栈MB级，切换开销大；协程是用户态调度单位，栈KB级，切换开销小，依赖线程执行。
- **协程调度过程**：P维护本地G队列，M绑定P后从队列取G执行；G阻塞时，M释放P并绑定新M；空闲P通过Work-Stealing从其他P或全局队列获取G。
- **P、M的数量**：P的数量默认等于CPU核心数（可通过GOMAXPROCS调整）；M的数量动态变化，默认无上限，通常略多于P，避免因M阻塞导致P闲置。


### 4. 协程切换的时机？
- 主动让出CPU：调用`runtime.Gosched()`主动放弃执行权；
- IO操作阻塞：如Channel收发、网络请求、文件读写等阻塞时；
- 系统调用：进入内核态执行系统调用时；
- 函数调用：函数调用时可能触发调度点；
- 抢占式调度：Go 1.14+支持，当G执行时间过长（默认10ms），会被其他G抢占。


### 5. channel的底层结构？接收、发送消息的过程？
- **底层结构**：基于`hchan`结构体，包含缓冲区（循环队列）、发送等待队列、接收等待队列、锁、元素类型信息、关闭标志等。
- **发送过程**：加锁后，若缓冲区未满或有等待的接收者，直接发送数据；否则当前G进入发送队列并阻塞，解锁后调度其他G。
- **接收过程**：加锁后，若缓冲区非空或有等待的发送者，直接接收数据；否则当前G进入接收队列并阻塞，解锁后调度其他G。


### 6. sema锁是什么？mutex源码中的结构有看过吗？
- **sema锁**：Go中的信号量锁，基于`runtime_semacquire`和`runtime_semrelease`实现，用于同步控制（如Channel的阻塞等待、WaitGroup等），支持阻塞和唤醒操作。
- **mutex源码结构**：`sync.Mutex`底层包含状态字段（`state`）和信号量（`sema`）。`state`记录锁的状态（是否锁定、是否有等待者、是否处于饥饿模式等），`sema`用于阻塞等待锁的Goroutine。


### 7. 讲讲正常模式和饥饿模式？
- **正常模式**：`sync.Mutex`默认模式，等待锁的Goroutine按FIFO顺序排队，被唤醒后需与新到来的Goroutine竞争锁，适合锁持有时间短的场景。
- **饥饿模式**：当Goroutine等待锁超过1ms仍未获取，进入饥饿模式，此时锁直接传递给队列头的Goroutine，新Goroutine不会参与竞争，而是加入队列尾部，适合锁持有时间长的场景，避免线程饥饿。
- 两种模式可自动切换：饥饿模式下，若队列头Goroutine释放锁且无其他等待者，或持有锁时间小于1ms，切换回正常模式。

## 阿里云一面
### 8. 有没有了解过消息队列？
了解过，消息队列是分布式系统中用于异步通信、解耦服务的中间件，核心作用是“削峰填谷”“异步解耦”“流量控制”。  
- 常见产品：RabbitMQ（基于AMQP协议，可靠性高）、Kafka（高吞吐，适合大数据场景）、RocketMQ（阿里开源，支持事务消息）、Pulsar（云原生，融合队列与流特性）；  
- 核心特性：消息持久化（避免数据丢失）、ACK确认机制（确保消息被消费）、重试机制（处理消费失败）、死信队列（存储无法消费的消息）；  
- 典型场景：订单创建后异步发送通知、秒杀场景削峰、日志异步采集、跨服务数据同步。


### 9. 介绍一下项目，为什么用 Go 写业务项目，而不是用 Java？
#### （1）项目示例（以“高并发API网关”为例）  
- 项目背景：为微服务集群提供统一入口，负责路由转发、鉴权、限流、监控；  
- 核心功能：基于请求路径路由到对应服务，JWT鉴权过滤非法请求，令牌桶算法实现接口限流，实时统计接口QPS与耗时；  
- 技术栈：Go（主语言）、Gin（Web框架）、Redis（存储限流令牌与鉴权缓存）、Prometheus+Grafana（监控）。

#### （2）选择 Go 而非 Java 的原因  
- **并发性能更优**：Go的Goroutine轻量（百万级并发无压力），用户态调度开销远低于Java线程（MB级栈，内核调度），适合高并发场景；  
- **编译与部署高效**：Go编译为静态二进制文件，无需JVM，部署时无需依赖环境，启动速度快（毫秒级），Java需依赖JRE，启动慢且部署包较大；  
- **内存占用低**：Go无JVM内存 overhead，同等业务下内存占用通常比Java低30%-50%；  
- **语法简洁，开发效率高**：Go语法简洁（无复杂继承、泛型早期虽弱但够用），内置并发工具（Channel、sync包），无需像Java那样依赖第三方框架（如Spring）实现并发；  
- **适合云原生场景**：Go对容器化（Docker）、微服务的支持更轻量，生态中云原生工具（K8s、Etcd）均为Go开发，技术栈统一。


### 10. 有没有了解过分布式文件系统？
了解过，分布式文件系统是将文件存储在多个节点（服务器）上，通过统一接口提供文件访问的系统，核心解决“海量文件存储”“高可用”“可扩展”问题。  
- 常见产品：  
  - HDFS（Hadoop生态，适合大数据离线存储，分NameNode（元数据）和DataNode（数据存储））；  
  - GlusterFS（开源，基于哈希分块，支持弹性扩展）；  
  - Ceph（统一存储，支持文件、块、对象存储，高可靠）；  
  - 阿里云OSS、AWS S3（云厂商分布式文件存储服务，按需付费）；  
- 核心特性：数据分片存储（分散压力）、多副本（避免单点故障，通常3副本）、元数据管理（记录文件位置与属性）、容错机制（节点故障时自动切换副本）；  
- 典型场景：海量日志存储、视频/图片存储、大数据离线计算数据存储。


### 11. Linux 的虚拟网络设备相关知识？
Linux 虚拟网络设备是内核模拟的网络设备，无实体硬件，用于实现主机内部、主机间或容器间的网络通信，常见类型及作用：  
- **TUN/TAP**：TUN（三层，处理IP报文）、TAP（二层，处理以太网帧），用于VPN、容器网络（如OpenVPN、Docker网络），实现用户态与内核态的数据包交互；  
- **Bridge（网桥）**：模拟物理交换机，连接多个网络接口（如容器网卡、物理网卡），实现同一主机内不同设备的二层通信（如Docker的bridge模式）；  
- **VETH Pair（虚拟以太网对）**：成对出现的虚拟网卡，一端发送的数据包会直接传递到另一端，用于容器间、容器与主机的通信（如Docker容器与宿主机的连接）；  
- **Loopback（回环设备，lo）**：本地回环接口，IP为127.0.0.1，用于主机内部进程间的网络通信（如本地服务访问localhost）；  
- **VLAN（虚拟局域网）**：基于802.1Q协议，在物理网卡上划分多个虚拟VLAN接口，实现同一物理网络中不同逻辑网络的隔离；  
- 核心原理：虚拟设备的数据包由内核网络子系统处理，无需经过物理网卡，转发效率高，且可通过iptables、tc等工具进行流量控制。


### 12. 有没有了解 TCP 的握手和挥手过程，以及 SSL 的握手？
#### （1）TCP 三次握手（建立连接）  
目的：确保双方收发能力正常，协商初始序列号（ISN）。  
1. 客户端（C）→ 服务器（S）：SYN报文（标记SYN=1），携带客户端ISN（x）；  
2. 服务器（S）→ 客户端（C）：SYN+ACK报文（SYN=1，ACK=1），携带服务器ISN（y）和确认号（x+1）；  
3. 客户端（C）→ 服务器（S）：ACK报文（ACK=1），携带确认号（y+1）；  
完成后，TCP连接建立，进入ESTABLISHED状态。

#### （2）TCP 四次挥手（关闭连接）  
目的：确保双方数据均已发送完成，优雅关闭连接。  
1. 客户端（C）→ 服务器（S）：FIN报文（FIN=1），表示C无数据发送；  
2. 服务器（S）→ 客户端（C）：ACK报文（ACK=1），确认收到FIN，此时S仍可发送数据；  
3. 服务器（S）→ 客户端（C）：FIN+ACK报文（FIN=1，ACK=1），表示S无数据发送；  
4. 客户端（C）→ 服务器（S）：ACK报文（ACK=1），确认收到FIN；  
服务器收到ACK后关闭连接，客户端等待2MSL（确保S收到ACK）后关闭连接。

#### （3）SSL 握手（以TLS 1.2为例，建立加密通信）  
目的：协商加密算法、交换密钥、验证身份，确保后续HTTP通信加密。  
1. 客户端→服务器：Client Hello（携带支持的TLS版本、加密套件、客户端随机数Client Random）；  
2. 服务器→客户端：Server Hello（选择TLS版本和加密套件）+ 服务器证书（含公钥）+ 服务器随机数Server Random；  
3. 客户端：验证服务器证书（通过CA链）→ 生成预主密钥Pre-Master Secret，用服务器公钥加密后发送给服务器；  
4. 服务器：用私钥解密Pre-Master Secret；  
5. 双方：用Client Random、Server Random、Pre-Master Secret计算相同的会话密钥（对称加密密钥）；  
6. 双方：发送Finished报文（用会话密钥加密），确认握手完成，后续HTTP数据用会话密钥加密传输。

---

### 13. 请简单介绍 Go 语言的基本数据类型。
- **基本类型**：布尔型（bool）、整数型（int/int8/int16/int32/int64、uint/uint8等）、浮点型（float32/float64）、复数型（complex64/complex128）、字符串（string）。
- **复合类型**：数组（[n]T）、切片（[]T）、映射（map[K]V）、结构体（struct）、指针（*T）、通道（chan T）、函数（func）、接口（interface）。


### 14. 你知道 Go 模块管理工具是如何工作的么？如何解决版本冲突？
- **工作原理**：Go 模块（go mod）通过 go.mod 文件管理依赖，记录模块路径、依赖项及其版本；go.sum 文件存储依赖的哈希值，确保依赖完整性。使用 `go get` 拉取依赖，`go mod tidy` 自动添加/移除依赖。
- **版本冲突解决**：当依赖项版本冲突时，Go 会选择最低兼容版本；可通过 `replace` 指令临时替换依赖版本，或手动指定统一版本（如 `go get 包@版本号`）。


### 15. Go 的并发模型是什么？请简单说说 goroutine。
- **并发模型**：基于 GMP 模型（Goroutine、Machine、Processor），通过用户态调度实现高效并发。
- **goroutine**：轻量级协程，由 Go 运行时管理，初始栈 2KB 且可动态伸缩，创建成本低（单机可创建数百万个）；通过 `go` 关键字启动，与其他 goroutine 并发执行，依赖系统线程（M）调度运行。


### 16. 如何保证并发安全？
- 使用互斥锁（sync.Mutex）或读写锁（sync.RWMutex）控制共享资源访问；
- 通过 channel 传递数据，实现“以通信代共享”；
- 对简单类型使用 sync/atomic 原子操作；
- 避免共享状态，采用不可变数据结构。


### 17. 能说说 select 语句吗？
select 语句用于同时监听多个 channel 的读写操作，仅执行其中就绪的 case：
- 若多个 case 就绪，随机选择一个执行；
- 若无就绪 case，且有 default 分支，则执行 default；
- 若无就绪 case 且无 default，会阻塞直到某个 case 就绪；
- 常用来实现超时控制、通道间同步、非阻塞读写等。


### 18. 你用过 Gin 或 Echo 吗？分别简单介绍下。
- **Gin**：高性能 HTTP 框架，基于 Radix 树路由，支持中间件、参数绑定、JSON 渲染等；API 简洁，性能接近原生，适合构建 RESTful API，社区活跃，插件丰富（如日志、限流）。
- **Echo**：轻量高性能框架，路由基于前缀树，支持上下文扩展、中间件链式调用、自动 TLS 等；设计简洁，内存占用低，适合构建微服务或高性能接口。


### 19. 如果你要写个中间件实现日志记录，思路是什么？
- 定义中间件函数，接收 `next http.Handler` 作为参数；
- 在中间件中记录请求开始时间、方法、路径、客户端 IP 等信息；
- 通过 `next.ServeHTTP(c)` 调用后续处理逻辑；
- 处理完成后，记录响应状态码、耗时等，输出完整日志（如结合 zap、logrus 等库）；
- 在框架中注册中间件（如 Gin 的 `router.Use(loggerMiddleware())`），使其对所有路由生效。


### 20. 如何处理请求的 JSON 绑定？
- 在 Gin/Echo 中，通过上下文提供的 Bind 方法绑定 JSON 数据到结构体；
- 定义结构体并通过 tag（如 `json:"field"`）指定 JSON 字段映射；
- 调用绑定方法（如 Gin 的 `c.ShouldBindJSON(&struct)`），框架自动解析请求体并填充结构体；
- 检查绑定错误（如字段类型不匹配、必填项缺失），返回相应的错误响应（如 400 Bad Request）。
