## 快手
### 1. 时间轮算法的优点
时间轮算法是一种高效的定时任务调度机制，核心优点包括：  
- **高效的时间管理**：通过环形数组（“轮”）+ 指针实现，将定时任务按时间哈希到不同槽位，插入和触发的时间复杂度接近 O(1)，适合大量定时任务场景。  
- **低资源消耗**：相比定时器链表（如每次遍历查找最近到期任务），无需频繁排序或遍历，CPU 和内存开销更小。  
- **可扩展性强**：支持多层时间轮（如秒轮、分轮、时轮），通过级联触发处理长周期任务，避免单轮数组过大。  
- **稳定性高**：任务触发延迟可控，适合对实时性要求不极致但需高吞吐量的场景（如消息队列的延迟投递、服务心跳检测）。  


### 2. context怎么用的
Go 的 `context.Context` 用于在 goroutine 之间传递上下文信息（如超时控制、取消信号、元数据），核心用法：  
- **创建上下文**：  
  - `context.Background()`：根上下文，通常作为所有上下文的起点。  
  - `context.TODO()`：暂不确定用途时使用，语义上等同于 `Background`。  

- **派生上下文**（通过根上下文创建，形成上下文树）：  
  - `context.WithCancel(parent)`：创建可取消的上下文，调用 `cancel()` 时通知子上下文终止。  
  - `context.WithTimeout(parent, timeout)`：超时自动取消的上下文（内部基于 `WithCancel` 实现）。  
  - `context.WithDeadline(parent, deadline)`：指定截止时间的上下文。  
  - `context.WithValue(parent, key, value)`：携带键值对元数据（如请求 ID、用户信息）。  

- **使用场景**：  
  - 控制 goroutine 生命周期（如 HTTP 请求取消时终止后端 goroutine）。  
  - 传递超时/截止时间（如限制数据库查询时长）。  
  - 传递请求级元数据（避免函数参数过多）。  

示例：  
```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel() // 确保资源释放

go func(ctx context.Context) {
  select {
  case <-ctx.Done():
    fmt.Println("任务取消或超时:", ctx.Err())
    return
  case <-time.After(10 * time.Second):
    fmt.Println("任务完成")
  }
}(ctx)
```  


### 3. map为什么不安全？安全该用什么呢
- **map 不安全的原因**：  
  Go 原生 map 未实现并发安全控制，当多个 goroutine 同时对 map 执行 **写操作（包括修改、删除）** 或 **读写混合操作** 时，会触发运行时 panic（检测到数据竞争）。这是因为 map 底层哈希表的扩容、桶分裂等操作不是原子的，并发修改可能导致数据结构损坏（如链表断裂、索引错乱）。  

- **安全的替代方案**：  
  1. **加锁保护**：使用 `sync.Mutex` 或 `sync.RWMutex` 包裹 map 操作（读多写少场景优先用 `RWMutex` 提高并发度）。  
     ```go
     var mu sync.RWMutex
     m := make(map[string]int)
     
     // 写操作
     mu.Lock()
     m["key"] = 1
     mu.Unlock()
     
     // 读操作
     mu.RLock()
     val := m["key"]
     mu.RUnlock()
     ```  
  2. **使用 sync.Map**：Go 1.9+ 提供的并发安全 map，适合 **读多写少** 场景，通过双 map 结构（`read` 只读 map + `dirty` 加锁 map）减少锁竞争。  


### 4. 说一下GMP
GMP 是 Go 语言的并发调度模型，由 **G（Goroutine）、M（Machine）、P（Processor）** 三部分组成，核心目的是高效调度海量 goroutine 并充分利用 CPU 资源：  
- **G**：协程实体，包含执行栈、指令指针、状态（如运行中、阻塞）等信息，是调度的基本单位。  
- **M**：操作系统线程（OS Thread），负责实际执行 G，与物理 CPU 核心绑定。  
- **P**：逻辑处理器，作为 G 和 M 的中间层，维护本地可运行 G 队列（local runq），并持有内存分配、锁等资源。P 的数量由 `GOMAXPROCS` 控制（默认等于 CPU 核心数），限制并发执行的 M 数量。  

**调度流程**：  
1. G 创建后优先放入 P 的本地队列，若队列满则放入全局队列（global runq）。  
2. M 绑定 P 后，从 P 的本地队列或全局队列中获取 G 执行；若队列空，会从其他 P 的本地队列“窃取”G（工作窃取机制），平衡负载。  
3. 当 G 执行阻塞操作（如系统调用、锁等待），M 会与 P 分离，P 继续调度其他 G；阻塞结束后，G 重新进入队列等待调度。  


### 5. select 如果都触发了，golang如何选择执行哪个case分支
当 `select` 语句中多个 `case` 同时满足触发条件（如多个 channel 可读/可写），Go 会 **随机选择一个 case 执行**，而非按代码顺序执行。  

这种随机性是为了避免“饥饿”问题（即避免某一 case 长期被其他 case 抢占而无法执行），保证各 case 的公平性。  

示例：  
```go
ch1 := make(chan int, 1)
ch2 := make(chan int, 1)
ch1 <- 1
ch2 <- 1

select {
case <-ch1:
  fmt.Println("执行 ch1")
case <-ch2:
  fmt.Println("执行 ch2")
}
// 输出可能是 "执行 ch1" 或 "执行 ch2"，随机决定
```  


### 6. ch := make(chan int) ch<-1 fmt.Println(<-ch) 会不会死锁？为什么
**会发生死锁**。  

原因：代码中创建的是 **无缓冲 channel**（`make(chan int)`），其发送（`ch<-1`）和接收（`<-ch`）操作必须成对出现且由不同 goroutine 执行：  
- 无缓冲 channel 的发送操作会阻塞，直到有其他 goroutine 执行接收操作；  
- 同理，接收操作也会阻塞，直到有其他 goroutine 执行发送操作。  

上述代码在 **同一个 goroutine** 中先执行 `ch<-1`，会立即阻塞（因无其他 goroutine 接收），导致后续的 `<-ch` 无法执行，最终整个 goroutine 陷入永久阻塞，触发死锁。  

解决方法：将发送和接收放在不同 goroutine 中，或使用有缓冲 channel（如 `make(chan int, 1)`，缓冲大小至少为 1）。  


### 7. mysql为什么用b+树，对比b树、b-树的优势
MySQL（InnoDB 引擎）选择 B+ 树作为索引结构，相比 B 树、B-树（B 树的变种，通常指 B 树）的核心优势：  
1. **查询效率更稳定**：  
   - B+ 树的所有数据记录都存储在叶子节点，且叶子节点通过链表连接，无论查询哪个数据，都需遍历到叶子节点，查询时间复杂度固定为 O(logN)。  
   - B 树的非叶子节点也存储数据，查询效率不稳定（最好 O(1)，最坏 O(logN)）。  

2. **更适合范围查询**：  
   - B+ 树叶子节点形成有序链表，范围查询（如 `WHERE id > 100 AND id < 200`）只需定位首尾节点，通过链表遍历即可，效率极高。  
   - B 树需回溯父节点查找下一个范围，操作复杂。  

3. **磁盘 IO 效率更高**：  
   - B+ 树非叶子节点仅存储索引键（不存数据），相同磁盘页可容纳更多索引项，树的高度更低（通常 2-4 层），减少磁盘 IO 次数。  
   - B 树非叶子节点存储数据，索引项密度低，树更高，IO 开销大。  

4. **支持聚簇索引**：  
   - InnoDB 的主键索引是聚簇索引，叶子节点直接存储完整数据行，B+ 树的结构天然适合这种“索引即数据”的存储方式。  


### 8. 虚拟内存，物理内存是什么
- **物理内存**：计算机实际配备的硬件内存（如内存条），是 CPU 可直接访问的存储空间，速度快但容量有限（通常为 GB 级）。  

- **虚拟内存**：操作系统提供的一种内存抽象，允许程序使用比物理内存更大的地址空间。其核心原理是：  
  - 每个进程看到的是独立的连续地址空间（虚拟地址），由操作系统映射到物理内存或磁盘（如 swap 分区）。  
  - 当物理内存不足时，操作系统将不常用的内存数据换出到磁盘（换出），需要时再换入物理内存（换入），实现“内存扩容”。  

**关系**：虚拟内存通过内存映射表（页表）与物理内存关联，CPU 访问虚拟地址时，由 MMU（内存管理单元）转换为物理地址。虚拟内存屏蔽了硬件细节，简化了程序开发，并通过“局部性原理”高效利用物理内存。  


### 9. 进程间的通信方式
进程间通信（IPC）用于不同进程之间交换数据或同步操作，常见方式包括：  
1. **管道（Pipe）**：  
   - 半双工通信（单向数据流），适用于父子进程或兄弟进程，数据在内存中临时存储。  
   - 示例：Linux 中的 `|` 命令管道。  

2. **命名管道（FIFO）**：  
   - 突破管道的亲缘关系限制，允许任意进程通过路径名访问，支持双向通信。  

3. **信号（Signal）**：  
   - 操作系统向进程发送的异步通知（如 `SIGINT` 终止进程），携带简单信息（信号编号）。  

4. **消息队列**：  
   - 由内核维护的消息链表，进程可按类型发送/接收消息，避免管道的流式数据限制。  

5. **共享内存**：  
   - 多个进程共享同一块物理内存，是最快的 IPC 方式（无需内核中转），需配合信号量或互斥锁保证同步。  

6. **信号量（Semaphore）**：  
   - 用于进程间同步（如控制共享资源的访问），通过 P/V 操作实现互斥或协作。  

7. **套接字（Socket）**：  
   - 支持不同主机上的进程通信（网络通信），也可用于同一主机的进程间通信（如 `localhost` 端口）。  

8. **文件**：  
   - 通过读写磁盘文件交换数据，简单但效率低，适合不频繁通信或持久化场景。
  
### 10. GMP原理，一个P上的G阻塞了，M会阻塞吗；P和M一一一一对应吗
#### GMP原理
GMP是Go的并发调度模型，由G（Goroutine，协程）、M（Machine，操作系统线程）、P（Processor，逻辑处理器）组成：
- **G**：待执行的协程，包含执行栈、指令指针等信息。
- **M**：实际执行代码的操作系统线程，负责物理CPU核心绑定。
- **P**：逻辑处理器，维护本地G队列（可运行的G），持有内存分配、锁等资源，是G与M的中间层。

调度核心逻辑：P的数量由`GOMAXPROCS`控制（默认等于CPU核心数），M需绑定P才能执行G；M从P的本地队列或全局队列获取G执行，若队列空则从其他P“窃取”G（负载均衡）。


#### 一个P上的G阻塞了，M会阻塞吗？
分两种情况：
- **若G因系统调用（如文件IO、网络IO）阻塞**：M会与P分离（P可绑定其他M继续调度），M随G一起阻塞，直到系统调用返回后，G被放入全局队列等待重新调度。
- **若G因用户态操作（如channel读写、mutex锁等待）阻塞**：G会被放入等待队列，M不阻塞，继续从P的本地队列获取其他G执行。


#### P和M一一对应吗？
**不是**。  
- 运行中的M必须绑定一个P（1:1），但系统中M的总数可大于P的数量（如部分M因G阻塞而与P分离，处于闲置状态）。  
- P的数量固定（`GOMAXPROCS`），M的数量动态变化（由Go运行时根据阻塞情况创建或销毁），目的是充分利用CPU资源同时避免过多线程切换开销。


### 11. channel阻塞与非阻塞的区别
channel的阻塞/非阻塞特性由操作类型和缓冲区状态决定：

| 操作类型       | 无缓冲channel                  | 有缓冲channel（容量N）          |
|----------------|--------------------------------|---------------------------------|
| **发送（ch <- x）** | 阻塞：必须等待接收方就绪       | 非阻塞：缓冲区未满时直接存入；阻塞：缓冲区满时等待 |
| **接收（x <- ch）** | 阻塞：必须等待发送方就绪       | 非阻塞：缓冲区非空时直接取出；阻塞：缓冲区空时等待 |
| **关闭（close(ch)）** | 唤醒所有等待的G（接收方返回零值） | 唤醒所有等待的G（接收方返回剩余数据和false） |

- **阻塞场景**：用于强同步（如goroutine间“手拉手”协作），确保操作顺序。  
- **非阻塞场景**：用于异步通信（如生产者-消费者模型），通过缓冲区缓解并发压力。  
- **非阻塞操作**：可通过`select`的`default`分支实现，避免阻塞（如`select { case ch <- x: default: /* 处理非阻塞逻辑 */ }`）。


### 12. slice相关
#### 核心特性
- **结构**：由指针（指向底层数组）、长度（len，当前元素数）、容量（cap，底层数组大小）组成，是引用类型。
- **与数组的区别**：数组长度固定，是值类型；切片长度可变，动态扩容。


#### 关键操作
1. **创建**：  
   - `make([]T, len, cap)`：指定长度和容量（cap≥len）。  
   - `[]T{1,2,3}`：字面量初始化，len和cap等于元素数。  

2. **扩容机制**：  
   - 当`len == cap`时，`append`操作触发扩容：  
     - 新容量≤1024时，为原cap的2倍；  
     - 新容量>1024时，为原cap的1.25倍；  
     - 若需扩容至更大值（如一次性append大量元素），直接以实际需求为新cap。  
   - 扩容后生成新底层数组，原切片与新切片指向不同数组。

3. **切片截取**：  
   - `s[low:high]`：生成新切片，与原切片共享底层数组（修改会相互影响），新len=high-low，新cap=原cap-low。  
   - 若需脱离原数组，可通过`copy`创建独立切片（如`newS := make([]T, len(s[low:high])); copy(newS, s[low:high])`）。


### 13. map线程安全吗？怎么样实现sync.Map
#### map线程安全吗？
**不安全**。  
Go原生map的底层哈希表操作（如扩容、桶分裂）不是原子的，多个goroutine同时读写会导致数据竞争，触发运行时panic。


#### 如何实现sync.Map？
`sync.Map`是Go 1.9+提供的并发安全map，专为**读多写少**场景设计，核心实现：

1. **双map结构**：  
   - `read`：只读map（原子操作访问），存储稳定的键值对，无锁开销。  
   - `dirty`：需加锁访问的map，存储新写入或修改的键值对。  

2. **读操作**：  
   - 先查`read`，命中则直接返回；  
   - 未命中则加锁查`dirty`，并递增“未命中计数器”。  

3. **写操作**：  
   - 若`read`中存在该键且未标记为“过期”，尝试原子更新；  
   - 否则加锁写入`dirty`，并标记`read`中对应键为“过期”。  

4. **晋升机制**：  
   - 当`read`的未命中次数等于`dirty`的长度时，将`dirty`原子替换为`read`（清空`dirty`），减少后续读操作的锁竞争。  

5. **删除操作**：  
   - 标记`read`中的键为“过期”，若`dirty`存在该键则删除。  

优势：读操作几乎无锁开销，适合缓存等读多写少场景；劣势：写操作开销较大，写密集场景性能不如“map+Mutex”。

### 14. 如何优雅地结束一个goroutine  
优雅结束goroutine的核心是**通过通信通知退出**，避免暴力终止（如直接杀死进程），确保资源正确释放。常见方式如下：  

#### 1. 使用 `channel` 发送退出信号  
通过一个专用的退出通知channel（如 `done`），让goroutine在收到信号后主动退出。  
```go
func worker(done <-chan struct{}) {
    for {
        select {
        case <-done: // 收到退出信号
            fmt.Println("worker exit gracefully")
            return
        default: // 正常工作逻辑
            fmt.Println("working...")
            time.Sleep(1 * time.Second)
        }
    }
}

func main() {
    done := make(chan struct{})
    go worker(done)

    // 运行3秒后通知退出
    time.Sleep(3 * time.Second)
    close(done) // 关闭channel，所有监听者都会收到信号
    time.Sleep(1 * time.Second) // 等待worker完成退出
}
```  
**优点**：简单可靠，支持同时通知多个goroutine（关闭channel后所有接收者都会被唤醒）。  


#### 2. 使用 `context.Context` 传递取消信号  
适合多层goroutine嵌套场景（如父goroutine管理多个子goroutine），通过 `context.WithCancel` 传递取消信号。  
```go
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done(): // 收到取消信号
            fmt.Println("worker exit:", ctx.Err())
            return
        default:
            fmt.Println("working...")
            time.Sleep(1 * time.Second)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go worker(ctx)

    time.Sleep(3 * time.Second)
    cancel() // 触发取消信号
    time.Sleep(1 * time.Second)
}
```  
**优点**：支持上下文传递（如超时、截止时间），适合复杂的goroutine层级结构。  


#### 3. 结合 `sync.WaitGroup` 等待退出完成  
确保goroutine退出后再继续执行主逻辑，避免资源未释放导致的问题。  
```go
func worker(done <-chan struct{}, wg *sync.WaitGroup) {
    defer wg.Done() // 退出时通知WaitGroup
    for {
        select {
        case <-done:
            fmt.Println("worker exit")
            return
        default:
            fmt.Println("working...")
            time.Sleep(1 * time.Second)
        }
    }
}

func main() {
    done := make(chan struct{})
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(done, &wg)

    time.Sleep(3 * time.Second)
    close(done)
    wg.Wait() // 等待worker完全退出
    fmt.Println("main exit")
}
```  


#### 关键原则  
- **避免使用 `runtime.Goexit()`**：强制退出当前goroutine，但可能跳过 `defer` 语句，导致资源泄漏。  
- **退出前清理资源**：在goroutine退出逻辑中通过 `defer` 释放资源（如关闭文件、连接）。  
- **防止阻塞**：确保退出信号能被及时接收（如避免goroutine在非select逻辑中永久阻塞）。  

通过以上方式，可实现goroutine的安全、可控退出，保证程序稳定性。

### 15. go的struct怎么比较
Go 中结构体（struct）的比较规则取决于其字段类型：  
- **可比较的情况**：当结构体的所有字段都是可比较类型（如基本类型、指针、数组等，不含切片、map、函数等不可比较类型）时，结构体可直接用 `==` 或 `!=` 比较，比较结果为所有字段是否完全相等。  
- **不可比较的情况**：若结构体包含不可比较类型的字段（如 `[]int`、`map`），直接比较会触发编译错误。  

示例：  
```go
type A struct {
    x int
    y string
}

type B struct {
    x []int // 切片不可比较
}

func main() {
    a1 := A{1, "a"}
    a2 := A{1, "a"}
    fmt.Println(a1 == a2) // 输出 true（所有字段相等）

    b1 := B{[]int{1}}
    b2 := B{[]int{1}}
    // fmt.Println(b1 == b2) // 编译错误：包含不可比较字段
}
```  


### 16. go里面怎么做上下文，什么框架用的比较多
Go 中通过标准库 `context` 包实现上下文管理，核心是 `context.Context` 接口，用于在 goroutine 间传递取消信号、超时控制和元数据（如请求 ID）。  

**常用方法**：  
- `context.Background()`：创建根上下文（无父节点），作为所有上下文的起点。  
- `context.WithCancel(parent)`：创建可取消的上下文，返回 `cancel` 函数，调用时通知子上下文终止。  
- `context.WithTimeout(parent, timeout)`：创建超时自动取消的上下文（如限制请求处理时间）。  
- `context.WithValue(parent, key, value)`：携带键值对元数据（需注意 key 类型唯一性）。  

**使用较多的框架**：  
- 原生 `net/http`：HTTP 服务器处理请求时，会为每个请求创建 `*http.Request`，其 `Context()` 方法返回请求上下文，用于传递超时和取消信号。  
- Gin 框架：通过 `c.Request.Context()` 获取请求上下文，或使用 `gin.Context` 的 `Deadline()`、`Done()` 等方法集成上下文功能。  
- gRPC：内置支持 `context.Context`，用于控制 RPC 调用的超时、取消和元数据传递。  


### 17. go defer原理
`defer` 用于延迟执行函数调用（在当前函数返回前执行），常用于资源释放（如关闭文件、解锁），其核心原理：  
1. **栈式存储**：`defer` 语句会将延迟函数及参数打包成一个结构体，压入当前 goroutine 的 defer 栈（LIFO，后进先出）。  
2. **执行时机**：当函数执行到 `return` 语句时，会先执行 defer 栈中的所有函数（按栈顺序逆序执行），再返回结果。  
3. **参数预计算**：`defer` 函数的参数在声明时就已确定（预计算），而函数体内的变量值以执行时为准。  

示例：  
```go
func f() int {
    x := 1
    defer func(n int) { // 参数n在defer声明时计算（n=1）
        x += n
        fmt.Println("defer:", x) // 输出 defer: 3
    }(x)
    x = 2
    return x // 返回2（defer修改不影响返回值，因return已将x=2存入返回寄存器）
}
```  


### 18. 进程、线程、协程
| 维度         | 进程（Process）                | 线程（Thread）                  | 协程（Coroutine）              |
|--------------|--------------------------------|--------------------------------|--------------------------------|
| **定义**     | 操作系统资源分配的基本单位（独立内存、文件描述符） | 进程内的执行单元，共享进程资源 | 用户态轻量级“线程”，由程序调度 |
| **调度者**   | 操作系统内核（抢占式）          | 操作系统内核（抢占式）          | 程序自身或运行时（协作/抢占）   |
| **开销**     | 大（内存、上下文切换成本高）    | 中（共享资源，切换成本低于进程） | 极小（栈KB级，切换无需内核参与） |
| **并发能力** | 低（受系统进程数限制）          | 中（单进程线程数通常不超过千级） | 极高（单进程可支持百万级）      |
| **通信方式** | IPC（管道、socket等）           | 共享内存（需加锁）              | 通常通过channel或共享内存       |  


### 19. 软中断/硬中断
- **硬中断**：  
  由硬件设备（如网卡、键盘、磁盘）触发的中断（如网络数据包到达、按键输入），直接打断 CPU 执行，进入内核态处理。  
  特点：响应优先级高，处理时间短（通常仅做简单标记，复杂逻辑交给软中断）。  

- **软中断**：  
  由软件触发的中断（如系统调用、进程调度），或由硬中断触发的后续处理（如网卡接收数据包后的协议栈处理）。  
  特点：优先级低于硬中断，可延迟执行（如 Linux 中的 `ksoftirqd` 内核线程专门处理软中断），避免阻塞硬中断。  

**区别**：硬中断是硬件触发的紧急事件，软中断是软件层面的延迟处理机制，两者共同保证系统对事件的快速响应和高效处理。  


### 20. 静态库/动态库
- **静态库**：  
  编译时将库代码完整复制到可执行文件中，运行时不依赖外部库。  
  优点：可执行文件独立运行，无需部署库文件；缺点：文件体积大，库更新需重新编译程序。  
  示例：GCC 生成的 `.a` 文件，Go 编译时默认静态链接（无动态依赖）。  

- **动态库**：  
  编译时仅记录库引用，运行时由操作系统加载到内存并共享给多个程序。  
  优点：文件体积小，库更新无需重新编译程序；缺点：依赖外部库文件，缺失会导致程序无法运行。  
  示例：Linux 的 `.so` 文件，Windows 的 `.dll` 文件。  


### 21. tcp和udp的区别，tcp的开启和断开是谁发起
#### TCP与UDP的区别  
| 特性         | TCP（传输控制协议）            | UDP（用户数据报协议）          |
|--------------|--------------------------------|--------------------------------|
| **连接性**   | 面向连接（需三次握手建立连接）  | 无连接（直接发送数据）          |
| **可靠性**   | 保证数据有序、不丢失（重传、校验） | 不保证可靠性（可能丢失、乱序）  |
| **效率**     | 低（拥塞控制、确认机制开销）    | 高（无额外开销，适合实时场景）  |
| **适用场景** | 文件传输、HTTP/HTTPS等         | 视频通话、DNS、实时游戏等       |

#### TCP的开启和断开发起方  
- **连接开启**：由客户端发起，通过“三次握手”建立连接（客户端→服务器→客户端）。  
- **连接断开**：通常由客户端或服务器任一方发起，通过“四次挥手”关闭连接（主动方→被动方→被动方→主动方）。  


### 22. IO多路复用，讲一下select/poll/epoll
IO 多路复用是一种让单个进程/线程同时监听多个 IO 事件的机制，避免为每个 IO 操作创建线程，提升并发效率。  

- **select**：  
  - 通过数组存储文件描述符（FD），调用时传入读、写、异常事件集合，内核遍历检测就绪 FD。  
  - 缺点：FD 数量限制（默认 1024），每次调用需复制 FD 集合到内核，效率随 FD 数量增长下降。  

- **poll**：  
  - 用链表替代数组，突破 FD 数量限制，但核心逻辑与 select 一致（仍需遍历检测就绪 FD）。  
  - 缺点：仍需复制整个 FD 集合，遍历效率低（O(n)）。  

- **epoll**（Linux 特有）：  
  - 内核维护就绪 FD 列表，通过事件驱动机制（回调）通知用户态，无需遍历所有 FD。  
  - 优点：FD 无上限，无需重复复制 FD 集合，就绪检测效率 O(1)，支持水平触发（LT）和边缘触发（ET）。  

**总结**：epoll 性能最优，是高并发场景（如 Nginx、Redis）的首选；select/poll 兼容性好，但仅适合简单场景。  


### 23. http content-type介绍一下，除了application/json还接触过什么，介绍一下restful API
#### Content-Type  
用于表示 HTTP 请求/响应体的媒体类型（数据格式），告知接收方如何解析数据。  

除 `application/json`（JSON 格式）外，常见类型：  
- `text/html`：HTML 文档（网页）。  
- `text/plain`：纯文本。  
- `application/x-www-form-urlencoded`：表单数据（键值对，如 `name=xxx&age=18`）。  
- `multipart/form-data`：用于上传文件（可包含二进制数据）。  
- `image/jpeg`：JPEG 图片。  
- `application/xml`：XML 格式。  

#### RESTful API  
一种基于 HTTP 设计接口的规范，核心原则：  
- **资源导向**：用 URL 表示资源（如 `/users` 表示用户列表，`/users/1` 表示 ID=1 的用户）。  
- **HTTP 方法语义**：用方法表示操作（GET 查询、POST 创建、PUT 更新、DELETE 删除）。  
- **无状态**：每个请求包含所有必要信息，服务器不存储客户端状态。  
- **返回 JSON/XML**：通常用 JSON 作为响应格式，状态码反映操作结果（如 200 成功、404 资源不存在）。  


### 24. http请求方式（method）分别有什么特点
HTTP 常用请求方法及特点：  
- **GET**：请求获取资源（如查询数据），参数在 URL 中，无请求体，幂等（多次请求结果一致），有长度限制。  
- **POST**：提交资源（如创建数据），参数在请求体中，非幂等（多次提交可能产生副作用，如重复创建），无长度限制。  
- **PUT**：全量更新资源（如替换整条记录），幂等（多次请求结果相同）。  
- **PATCH**：部分更新资源（如仅修改某字段），非幂等（取决于实现）。  
- **DELETE**：删除资源，幂等（多次删除结果相同）。  
- **HEAD**：类似 GET，但仅返回响应头（无响应体），用于检查资源是否存在或获取元数据。  
- **OPTIONS**：获取目标资源支持的 HTTP 方法（跨域请求时的预检请求常用）。  


### 25. 有哪些状态码
HTTP 状态码分 5 类，常用码：  
- **1xx（信息）**：`100 Continue`（服务器已接收请求头，可继续发送体）。  
- **2xx（成功）**：  
  - `200 OK`：请求成功。  
  - `201 Created`：资源创建成功（如 POST 后）。  
- **3xx（重定向）**：  
  - `301 Moved Permanently`：永久重定向（URL 已变更）。  
  - `302 Found`：临时重定向。  
  - `304 Not Modified`：资源未修改（使用缓存）。  
- **4xx（客户端错误）**：  
  - `400 Bad Request`：请求参数错误。  
  - `401 Unauthorized`：未认证（需登录）。  
  - `403 Forbidden`：权限不足。  
  - `404 Not Found`：资源不存在。  
  - `405 Method Not Allowed`：请求方法不支持。  
- **5xx（服务器错误）**：  
  - `500 Internal Server Error`：服务器内部错误。  
  - `502 Bad Gateway`：网关错误（如反向代理后端不可用）。  
  - `503 Service Unavailable`：服务暂时不可用（如过载）。
 
### 26. gorm 有遇到一些坑吗？
使用 GORM 时可能遇到的常见问题：  
1. **默认软删除的坑**：若模型定义了 `gorm.DeletedAt` 字段（默认开启软删除），`Delete` 操作会仅标记 `deleted_at` 字段而非物理删除，查询时会自动过滤已软删除记录。若需物理删除，需用 `Unscoped().Delete(...)`。  
2. **零值更新被忽略**：GORM 默认忽略零值（如 `0`、`""`）更新，如需强制更新零值，需用 `Select` 指定字段（如 `db.Model(&user).Select("age").Update("age", 0)`）。  
3. **预加载（Preload）的嵌套查询问题**：多层嵌套预加载（如 `Preload("Orders.Products")`）可能产生复杂 SQL，需注意性能；条件预加载（`Preload("Orders", "status = ?", "paid")`）需确保条件正确。  
4. **事务提交/回滚的隐性问题**：事务中若执行 `Create` 后未显式 `Commit` 或 `Rollback`，可能导致连接泄漏；需用 `defer tx.Rollback()` 确保异常时回滚。  
5. **字段映射不一致**：结构体字段名与数据库列名默认按 `SnakeCase` 映射（如 `UserName` → `user_name`），自定义列名需用 `gorm:"column:custom_name"` 标签，否则可能查询不到数据。  


### 27. 你对 go 的常用的一些数据结构的实现有了解吗？
Go 标准库中常用数据结构的核心实现：  
- **切片（Slice）**：动态数组，底层是连续内存的数组，通过指针、长度（len）、容量（cap）管理，支持动态扩容（按规则翻倍）。  
- **映射（Map）**：哈希表实现，通过链地址法解决哈希冲突，底层由数组（桶）和溢出桶组成，大桶（`buckets`）存储键值对，小桶（`overflow buckets`）处理冲突。  
- **列表（List，`container/list`）**：双向链表，每个节点包含 `Value`、`Prev`、`Next` 指针，支持 O(1) 头/尾插入，O(n) 随机访问。  
- **堆（Heap，`container/heap`）**：基于切片实现的最小堆（需用户实现 `Interface` 接口），支持 O(logn) 插入/删除，常用于优先级队列。  
- **环形链表（Ring，`container/ring`）**：循环链表，节点首尾相连，适合实现缓冲区、轮询逻辑。  


### 28. slice、map、channel
#### Slice  
- **结构**：`struct { pointer *T; len int; cap int }`，引用底层数组，长度可变。  
- **核心特性**：支持 `append` 动态扩容，切片截取（`s[low:high]`）共享底层数组，需注意修改冲突；无内置并发安全，多 goroutine 操作需加锁。  

#### Map  
- **结构**：哈希表，底层由 `buckets` 数组（存储键值对）、`oldbuckets`（扩容时临时存储旧桶）、`hash0`（哈希种子）等组成。  
- **核心特性**：无序（Go 1.12+ 随机遍历），键必须可比较（不能是切片、map、函数）；非并发安全，多 goroutine 读写需用 `sync.Mutex` 或 `sync.Map`。  

#### Channel  
- **结构**：`struct { qcount uint; dataqsiz uint; buf unsafe.Pointer; sendx uint; recvx uint; closed uint32; elemtype *_type; sendq waitq; recvq waitq; lock mutex }`，包含缓冲区、等待队列、互斥锁。  
- **核心特性**：并发安全（内置锁），支持阻塞/非阻塞读写，可通过 `close` 关闭；无缓冲 channel 实现强同步，有缓冲 channel 实现异步通信。  


### 29. channel 是可以被 close 的，之后还可以读写吗？
- **关闭后读取**：可以读取，返回缓冲区剩余数据；若缓冲区为空，返回元素类型的零值和 `false`（需用 `v, ok := <-ch` 判断）。  
- **关闭后写入**：会触发 `panic`（写入已关闭的 channel 是非法操作）。  

示例：  
```go
ch := make(chan int, 2)
ch <- 1
ch <- 2
close(ch)

// 读取剩余数据
fmt.Println(<-ch) // 1
fmt.Println(<-ch) // 2
v, ok := <-ch
fmt.Println(v, ok) // 0 false（缓冲区空，返回零值和false）

// 写入已关闭的channel
// ch <- 3 // 触发panic: send on closed channel
```  


### 30. make 和 new 的一些区别
| 维度         | make                          | new                            |
|--------------|-------------------------------|--------------------------------|
| **作用**     | 初始化引用类型（切片、map、channel） | 为值类型（如int、struct）分配内存并返回指针 |
| **返回值**   | 返回类型本身（如 `[]int`、`map[string]int`） | 返回指向类型的指针（如 `*int`、`*struct{}`） |
| **内存初始化** | 会初始化底层数据结构（如切片的len、cap，map的哈希表） | 仅分配内存，初始化为零值（如 `*int` 指向 0） |
| **支持类型** | 仅支持 slice、map、channel      | 支持所有类型（值类型、引用类型的指针） |

示例：  
```go
// make初始化切片（返回[]int）
s := make([]int, 2, 4) // len=2, cap=4

// new初始化int（返回*int）
i := new(int) // *i = 0

// 错误用法
// new([]int) // 返回*[]int（指向nil切片的指针，需手动初始化）
// make(int) // 编译错误：make不支持值类型
```

### 31. Go与C++的对比
| 维度         | Go                            | C++                            |
|--------------|-------------------------------|--------------------------------|
| **内存管理** | 自动垃圾回收（GC），无需手动释放 | 手动管理内存（`new`/`delete`），需开发者控制生命周期 |
| **并发模型** | 基于Goroutine和Channel，轻量级协程调度 | 基于线程和锁（`pthread`/`std::thread`），需手动处理同步 |
| **编译方式** | 直接编译为机器码，编译速度快，无依赖 | 编译为机器码，编译过程复杂（预处理、编译、汇编、链接），可静态/动态链接 |
| **类型系统** | 静态类型，支持类型推断，无类继承（用组合替代） | 静态类型，支持复杂继承和多态，模板系统灵活但复杂 |
| **错误处理** | 显式返回`error`类型，需主动判断 | 基于异常（`try/catch`），可忽略异常导致崩溃 |
| **适用场景** | 云原生、后端服务、工具开发（高并发、简单高效） | 系统级开发、游戏引擎、高性能计算（追求极致性能） |
| **语法风格** | 简洁（少关键字、强制代码格式化） | 复杂灵活（多范式，兼容C语法，特性丰富） |


### 32. gRPC和HTTP的区别
| 维度         | gRPC                          | HTTP（RESTful）                |
|--------------|-------------------------------|--------------------------------|
| **传输协议** | 基于HTTP/2，支持多路复用、二进制帧 | 通常基于HTTP/1.1（文本传输），HTTP/2也可支持但较少用 |
| **数据格式** |  Protocol Buffers（二进制，体积小、解析快） | JSON/XML（文本，易读性好，解析开销大） |
| **接口定义** | 强类型，通过`.proto`文件定义服务和消息结构 | 无严格规范，依赖文档（如OpenAPI） |
| **通信方式** | 支持双向流、服务器推送（基于HTTP/2流特性） | 主要是请求-响应模式，流支持较弱 |
| **性能** | 更高（二进制传输、连接复用、高效序列化） | 较低（文本解析、连接开销大） |
| **适用场景** | 服务间通信（微服务内部）、高性能需求场景 | 前后端交互、对外API（易调试、兼容性好） |


### 33. 如何把JWT和用户对应起来
JWT（JSON Web Token）与用户关联的核心逻辑是**在令牌中嵌入用户唯一标识**，流程如下：  
1. **生成令牌时关联用户**：  
   用户登录成功后，服务器生成JWT，在Payload中包含用户唯一标识（如用户ID、用户名），示例：  
   ```json
   {
     "sub": "123456", // 用户ID（subject，标准字段）
     "name": "Alice", // 用户名（自定义字段）
     "exp": 1620000000 // 过期时间
   }
   ```  
   用服务器私钥签名后返回给客户端。  

2. **验证令牌时解析用户**：  
   客户端请求时在Header中携带JWT（`Authorization: Bearer <token>`），服务器验证流程：  
   - 验证签名（确保令牌未被篡改）；  
   - 检查过期时间（`exp`字段）；  
   - 解析Payload中的用户标识（如`sub`字段），关联到对应的用户数据（如从数据库查询用户信息）。  

3. **安全性补充**：  
   - 敏感信息（如密码）不放入Payload（JWT可解码，仅签名防篡改）；  
   - 短期过期+刷新令牌机制，减少令牌泄露风险。  


### 34. 令牌桶算法原理
令牌桶算法是一种流量控制机制，核心原理：  
1. **令牌生成**：系统以固定速率（如10个/秒）向桶中放入令牌，桶有最大容量（如100个），令牌满时多余令牌丢弃。  
2. **请求处理**：  
   - 每个请求需从桶中获取1个令牌，获取成功则处理请求；  
   - 无令牌时拒绝请求或等待（根据策略）。  
3. **突发流量处理**：桶中积累的令牌可应对短时间突发流量（如桶满时允许一次性处理100个请求），超过桶容量的突发流量会被限流。  

优势：既限制长期平均速率，又允许合理的短期突发，适合大多数限流场景（如API网关、接口保护）。


### 35. 令牌桶算法和其他限流方式的对比
| 限流方式       | 核心原理                     | 优势                          | 劣势                          | 适用场景                     |
|----------------|------------------------------|-------------------------------|-------------------------------|------------------------------|
| **令牌桶**     | 固定速率生成令牌，请求需获取令牌 | 支持突发流量，灵活性高         | 实现稍复杂，需维护令牌生成逻辑 | 大多数API限流、网关控制       |
| **漏桶**       | 请求进入桶中，固定速率流出     | 严格控制输出速率，平滑流量     | 不支持突发流量（突发请求会排队） | 网络传输限流（如TCP拥塞控制） |
| **计数器**     | 固定时间窗口内计数，超过阈值限流 | 实现简单，易于理解             | 存在临界问题（窗口切换时突发） | 简单场景（如接口QPS限制）     |
| **滑动窗口**   | 时间窗口划分为小格，滑动计数   | 缓解计数器的临界问题           | 实现复杂，性能开销略高         | 对精度要求较高的限流场景     |


### 36. MySQL索引有哪几种
MySQL常见索引类型：  
1. **主键索引（PRIMARY KEY）**：  
   - 唯一标识表中记录，一个表只能有一个主键，不允许NULL值，自动创建聚簇索引（InnoDB）。  

2. **唯一索引（UNIQUE）**：  
   - 索引列值必须唯一（允许NULL值，多个NULL不冲突），用于保证数据唯一性（如用户名）。  

3. **普通索引（INDEX）**：  
   - 最基本的索引，无唯一性限制，仅用于加速查询（如`INDEX idx_age (age)`）。  

4. **联合索引（Composite Index）**：  
   - 对多个列创建索引（如`INDEX idx_name_age (name, age)`），遵循“最左前缀原则”，可优化多条件查询。  

5. **全文索引（FULLTEXT）**：  
   - 用于长文本字段（如`TEXT`）的关键词搜索（如文章内容检索），InnoDB和MyISAM均支持，仅适用于`CHAR`、`VARCHAR`、`TEXT`类型。  


### 37. 主键索引和唯一索引的区别
| 维度         | 主键索引（PRIMARY KEY）       | 唯一索引（UNIQUE）             |
|--------------|-------------------------------|--------------------------------|
| **数量限制** | 一个表只能有一个主键索引       | 一个表可以有多个唯一索引       |
| **NULL值允许** | 不允许NULL值                  | 允许NULL值（多个NULL不冲突）   |
| **聚簇索引** | InnoDB中主键索引是聚簇索引（数据与索引存储在一起） | 非聚簇索引（索引与数据分离，需回表） |
| **用途**     | 唯一标识记录，确保表中每行唯一性 | 保证特定列值唯一（如邮箱、手机号） |
| **自动创建** | 若表无主键，InnoDB会自动选择非NULL唯一索引作为聚簇索引；若无则隐式创建 | 需手动创建                     |


### 38. MySQL两种存储引擎的区别和应用场景
以最常用的**InnoDB**和**MyISAM**为例：  

| 特性         | InnoDB                        | MyISAM                         |
|--------------|-------------------------------|--------------------------------|
| **事务支持** | 支持ACID事务、事务回滚         | 不支持事务                     |
| **锁机制**   | 行级锁（适合高并发写）、表级锁 | 仅表级锁（写操作阻塞所有读写） |
| **外键支持** | 支持外键约束                  | 不支持外键                     |
| **索引类型** | 聚簇索引（主键索引包含数据）   | 非聚簇索引（索引与数据分离）   |
| **崩溃恢复** | 支持（通过redo/undo日志）      | 不支持（崩溃后可能数据损坏）   |
| **全文索引** | 支持（MySQL 5.6+）            | 支持                           |
| **性能**     | 写操作性能好，读性能略低       | 读操作性能好，写性能差         |

**应用场景**：  
- **InnoDB**：需事务支持、高并发写操作的场景（如电商订单、金融交易）。  
- **MyISAM**：只读或读写少的场景（如日志表、静态数据查询），已逐渐被InnoDB替代。  


### 39. 介绍一下B+树
B+树是一种多路平衡查找树，MySQL索引的核心数据结构，特点：  
1. **结构**：  
   - 非叶子节点：仅存储索引键（不存数据），用于索引查找；  
   - 叶子节点：存储完整索引键和数据（或主键，用于回表），且叶子节点通过双向链表连接。  

2. **优势**：  
   - **查询效率稳定**：所有数据在叶子节点，查询时间复杂度固定为O(logN)；  
   - **范围查询高效**：叶子节点链表支持快速范围扫描（如`id > 100 AND id < 200`）；  
   - **磁盘友好**：非叶子节点存储更多索引键，树高更低（通常2-4层），减少磁盘IO。  

3. **与B树的区别**：  
   - B树非叶子节点存储数据，查询效率不稳定；B+树仅叶子节点存数据，更适合索引场景。  


### 40. Redis支持的数据类型有哪些
Redis支持多种数据类型，核心包括：  
1. **String（字符串）**：最基本类型，可存储文本、数字（如`SET name "Alice"`），支持自增（`INCR count`）、拼接等操作。  
2. **Hash（哈希）**：键值对集合，适合存储对象（如用户信息：`HSET user:1 name "Alice" age 20`）。  
3. **List（列表）**：有序字符串列表，支持两端插入/删除（`LPUSH`/`RPOP`），可实现队列、栈。  
4. **Set（集合）**：无序不重复元素集合，支持交集（`SINTER`）、并集（`SUNION`）等集合操作。  
5. **Sorted Set（有序集合，ZSet）**：带分数的Set，元素按分数排序（`ZADD rank 90 "Alice"`），适合排行榜、范围查询。  
6. **其他类型**：  
   - Bitmap（位图）：二进制位操作，适合存储布尔值集合；  
   - HyperLogLog：用于基数统计（如独立访客数）；  
   - Geospatial：存储地理位置信息，支持距离计算。  


### 41. Bitmap的应用场景有哪些
Bitmap（位图）是用二进制位表示数据存在性的结构（1表示存在，0表示不存在），适合以下场景：  
1. **用户签到**：用1位表示用户某天是否签到（如365位可存储一年签到记录），节省空间且支持快速统计（如`BITCOUNT`计算签到天数）。  
2. **权限控制**：用不同位表示不同权限（如bit0表示读、bit1表示写），通过位运算（`AND`/`OR`）快速判断权限。  
3. **去重统计**：如统计网站独立访客（UV），用用户ID映射到位图位置，`BITCOUNT`可快速计算UV数（比Set更省内存）。  
4. **布隆过滤器底层**：多个Bitmap组合实现布隆过滤器，用于快速判断元素是否存在（如缓存穿透防护）。  
5. **状态标记**：如订单状态（已支付、已发货等），用位标记不同状态，高效查询符合条件的记录。  

优势：内存占用极低（1字节可表示8个状态），位运算（与、或、非）高效。
