## 奇安信
### 1. Redis 的数据结构  
Redis 提供了多种核心数据结构，每种结构有特定的应用场景：  

1. **字符串（String）**  
   - 存储字符串、整数或二进制数据（最大 512MB）。  
   - 常用命令：`SET`（设置）、`GET`（获取）、`INCR`（自增）、`EXPIRE`（设置过期时间）。  
   - 场景：缓存用户信息、计数器（如点赞数）、分布式锁（`SET NX`）。  

2. **哈希（Hash）**  
   - 键值对集合，适合存储对象（如用户信息：`id:1 {name:"Alice", age:20}`）。  
   - 常用命令：`HSET`（设置字段）、`HGET`（获取字段）、`HGETALL`（获取所有字段）。  
   - 场景：存储对象属性，避免序列化开销。  

3. **列表（List）**  
   - 有序字符串列表（双向链表实现），支持两端操作。  
   - 常用命令：`LPUSH`（左插入）、`RPOP`（右弹出）、`LRANGE`（获取范围元素）。  
   - 场景：消息队列、最新消息列表（如朋友圈）。  

4. **集合（Set）**  
   - 无序、唯一元素集合，支持交集、并集、差集运算。  
   - 常用命令：`SADD`（添加）、`SMEMBERS`（获取所有元素）、`SINTER`（交集）。  
   - 场景：去重（如用户标签）、共同好友计算。  

5. **有序集合（Sorted Set）**  
   - 带分数的有序集合（分数决定排序），底层用跳跃表 + 哈希表实现。  
   - 常用命令：`ZADD`（添加元素及分数）、`ZRANK`（获取排名）、`ZRANGEBYSCORE`（按分数范围查询）。  
   - 场景：排行榜（如游戏积分排名）、范围统计。  

6. **其他高级结构**  
   - **Bitmap**：位操作，适合海量数据统计（如用户签到：1 表示签到，0 表示未签）。  
   - **HyperLogLog**：基数统计（如独立访客数 UV，占用内存极小）。  
   - **Geospatial**：地理空间数据（如附近的人，基于经纬度计算距离）。  


### 2. MySQL 主从同步（数据复制）  
MySQL 主从同步是将主库数据复制到从库，实现读写分离和容灾，核心流程如下：  

1. **同步原理**  
   - 基于 **binlog（二进制日志）**：主库将所有写操作记录到 binlog，从库读取并执行这些日志，保持数据一致。  

2. **同步步骤**  
   1. **主库写入 binlog**：主库执行 `INSERT`/`UPDATE`/`DELETE` 后，将操作记录到 binlog（按事件格式存储）。  
   2. **从库请求 binlog**：从库的 `IO 线程` 连接主库，请求新的 binlog 事件，主库的 `dump 线程` 发送 binlog 到从库。  
   3. **从库存储中继日志**：从库的 `IO 线程` 将接收的 binlog 写入本地 `relay log（中继日志）`。  
   4. **从库执行中继日志**：从库的 `SQL 线程` 读取中继日志，解析并执行其中的 SQL 语句，同步数据到从库。  

3. **同步模式**  
   - **异步复制**（默认）：主库写入 binlog 后立即返回，不等待从库确认，可能丢失数据（主库崩溃时）。  
   - **半同步复制**：主库等待至少一个从库接收 binlog 后再返回，平衡性能与安全性。  

4. **应用场景**  
   - 读写分离：主库负责写，从库负责读，分散数据库压力。  
   - 数据备份：从库作为备份，主库故障时可切换到从库。  


### 3. Go 的 GMP 模型  
GMP 是 Go 语言的协程（goroutine）调度模型，通过三级结构实现高效并发：  

- **G（Goroutine）**：协程本身，包含栈、程序计数器、状态（如运行中、等待中）等信息。  
- **M（Machine）**：操作系统内核线程，是实际执行代码的载体（绑定 CPU 核心）。  
- **P（Processor）**：逻辑处理器，作为 G 和 M 的桥梁，包含本地协程队列、调度器状态、内存缓存等。  

#### 核心机制  
1. **调度流程**  
   - 协程创建后，优先放入 P 的本地队列（小队列，无锁），若本地队列满则放入全局队列。  
   - M 绑定 P 后，从 P 的本地队列取 G 执行；若本地队列为空，会从全局队列或其他 P 的本地队列“窃取”G（工作窃取机制），平衡负载。  

2. **阻塞处理**  
   - 当 G 执行阻塞操作（如系统调用、`channel` 读写）：  
     - 若为**可阻塞操作**（如 `time.Sleep`），G 被标记为“等待中”，放入等待队列，M 继续执行其他 G。  
     - 若为**系统调用**，M 与 P 解绑，P 可绑定新 M 执行剩余 G；系统调用完成后，G 重新进入队列等待调度。  

3. **优势**  
   - 充分利用多核 CPU（每个 P 对应一个核），支持百万级协程高效调度，切换开销远低于线程（用户态调度，无需内核介入）。  


### 4. Linux 的常用命令  
#### 文件/目录操作  
- `ls`：列出目录内容（`ls -l` 详细信息，`ls -a` 显示隐藏文件）。  
- `cd`：切换目录（`cd ..` 上级目录，`cd ~` 家目录）。  
- `mkdir`：创建目录（`mkdir -p a/b` 递归创建）。  
- `cp`：复制文件/目录（`cp -r src dest` 复制目录）。  
- `mv`：移动/重命名（`mv file dir/` 移动到目录，`mv old new` 重命名）。  
- `rm`：删除（`rm -rf file` 强制删除文件/目录，慎用）。  
- `cat`：查看文件内容（`cat file`）；`tail -f file` 实时查看日志。  

#### 进程管理  
- `ps`：查看进程（`ps aux` 显示所有进程）。  
- `top`/`htop`：动态查看进程资源占用（按 `q` 退出）。  
- `kill`：终止进程（`kill -9 PID` 强制杀死进程）。  

#### 系统信息  
- `df -h`：查看磁盘空间（人类可读单位）。  
- `free -h`：查看内存使用情况。  
- `uname -a`：查看系统内核信息。  

#### 网络操作  
- `ifconfig`/`ip addr`：查看网络接口与 IP。  
- `ping host`：测试网络连通性。  
- `netstat -tuln`：查看监听端口（`ss -tuln` 更高效）。  


### 5. Docker 中拷贝文件到容器的命令  
使用 `docker cp` 命令，格式：  
```bash
docker cp 本地文件路径 容器ID或名称:容器内目标路径
```  

示例：  
- 将本地 `./app.conf` 拷贝到容器 `mycontainer` 的 `/etc/` 目录下：  
  ```bash
  docker cp ./app.conf mycontainer:/etc/
  ```  

- 拷贝目录（需加 `-r` 递归）：将本地 `./data` 目录拷贝到容器 `mycontainer` 的 `/var/` 目录：  
  ```bash
  docker cp -r ./data mycontainer:/var/
  ```  

说明：  
- 容器需处于运行或停止状态（但需存在）。  
- 若目标路径不存在，会自动创建（目录）或覆盖（文件）。  


### 6. 排序算法时间复杂度  
| 排序算法       | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |  
|----------------|----------------|----------------|----------------|------------|--------|  
| 冒泡排序       | O(n²)          | O(n²)          | O(n)           | O(1)       | 稳定   |  
| 选择排序       | O(n²)          | O(n²)          | O(n²)          | O(1)       | 不稳定 |  
| 插入排序       | O(n²)          | O(n²)          | O(n)           | O(1)       | 稳定   |  
| 希尔排序       | O(n^1.3)       | O(n²)          | O(n)           | O(1)       | 不稳定 |  
| 快速排序       | O(n log n)     | O(n²)          | O(n log n)     | O(log n)   | 不稳定 |  
| 归并排序       | O(n log n)     | O(n log n)     | O(n log n)     | O(n)       | 稳定   |  
| 堆排序         | O(n log n)     | O(n log n)     | O(n log n)     | O(1)       | 不稳定 |  
| 计数排序       | O(n + k)       | O(n + k)       | O(n + k)       | O(n + k)   | 稳定   |  
| 基数排序       | O(d(n + k))    | O(d(n + k))    | O(d(n + k))    | O(n + k)   | 稳定   |  

- 注：`n` 为数据规模，`k` 为数据范围，`d` 为最大数的位数。  


### 7. 令牌桶算法原理  
令牌桶算法是**流量控制（限流）** 的经典算法，核心是通过“令牌”控制请求速率：  

1. **算法模型**  
   - 系统维护一个“令牌桶”，按固定速率（如 100 个/秒）往桶中放入令牌。  
   - 桶有最大容量，令牌满后不再放入（避免溢出）。  
   - 每个请求需要从桶中获取 1 个令牌：  
     - 若获取到令牌，请求被处理；  
     - 若桶中无令牌，请求被限流（拒绝或排队）。  

2. **特点**  
   - **支持突发流量**：桶中积累的令牌可应对短时间的流量峰值（如桶容量 100，突发 100 个请求可一次性处理）。  
   - **速率可控**：通过调整令牌生成速率，精确控制长期平均流量（如限制接口 QPS 为 1000）。  

3. **应用场景**  
   - API 接口限流（防止过载）、消息队列削峰（控制消费速率）、网关流量控制（如 Nginx 的 `limit_req` 模块基于令牌桶）。  

示例：若令牌生成速率为 5 个/秒，桶容量 10，则：  
- 平稳期：每秒处理 5 个请求，令牌不积累。  
- 突发期：某秒有 15 个请求，桶中 10 个令牌 + 新生成 5 个，可处理 15 个；后续若无突发，令牌重新积累。


### 8. 对象存储的原理和框架实现  
#### 原理  
对象存储（Object Storage）是一种以“对象”为单位存储数据的架构，适用于海量非结构化数据（如图片、视频、日志），核心原理：  
- **数据单元**：数据以“对象”形式存储，每个对象包含三部分——数据本身、元数据（描述信息，如大小、创建时间、自定义标签）、唯一标识符（如UUID）。  
- **扁平化结构**：无文件系统的目录层级，所有对象直接存储在“桶（Bucket）”中，通过唯一标识符访问，避免传统文件系统的目录树性能瓶颈。  
- **分布式架构**：数据分散存储在多个节点，通过冗余副本（如3副本）保证高可用，通过一致性哈希实现负载均衡。  

#### 框架实现（主流方案）  
1. **开源框架**：  
   - **Ceph**：统一存储系统，支持对象存储（RGW组件）、块存储、文件系统，通过CRUSH算法管理数据分布，适合大规模部署。  
   - **MinIO**：兼容S3 API的轻量级对象存储，部署简单（单节点或分布式），支持纠删码（节省存储空间），适合开发测试和中小规模生产环境。  
   - **Swift（OpenStack Swift）**：OpenStack生态的对象存储组件，采用环状结构（Ring）管理存储节点，适合多租户场景。  

2. **核心组件**：  
   - **API网关**：提供RESTful API（如S3、Swift API），处理对象的增删改查请求。  
   - **元数据服务**：管理对象元数据（如存储位置、权限），通常用分布式数据库（如etcd、Cassandra）存储。  
   - **数据节点**：实际存储对象数据，支持水平扩展，通过副本或纠删码保证数据可靠性。  


### 9. beego 和 gin 框架的优缺点对比  
| 维度         | beego                                  | gin                                      |  
|--------------|----------------------------------------|------------------------------------------|  
| **定位**     | 全栈框架（MVC架构，内置多种组件）       | 轻量级Web框架（仅专注HTTP路由与中间件）   |  
| **优势**     | 1. 功能完备：内置ORM、Session、日志、配置管理等，开箱即用；<br>2. 开发效率高：通过bee工具生成项目骨架，自动路由注册；<br>3. 文档完善，适合新手快速上手。 | 1. 性能优异：路由基于Radix树实现，速度极快（接近原生net/http）；<br>2. 灵活性高：仅提供核心功能，可按需集成第三方库（如gorm、zap）；<br>3. 中间件生态丰富，易于扩展。 |  
| **劣势**     | 1. 相对臃肿：内置组件多，若仅需简单API，资源占用较高；<br>2. 灵活性低：框架约束较强，定制化需修改源码或绕开框架机制。 | 1. 功能基础：需手动集成ORM、日志等组件，初期配置成本高；<br>2. 对新手不友好：文档较简洁，需自行摸索最佳实践。 |  
| **适用场景** | 快速开发完整Web应用（如后台管理系统、企业级应用）。 | 高性能API服务（如微服务、高并发接口）、对灵活性要求高的场景。 |  


### 10. 进程、线程和协程的区别  
| 维度         | 进程                     | 线程                     | 协程（Goroutine）         |  
|--------------|--------------------------|--------------------------|---------------------------|  
| **定义**     | 资源分配的基本单位       | CPU调度的基本单位        | 用户态轻量级线程          |  
| **资源**     | 独立内存空间、文件描述符等 | 共享进程资源，独有栈和寄存器 | 共享线程资源，栈动态伸缩（KB级） |  
| **调度**     | 内核调度（抢占式）       | 内核调度（抢占式）       | 用户态调度（协作式/抢占式，如Go有内核辅助） |  
| **切换开销** | 大（切换页表、内存映射） | 中（切换栈、寄存器）     | 极小（仅保存少量寄存器）   |  
| **并发能力** | 低（受系统资源限制）     | 中（单进程可创建数千个） | 极高（单进程可创建数百万个） |  
| **隔离性**   | 高（进程崩溃不影响其他） | 低（线程崩溃可能导致进程崩溃） | 低（依赖线程，协程崩溃可能影响同线程其他协程） |  


### 11. 一个进程创建子进程后，子进程可继承父进程的资源  
子进程通过**fork()系统调用**创建，继承父进程的大部分资源，主要包括：  
1. **内存空间**：代码段、数据段、堆（但写时复制，子进程修改后会独立分配内存）。  
2. **文件描述符表**：打开的文件、socket、管道等（共享文件指针，如父子进程读写同一文件会相互影响）。  
3. **进程信息**：环境变量、工作目录、信号处理方式（`signal handler`）、用户ID/组ID。  
4. **其他**：共享内存段、信号量、消息队列等进程间通信资源。  

**不继承的资源**：  
- 进程ID（PID）、父进程ID（PPID）。  
- 内存锁（`mlock`锁定的内存页）。  
- 计时器、 pending 信号（未处理的信号）。  


### 12. 全局变量在初始化前后的存储程序段  
全局变量在初始化前后存储的程序段**不同**：  
1. **初始化前**：  
   - 未初始化的全局变量（包括显式初始化为0的变量）存放在 **.bss段**（Block Started by Symbol）。  
   - 特点：仅占用符号表空间，不占用实际磁盘空间，程序加载时由内核初始化为0。  

2. **初始化后**：  
   - 已初始化且值非0的全局变量存放在 **.data段**（Data Segment）。  
   - 特点：占用磁盘空间，程序加载时直接从磁盘读取初始值到内存。  

**补充**：  
- 常量（如`const`定义的变量）存放在 **.rodata段**（Read-Only Data），只读不可修改。  
- 示例：  
  ```c
  int a;          // .bss段（未初始化）
  int b = 0;      // .bss段（初始化为0）
  int c = 10;     // .data段（初始化为非0）
  const int d = 5;// .rodata段（常量）
  ```  


### 13. Go语言的核心特性  
Go语言设计聚焦“简单、高效、并发”，核心特性包括：  
1. **简洁的语法**：无类继承、无泛型（1.18后支持）、无异常处理（用`error`返回），代码可读性高，学习成本低。  
2. **原生支持并发**：通过`goroutine`（轻量级协程）和`channel`实现并发，`go`关键字一键启动协程，无需手动管理线程。  
3. **静态类型与编译型**：编译为机器码，执行效率接近C；静态类型检查，减少运行时错误。  
4. **内存安全**：内置垃圾回收（GC），无需手动管理内存；指针不支持算术运算，避免野指针。  
5. **接口隐式实现**：无需显式声明“implements”，类型只要实现接口的所有方法即视为实现该接口，灵活度高。  
6. **工具链完善**：内置`go build`（编译）、`go test`（测试）、`go mod`（依赖管理），支持交叉编译（如在Linux编译Windows程序）。  
7. **标准库丰富**：`net/http`（Web服务）、`encoding/json`（序列化）、`sync`（并发工具）等，开箱即用。  


### 14. Go语言的内存模型与GC  
#### 内存模型  
Go的内存模型定义了**多协程访问共享变量时的可见性规则**，核心是“ happens-before ”原则：  
- 若操作A happens-before 操作B，则A的结果对B可见。  
- 保证可见性的机制：  
  - **初始化**：包级变量的初始化按声明顺序执行，依赖的包先初始化。  
  - **`goroutine`启动**：`go`语句之前的操作 happens-before 协程内的操作。  
  - **`goroutine`结束**：协程内的操作不保证 happens-before 协程结束后的操作（需用`sync.WaitGroup`等同步）。  
  - **`channel`通信**：发送操作 happens-before 接收操作完成；关闭channel happens-before 接收“零值”。  
  - **锁操作**：`Mutex.Lock()` 之前的 `Unlock()` happens-before 后续的 `Lock()`。  

#### GC（垃圾回收）  
Go的GC是**并发标记-清除算法**，目标是低延迟，核心流程：  
1. **标记阶段**：  
   - **初始标记（STW）**：暂停所有协程，标记根对象（全局变量、栈对象），耗时微秒级。  
   - **并发标记**：恢复协程，后台线程并发遍历对象引用，标记可达对象（三色标记法：白-未标记、灰-待处理、黑-已标记）。  
   - **重新标记（STW）**：短暂暂停，处理并发标记期间的引用变化（写屏障记录的修改）。  

2. **清除阶段**：并发回收未标记的白色对象（不可达），无需STW。  

3. **触发条件**：堆内存增长达到阈值（默认当前堆大小的2倍）、定时触发（约2分钟）、手动调用`runtime.GC()`。  


### 15. 其他语言的垃圾回收算法  
不同语言的GC算法因场景（延迟、吞吐量）不同而设计各异：  
1. **Java（HotSpot VM）**：  
   - **分代收集**：将对象按存活时间分为新生代（Young Gen）和老年代（Old Gen）。  
     - 新生代：用**标记-复制算法**（存活对象少，复制成本低）。  
     - 老年代：用**标记-清除-整理算法**（存活对象多，避免内存碎片）。  
   - **G1收集器**：将堆分为多个区域，按区域优先级回收，平衡延迟与吞吐量。  

2. **Python**：  
   - **引用计数**：每个对象维护引用计数器，为0时立即回收（优点：实时性高；缺点：无法处理循环引用）。  
   - **分代收集**：辅助引用计数，处理循环引用（按对象存活时间分代，低频回收老年代）。  

3. **C#（.NET）**：  
   - **标记-清除-压缩算法**：标记可达对象，清除不可达对象，压缩存活对象减少碎片。  
   - **并发GC**：后台线程并发标记，减少STW时间（类似Go）。  

4. **JavaScript（V8）**：  
   - **分代收集**：新生代用**Scavenge算法**（标记-复制），老年代用**标记-清除-整理**。  
   - **增量标记**：将标记阶段拆分为小步骤，穿插在JS执行中，降低延迟。  

5. **Rust**：  
   - **所有权系统**：编译期通过静态分析确定对象生命周期，无需运行时GC，内存由开发者显式管理（或通过智能指针自动释放）。
  

### 16. 有缓存 Channel 与无缓存 Channel 的区别  
Channel 是 Go 中协程间通信的核心机制，按是否有缓存分为两类，核心区别如下：  

| 特性               | 无缓存 Channel（`make(chan T)`）                          | 有缓存 Channel（`make(chan T, n)`，`n>0`）               |  
|--------------------|----------------------------------------------------------|----------------------------------------------------------|  
| **发送/接收阻塞**  | 发送操作（`ch <- v`）会阻塞，直到有协程执行接收操作（`<-ch`）；反之亦然。 | 发送操作仅在缓存满时阻塞；接收操作仅在缓存空时阻塞。       |  
| **同步性**         | 实现严格同步：发送方和接收方必须同时就绪，操作才会完成（类似“握手”）。 | 实现异步通信：发送方可以先将数据存入缓存，接收方可后续读取。 |  
| **适用场景**       | 协程间强同步（如任务交接、步骤协调）。                     | 缓冲数据流（如生产者-消费者模型，平衡生产与消费速度）。     |  

示例：  
- 无缓存：`ch := make(chan int)`，`go func() { ch <- 1 }()` 会阻塞，直到主协程执行 `<-ch`。  
- 有缓存：`ch := make(chan int, 1)`，`ch <- 1` 可直接完成（缓存未满），后续 `<-ch` 读取数据。  


### 17. string 类型的底层结构及字符串追加原理  
#### 底层结构  
Go 中 `string` 是**不可变的字节序列**，底层由两部分组成（类似切片）：  
- 指向字节数组的指针（`ptr`）；  
- 字节数组的长度（`len`）。  

源码简化定义：  
```go
type stringStruct struct {
    str unsafe.Pointer  // 指向字节数组的指针
    len int             // 字符串长度
}
```  
**不可变性**：字符串创建后，其底层字节数组无法修改（修改会触发编译错误），保证线程安全。  

#### 字符串追加（`+` 或 `strings.Builder`）  
1. **`+` 运算符**：  
   - 原理：由于字符串不可变，每次追加会创建新的字节数组，复制原字符串和新增内容到新数组，返回新字符串。  
   - 性能：多次追加时效率低（时间复杂度 O(n²)，如循环追加 `s += "a"` 会产生多次复制）。  

2. **`strings.Builder`**：  
   - 原理：内部维护一个可扩容的字节切片（`[]byte`），追加时直接写入切片，避免频繁创建新字符串。  
   - 性能：高效（时间复杂度 O(n)），最终通过 `String()` 方法将切片转为字符串（仅复制指针和长度，不复制底层数据）。  

示例：  
```go
// 低效方式
s := "hello"
s += " world"  // 创建新字符串，复制 "hello" + " world"

// 高效方式
var b strings.Builder
b.WriteString("hello")
b.WriteString(" world")
s := b.String()  // 仅转换，不复制底层字节
```  


### 18. Go 处理高并发的优势  
Go 天生为高并发设计，核心优势体现在以下方面：  

1. **轻量级协程（Goroutine）**：  
   - 协程初始栈仅 2KB（可动态扩容至 GB 级），远小于线程（默认 1MB+），单机器可创建百万级协程。  
   - 切换成本极低（用户态调度，无需陷入内核），比线程切换快 1-2 个数量级。  

2. **高效调度模型（GMP）**：  
   - 通过 G（协程）、M（内核线程）、P（逻辑处理器）三级结构，实现协程到内核线程的灵活映射。  
   - 工作窃取机制：空闲 P 从繁忙 P 的队列中“窃取”协程，平衡负载，充分利用多核 CPU。  

3. **原生并发工具**：  
   - `channel` 实现协程间安全通信，避免共享内存带来的锁竞争。  
   - `sync` 包提供丰富同步原语（`WaitGroup`、`Mutex`、`Cond` 等），简化并发控制。  

4. **IO 模型优化**：  
   - 对网络 IO、文件 IO 等操作进行封装，底层使用 epoll（Linux）、kqueue（BSD）等 IO 多路复用技术。  
   - 协程在 IO 阻塞时自动让出 CPU，不浪费资源（无需像线程那样阻塞等待）。  

5. **内存与 GC 优化**：  
   - 内存分配基于 TCMalloc 思想，小对象从线程缓存快速分配，减少锁竞争。  
   - 并发 GC 机制（STW 时间微秒级），即使在高并发场景下也能保持低延迟。  


### 19. Go 与 C++、Java 的核心区别  
| 维度               | Go                                      | C++                                     | Java                                    |  
|--------------------|-----------------------------------------|-----------------------------------------|-----------------------------------------|  
| **类型系统**       | 静态类型，无类继承，支持接口隐式实现。   | 静态类型，支持类继承、多态、模板（泛型）。 | 静态类型，支持类继承、多态、泛型。       |  
| **内存管理**       | 自动 GC（并发标记-清除），无手动释放。   | 手动管理（`new`/`delete`），或用智能指针。 | 自动 GC（分代收集），无手动释放。         |  
| **并发模型**       | 基于 Goroutine + Channel，用户态调度。  | 基于线程（`std::thread`），需手动管理同步（ mutex 等）。 | 基于线程（`Thread`），通过 `synchronized` 或 `java.util.concurrent` 同步。 |  
| **语法复杂度**     | 极简（无构造函数、析构函数、异常等）。   | 复杂（指针算术、运算符重载、模板元编程等）。 | 中等（异常、注解、内部类等）。           |  
| **编译与执行**     | 编译为机器码，直接执行，启动快。         | 编译为机器码，直接执行，启动快。         | 编译为字节码，需 JVM 解释/编译执行，启动较慢。 |  
| **适用场景**       | 高并发服务（微服务、API 网关）、云原生工具。 | 高性能场景（游戏引擎、操作系统、数据库）。 | 企业级应用（后端服务、Android 应用）。   |  
| **生态**           | 标准库丰富，云原生工具链成熟（Docker、K8s 均用 Go 开发）。 | 生态庞大，支持底层开发到应用层。         | 生态成熟，框架丰富（Spring、Hadoop 等）。 |
