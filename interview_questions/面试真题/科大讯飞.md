### 1. Gin框架里的中间件是什么意思？有没有实际使用过他的中间件，怎么使用的？
Gin 中间件是**拦截 HTTP 请求/响应的可复用组件**，可在请求到达处理函数前执行前置逻辑（如认证、日志），或在响应返回前执行后置逻辑（如统一格式、耗时统计），核心作用是解耦通用逻辑与业务逻辑。  

实际使用过多种中间件，常见场景及用法如下：  
1. **全局中间件（作用于所有请求）**：  
   如日志记录中间件，记录每个请求的方法、路径、耗时：  
   ```go
   // 自定义日志中间件
   func loggerMiddleware() gin.HandlerFunc {
       return func(c *gin.Context) {
           start := time.Now()
           // 前置逻辑：请求处理前执行
           c.Next() // 调用后续中间件和处理函数
           // 后置逻辑：响应返回前执行
           cost := time.Since(start)
           fmt.Printf("method: %s, path: %s, cost: %v\n", c.Request.Method, c.Request.URL.Path, cost)
       }
   }

   // 注册全局中间件
   r := gin.Default()
   r.Use(loggerMiddleware()) // 所有请求都会经过该中间件
   ```  

2. **路由组中间件（作用于特定路由组）**：  
   如用户认证中间件，仅对 `/api/user` 路由组生效：  
   ```go
   // 认证中间件：校验请求头中的 Token
   func authMiddleware() gin.HandlerFunc {
       return func(c *gin.Context) {
           token := c.GetHeader("Authorization")
           if token == "" || !validateToken(token) {
               c.JSON(http.StatusUnauthorized, gin.H{"msg": "未授权"})
               c.Abort() // 终止请求，不进入后续处理
               return
           }
           c.Next() // 认证通过，继续执行
       }
   }

   // 注册路由组并绑定中间件
   userGroup := r.Group("/api/user")
   userGroup.Use(authMiddleware()) // 该组下所有路由都会经过认证
   userGroup.GET("/info", getUserInfo) // 需认证才能访问
   ```  


### 2. Gin里面的C.Next是什么意思？
`c.Next()` 是 Gin 框架中 `*gin.Context` 类型的核心方法，作用是**触发后续中间件和路由处理函数的执行**，是中间件“链式调用”的关键。  

- **执行逻辑**：  
  当中间件调用 `c.Next()` 时，Gin 会按注册顺序执行下一个中间件；若所有中间件都执行完 `c.Next()`，则执行当前路由绑定的处理函数。  
  例如：全局中间件 A → 路由组中间件 B → 处理函数，调用顺序为：  
  1. 中间件 A 的“前置逻辑” → 调用 `c.Next()`；  
  2. 中间件 B 的“前置逻辑” → 调用 `c.Next()`；  
  3. 执行处理函数；  
  4. 回到中间件 B 的“后置逻辑”；  
  5. 回到中间件 A 的“后置逻辑”。  

- **反向操作 `c.Abort()`**：  
  若中间件中调用 `c.Abort()`，会终止后续中间件和处理函数的执行（如认证失败时直接返回，不进入业务逻辑），与 `c.Next()` 功能相反。  


### 3. go里的Context是什么？
Go 中的 `context.Context` 是**跨 Goroutine 传递上下文信息的工具**，核心作用是“传递取消信号、超时控制、共享请求级数据”，避免 Goroutine 泄漏，常用于 HTTP 请求、RPC 调用等场景。  

- **核心功能**：  
  1. **取消信号**：通过 `context.WithCancel()` 创建可取消 Context，当调用 `cancel()` 时，所有关联的 Goroutine 会收到取消信号，可及时退出。  
     ```go
     ctx, cancel := context.WithCancel(context.Background())
     defer cancel() // 确保最终取消
     go func(ctx context.Context) {
         for {
             select {
             case <-ctx.Done(): // 收到取消信号
                 fmt.Println("Goroutine exit")
                 return
             default:
                 // 业务逻辑
             }
         }
     }(ctx)
     ```  
  2. **超时控制**：通过 `context.WithTimeout()` 设置超时时间，超时后自动触发取消（如 HTTP 请求超时控制）。  
  3. **共享数据**：通过 `ctx.Value(key)` 在同一请求的不同 Goroutine/函数间传递数据（如请求 ID、用户信息），但不建议传递大量数据（避免耦合）。  

- **使用原则**：  
  - 函数参数中 Context 应作为第一个参数；  
  - 不传递 `nil` Context，默认用 `context.Background()`；  
  - 不存储 Context 到结构体，需显式传递。  


### 4. 哪些场景会导致channel的panic？
Go 中操作 Channel 时，以下场景会触发 `panic`：  
1. **向已关闭的 Channel 发送数据**：  
   Channel 关闭后无法再写入数据，写入会直接 `panic`（读取已关闭 Channel 会返回零值+`ok=false`，不会 panic）。  
   ```go
   ch := make(chan int, 1)
   close(ch)
   ch <- 1 // panic: send on closed channel
   ```  

2. **重复关闭 Channel**：  
   Channel 关闭后再次调用 `close(ch)` 会触发 `panic`（关闭未初始化的 `nil` Channel 也会 panic）。  
   ```go
   ch := make(chan int)
   close(ch)
   close(ch) // panic: close of closed channel
   ```  

3. **向无缓冲且无接收者的 Channel 发送数据（死锁）**：  
   虽本质是死锁，但运行时会触发 `panic`，场景为：无缓冲 Channel 发送数据时，若没有 Goroutine 接收，发送会永久阻塞，最终导致死锁 panic。  
   ```go
   ch := make(chan int)
   ch <- 1 // 无接收者，死锁 panic: all goroutines are asleep - deadlock!
   ```  


### 5. TCP是哪层协议？还有哪些在传输层？ TCP和UDP的使用场景？
- **TCP 的协议层级**：TCP（传输控制协议）属于 **OSI 七层模型的传输层**（四层模型的传输层），负责端到端的可靠数据传输。  

- **传输层其他协议**：除 TCP 外，传输层常见协议为 **UDP（用户数据报协议）**；此外还有 SCTP（流控制传输协议，用于电信场景）、DCCP（数据报拥塞控制协议）等，但实际应用中以 TCP 和 UDP 为主。  

- **TCP 和 UDP 的使用场景**：  
  1. **TCP 适用场景**：需可靠传输、无数据丢失的场景，如：  
     - HTTP/HTTPS 协议（网页访问、API 调用）；  
     - 文件传输（FTP、SFTP）；  
     - 即时通讯的消息发送（如微信文字消息，需确保送达）。  
  2. **UDP 适用场景**：需低延迟、可容忍少量丢包的场景，如：  
     - 视频/语音通话（如 Zoom、抖音直播，延迟优先于完整性）；  
     - DNS 查询（请求小、需快速响应）；  
     - 实时游戏（如王者荣耀，卡顿比丢包更影响体验）。  


### 6. HTTP是哪一层协议？ 基于什么协议的？
- **HTTP 的协议层级**：HTTP（超文本传输协议）属于 **OSI 七层模型的应用层**（四层模型的应用层），直接面向用户业务，定义了客户端与服务器的请求/响应格式。  

- **HTTP 基于的协议**：HTTP 基于 **传输层的 TCP 协议**（HTTP/1.0、HTTP/1.1、HTTP/2.0 均基于 TCP）；而 HTTP/3.0 基于 **UDP 协议**（通过 QUIC 协议实现可靠传输，降低延迟）。  


### 7. HTTP3.0 HTTP2.0 HTTP1.0区别三连问
#### 1. HTTP1.0 vs HTTP2.0：核心差异在“性能优化”  
| 维度         | HTTP1.0                          | HTTP2.0                          |
|--------------|----------------------------------|----------------------------------|
| **连接方式** | 短连接（默认），每次请求需建立TCP连接 | 长连接（默认），单TCP连接复用，减少握手开销 |
| **数据格式** | 文本格式（ASCII），头部冗余大       | 二进制分帧（Frame），头部压缩（HPACK） |
| **并发能力** | 单连接串行执行，存在“队头阻塞”       | 多流并行（Stream），不同请求用流ID标记，无队头阻塞 |
| **服务器推送** | 不支持                             | 支持（Server Push），主动推送关联资源（如HTML+CSS） |

#### 2. HTTP2.0 vs HTTP3.0：核心差异在“传输层协议”  
| 维度         | HTTP2.0                          | HTTP3.0                          |
|--------------|----------------------------------|----------------------------------|
| **传输层协议** | 基于TCP，需三次握手，存在TCP队头阻塞 | 基于UDP（QUIC协议），无TCP握手，解决队头阻塞 |
| **连接建立速度** | 首次连接需TCP三次握手+TLS握手，延迟高 | 首次连接仅需1-RTT（甚至0-RTT），延迟降低50%+ |
| **兼容性** | 依赖TCP，需处理TCP层问题（如重传）     | 基于UDP，自定义拥塞控制，更灵活（如BBR） |
| **部署难度** | 需升级服务器/客户端，依赖TCP优化     | 需支持QUIC协议，部分网络可能屏蔽UDP端口 |

#### 3. 三代协议核心演进逻辑：  
从 HTTP1.0（短连接、文本）→ HTTP2.0（长连接、二进制、多流）→ HTTP3.0（UDP+QUIC、低延迟），核心目标都是“降低延迟、提升并发”，HTTP3.0 进一步解决了 TCP 协议本身的性能瓶颈。  


### 8. 同一个电脑上QQ能上，但是浏览器不能上，排查一下可能是什么原因？
QQ 能上（通常用 UDP/TCP 直连）但浏览器不能上（HTTP/HTTPS 基于 TCP），说明网络通但浏览器相关配置/协议有问题，排查方向：  

1. **浏览器代理配置错误**：  
   - 浏览器可能开启了无效代理（如之前配置的代理服务器下线），导致 HTTP 请求无法转发。  
   - 排查：打开浏览器“设置→代理设置”，关闭代理或配置正确的代理地址。  

2. **DNS 解析故障**：  
   - QQ 可能用 IP 直连（如腾讯服务器 IP 已缓存），但浏览器访问域名需 DNS 解析，若 DNS 服务器配置错误（如手动设置的 DNS 不可用），会导致域名无法解析。  
   - 排查：用 `ping www.baidu.com` 测试，若提示“未知主机”，则修改 DNS 为公共 DNS（如 8.8.8.8、114.114.114.114）。  

3. **浏览器端口/协议限制**：  
   - 浏览器默认用 80（HTTP）/443（HTTPS）端口，若这些端口被防火墙屏蔽（如系统防火墙、杀毒软件），会导致请求被拦截。  
   - 排查：关闭防火墙/杀毒软件后重试，或用 `telnet www.baidu.com 80` 测试端口是否通畅。  

4. **浏览器缓存/插件问题**：  
   - 浏览器缓存损坏或插件冲突（如广告拦截插件误拦截请求），导致页面无法加载。  
   - 排查：清除浏览器缓存（Ctrl+Shift+Del），禁用所有插件后重启浏览器。  

5. **系统 hosts 文件篡改**：  
   - hosts 文件中可能被添加了域名与无效 IP 的映射（如恶意软件修改），导致浏览器访问域名时指向错误 IP。  
   - 排查：打开 `C:\Windows\System32\drivers\etc\hosts`（Windows）或 `/etc/hosts`（Linux/Mac），删除无关域名映射。  


### 9. linux的常用命令；
Linux 常用命令按功能分类如下：  
1. **文件/目录操作**：  
   - `ls`：列出目录内容（`ls -l` 详细信息，`ls -a` 显示隐藏文件）；  
   - `cd`：切换目录（`cd ..` 上一级，`cd ~` 家目录）；  
   - `pwd`：显示当前目录路径；  
   - `mkdir`：创建目录（`mkdir -p a/b` 创建多级目录）；  
   - `rm`：删除文件/目录（`rm -r` 递归删除目录，`rm -f` 强制删除）；  
   - `cp`：复制文件（`cp -r` 复制目录）；  
   - `mv`：移动/重命名文件。  

2. **进程管理**：  
   - `ps`：查看进程（`ps aux` 显示所有进程）；  
   - `top`：实时查看进程资源占用（按 `q` 退出）；  
   - `kill`：终止进程（`kill -9 PID` 强制终止）；  
   - `bg/fg`：将进程切换到后台/前台。  

3. **网络操作**：  
   - `ping`：测试网络连通性（`ping -c 4 baidu.com` 发送4个包）；  
   - `netstat`：查看网络连接（`netstat -tuln` 显示监听端口）；  
   - `curl`：发送 HTTP 请求（`curl http://baidu.com` 查看响应）；  
   - `ifconfig`/`ip addr`：查看网卡信息。  

4. **文件内容查看**：  
   - `cat`：查看文件全部内容；  
   - `less`：分页查看大文件（按 `q` 退出）；  
   - `grep`：搜索文件内容（`grep "error" log.txt` 查找包含 error 的行）；  
   - `tail`：查看文件末尾内容（`tail -f log.txt` 实时跟踪日志）。  


### 10. 如何查看80端口被什么进程占用了，要用什么命令；
Linux 下查看 80 端口占用进程的常用命令：  

1. **`netstat` 命令**（适用于所有 Linux 系统）：  
   ```bash
   netstat -tuln | grep :80  # 先查看80端口是否被监听
   netstat -tulnp | grep :80  # 查看占用80端口的进程（-p 显示PID和进程名）
   ```  
   - 输出示例：`tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1234/nginx`（PID=1234，进程名=nginx）。  

2. **`ss` 命令**（替代 `netstat` 的新工具，效率更高）：  
   ```bash
   ss -tuln | grep :80        # 查看监听状态
   ss -tulnp | grep :80      # 查看进程信息
   ```  

3. **`lsof` 命令**（需安装 `lsof` 工具，适用于更详细的文件/端口占用）：  
   ```bash
   lsof -i :80  # 直接查看占用80端口的进程
   ```  

- **补充**：若提示“权限不足”，需加 `sudo` 执行（如 `sudo netstat -tulnp | grep :80`）。  


### 11. Linux下的文件描述符是什么意思？
Linux 下的 **文件描述符（File Descriptor，FD）** 是**内核为每个打开的文件（包括普通文件、目录、网络套接字、设备等）分配的非负整数标识符**，用于简化用户程序对文件的操作。  

- **核心本质**：用户程序无法直接操作内核中的文件对象，需通过 FD 作为“桥梁”—— 打开文件时，内核创建文件对象并返回 FD；后续读写文件时，用户程序通过 FD 告知内核操作哪个文件对象。  

- **常见默认 FD**：  
  - 0：标准输入（stdin，默认从键盘输入）；  
  - 1：标准输出（stdout，默认输出到终端）；  
  - 2：标准错误（stderr，默认输出到终端）；  
  - 3+：用户打开的文件/套接字等。  

- **示例**：当执行 `echo "hello" > test.txt` 时，Shell 会打开 `test.txt` 并获得 FD=3，将标准输出（FD=1）重定向到 FD=3，最终将内容写入文件。  


### 12. 文件描述符的范围是多少？
Linux 下文件描述符的范围受**系统配置**和**进程限制**双重约束：  

1. **默认范围**：  
   - 最小 FD：0（标准输入）；  
   - 单个进程默认最大 FD：1024（早期 Linux 限制，现代系统默认更高，如 65535）。  

2. **系统级限制**：  
   - 内核参数 `fs.file-max` 定义系统全局最大 FD 数量（如 `cat /proc/sys/fs/file-max` 查看，默认通常为百万级，如 1048576），表示整个系统最多可打开的文件描述符总数。  

3. **进程级限制**：  
   - 每个进程的最大 FD 数量由 `ulimit` 控制，分为“软限制”和“硬限制”：  
     - 软限制：进程当前可使用的最大 FD 数（默认 1024 或 65535），可被进程自行提高（但不能超过硬限制）；  
     - 硬限制：软限制的上限（需 root 权限修改）。  
   - 查看进程限制：`ulimit -n`（查看软限制），`ulimit -Hn`（查看硬限制）。  

- **总结**：单个进程的 FD 范围通常是 `0 ~ 进程软限制-1`，系统全局 FD 范围是 `0 ~ fs.file-max-1`。  


### 13. 如何避免文件描述符的耗尽？
文件描述符耗尽会导致进程无法打开新文件/套接字（报错“Too many open files”），避免方法从“限制使用”和“优化释放”两方面入手：  

1. **合理设置进程 FD 限制**：  
   - 临时调整：`ulimit -n 65535`（将当前 Shell 进程的软限制设为 65535，重启失效）；  
   - 永久调整：编辑 `/etc/security/limits.conf`，添加：  
     ```conf
     * soft nofile 65535  # 所有用户软限制
     * hard nofile 100000 # 所有用户硬限制
     ```  
   - 调整系统全局限制：编辑 `/etc/sysctl.conf`，添加 `fs.file-max = 1048576`，执行 `sysctl -p` 生效。  

2. **及时释放无用 FD**：  
   - 编程时：打开文件/套接字后，确保在使用完毕后调用 `close()` 关闭（如 Go 中用 `defer file.Close()`，避免遗漏）；  
   - 排查泄漏：用 `lsof -p PID` 查看进程打开的 FD 数量，若持续增长，可能存在 FD 泄漏（如循环中打开文件未关闭）。  

3. **优化 FD 使用**：  
   - 复用 FD：如 HTTP 长连接复用套接字 FD，避免频繁创建/关闭；  
   - 限制并发连接：如服务器程序通过线程池/协程池控制并发量，避免因大量并发连接导致 FD 耗尽（如 Nginx 的 `worker_connections` 配置）。  

4. **监控与告警**：  
   - 定期监控进程 FD 使用量（如 `lsof -p PID | wc -l`），当接近限制的 80% 时触发告警，及时排查问题。  


### 14. Redis的持久化方式
Redis 提供两种核心持久化方式，用于将内存数据写入磁盘，防止重启后数据丢失：  

1. **RDB（Redis Database）**：  
   - 原理：按配置的时间间隔（如“60秒内修改1000次”）生成内存快照（二进制文件 `dump.rdb`），将整个内存数据压缩存储到磁盘。  
   - 触发方式：  
     - 自动触发：配置 `save 60 1000`（60秒内1000次写操作触发）；  
     - 手动触发：执行 `SAVE`（阻塞 Redis 主线程，适合停机备份）或 `BGSAVE`（fork 子进程执行，不阻塞主线程）。  
   - 优点：文件体积小，恢复速度快（直接加载二进制文件）；  
   - 缺点：可能丢失最后一次快照后的数（如系统崩溃）。  

2. **AOF（Append Only File）**：  
   - 原理：记录所有写命令（如 `SET key value`、`HSET hash field value`）到日志文件（`appendonly.aof`），重启时通过重放日志恢复数据。  
   - 持久化策略（`appendfsync` 配置）：  
     - `always`：每次写命令都刷盘（最安全，性能最差）；  
     - `everysec`：每秒刷盘一次（默认，平衡安全与性能）；  
     - `no`：由操作系统决定刷盘时机（性能最好，安全性最差）。  
   - 优点：数据安全性高（丢失数据最多为1秒），支持“日志重写”（压缩冗余命令，减小文件体积）；  
   - 缺点：日志文件体积大，恢复速度慢于 RDB。  

3. **混合持久化（Redis 4.0+）**：  
   - 原理：AOF 文件头部存储 RDB 快照，尾部存储增量 AOF 命令，兼顾 RDB 的恢复速度和 AOF 的安全性，默认开启（`aof-use-rdb-preamble yes`）。  


### 15. 如何选择持久化方式？
Redis 持久化方式的选择需结合**业务对数据安全性的要求**、**恢复速度**和**性能开销**，核心决策逻辑：  

1. **优先选混合持久化（推荐）**：  
   - 场景：绝大多数业务（如电商缓存、用户会话），既需要较快的恢复速度，又希望减少数据丢失风险。  
   - 理由：AOF 尾部保证数据安全性（丢失≤1秒），RDB 头部保证恢复速度（比纯 AOF 快数倍），兼顾两者优势。  

2. **选纯 RDB**：  
   - 场景：数据可容忍分钟级丢失，且对恢复速度要求高（如非核心缓存、临时数据）。  
   - 理由：RDB 文件体积小，备份/传输效率高，恢复速度快；但需接受“极端情况下丢失最后一次快照后的数据”（如10分钟内的数据）。  

3. **选纯 AOF**：  
   - 场景：数据安全性要求极高（如金融交易数据、不能丢失任何操作），可接受较慢的恢复速度。  
   - 理由：`appendfsync always` 配置下可实现“零数据丢失”，但会严重影响 Redis 写入性能；若用 `everysec`，则丢失数据≤1秒，性能接近 RDB。  

4. **特殊场景：关闭持久化**：  
   - 场景：纯内存缓存（如热点数据缓存，数据可从数据库重建），追求极致性能。  
   - 理由：关闭持久化后，Redis 无需写入磁盘，写入性能最大化，但重启后数据全部丢失。  

- **补充建议**：无论选择哪种方式，都需定期备份持久化文件（如 RDB/AOF 文件），避免磁盘损坏导致数据丢失。  


### 16. Kafka如何保证消息的顺序的？
Kafka 保证消息顺序的核心是“**分区内有序，全局有序需额外设计**”，具体机制：  

1. **分区内消息有序**：  
   - 原理：Kafka 的每个 Topic 分为多个 Partition（分区），消息按“生产者发送顺序”写入 Partition 的尾部（Append Only），且每个消息在 Partition 内有唯一的偏移量（Offset），消费者按 Offset 顺序读取，因此**单个 Partition 内的消息绝对有序**。  
   - 关键：生产者发送消息时，若指定相同的 `key`（如用户 ID），Kafka 会通过 `key` 哈希取模将消息分配到同一 Partition，确保同一业务流的消息（如同一用户的订单）在同一 Partition 内有序。  

2. **全局有序（跨分区有序）**：  
   - 场景：需所有消息按发送顺序消费（如全局事件日志），需额外设计：  
     1. 单 Partition 方案：Topic 仅创建 1 个 Partition，所有消息写入同一 Partition，实现全局有序；但会牺牲并发能力（仅 1 个消费者可消费），适合低吞吐量场景。  
     2. 外部排序方案：多 Partition 写入后，消费者将消息拉取到外部系统（如 Spark、Flink），按消息的“时间戳”或“全局唯一 ID”排序，适合高吞吐量场景。  

3. **避免消费乱序**：  
   - 消费者：同一 Partition 只能由消费者组中的**单个消费者**消费（避免多消费者并发读取导致乱序）；  
   - 消息重试：若消息消费失败需重试，需确保重试消息仍写入原 Partition（如指定相同 `key`），避免重试消息乱序。  

- **总结**：Kafka 天然保证“分区内有序”，全局有序需通过“单 Partition”或“外部排序”实现，核心是利用 Partition 的 Append Only 特性和 `key` 哈希分区机制。
