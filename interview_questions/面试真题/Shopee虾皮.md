## Shopee 虾皮
### 1. TCP 与 UDP 的差别  
TCP（传输控制协议）和 UDP（用户数据报协议）是 TCP/IP 协议栈中两种核心传输层协议，主要区别如下：  

| 特性               | TCP                                      | UDP                                      |  
|--------------------|------------------------------------------|------------------------------------------|  
| **连接性**         | 面向连接（需三次次握手建立连接，4次挥手关闭） | 无连接（直接发送数据，无需建立连接）      |  
| **可靠性**         | 可靠传输（保证数据不丢失、不重复、按序到达） | 不可靠（不保证交付，可能丢失、乱序）      |  
| **拥塞控制**       | 有（通过慢启动、拥塞避免等机制调整发送速率） | 无（发送速率不受网络状态影响）            |  
| **数据边界**       | 无（流式传输，数据被拆分为多个报文，接收端合并） | 有（每个数据报独立，接收端不合并）        |  
| **效率**           | 较低（头部开销大，需确认和重传）          | 较高（头部简单，无额外控制开销）          |  
| **适用场景**       | 文件传输、网页加载、邮件等（需可靠传输）  | 视频通话、直播、DNS 查询等（需实时性）    |  


### 2. TCP 如何实现纠错、防止丢失数据和重复  
TCP 通过一系列机制保证数据可靠传输：  

1. **校验和**：每个 TCP 报文段包含校验和字段，接收端通过校验和检测数据是否在传输中损坏，若损坏则丢弃并要求重传。  

2. **序号与确认机制**：  
   - 发送端为每个字节分配唯一序号（Sequence Number），确保数据按序传输。  
   - 接收端收到数据后，返回确认序号（Acknowledgment Number），表示已正确接收至该序号的数据。  

3. **超时重传**：  
   - 发送端发送数据后启动计时器，若超时未收到确认，则重传该数据。  
   - 超时时间动态调整（基于往返时间 RTT 估算），避免不必要的重传。  

4. **滑动窗口机制**：  
   - 接收端通过窗口大小告知发送端自己的接收缓冲区容量，控制发送速率，避免接收端溢出。  
   - 未被确认的数据需暂存，若超时则重传，解决数据丢失问题。  

5. **重复数据处理**：  
   - 接收端通过序号识别重复数据（已接收过的序号），直接丢弃重复报文，避免数据重复。  


### 3. HTTPS 加密流程  
HTTPS 是 HTTP 基于 TLS/SSL 协议的加密版本，加密流程如下：  

1. **客户端发起连接**：客户端向服务器发送 HTTPS 请求，包含支持的 TLS 版本、加密套件（如 RSA、AES 等）。  

2. **服务器配置**：服务器返回数字证书（含公钥、服务器域名、证书颁发机构 CA 等信息）和选择的加密套件。  

3. **客户端验证证书**：  
   - 客户端验证证书合法性（检查 CA 签名、有效期、域名匹配等），若无效则警告用户。  
   - 验证通过后，客户端生成一个随机对称密钥（会话密钥）。  

4. **密钥协商**：  
   - 客户端用服务器公钥加密会话密钥，发送给服务器。  
   - 服务器用自己的私钥解密，获取会话密钥。  

5. **对称加密通信**：  
   - 后续所有 HTTP 数据均使用会话密钥进行对称加密（如 AES），双方通过该密钥加密和解密数据。  

核心：通过非对称加密（RSA/ECC）安全交换对称密钥，再用对称加密（效率更高）传输实际数据，兼顾安全性和性能。  


### 4. 数据库四种隔离级别  
数据库隔离级别用于解决并发访问时的脏读、不可重复读、幻读问题，SQL 标准定义了四种级别：  

1. **读未提交（Read Uncommitted）**：  
   - 允许事务读取其他未提交事务的数据。  
   - 问题：存在脏读（读取到未提交的无效数据）。  

2. **读已提交（Read Committed）**：  
   - 事务只能读取其他已提交事务的数据。  
   - 解决：脏读；问题：不可重复读（同一事务中多次读取同一数据，结果可能不同）。  

3. **可重复读（Repeatable Read）**：  
   - 同一事务中多次读取同一数据，结果始终一致（不受其他事务提交影响）。  
   - 解决：脏读、不可重复读；问题：幻读（事务中新增/删除数据，另一事务查询时出现“幻影”数据）。  
   - 注：MySQL InnoDB 通过 MVCC（多版本并发控制）在可重复读级别解决了幻读。  

4. **串行化（Serializable）**：  
   - 事务串行执行（类似单线程），完全隔离。  
   - 解决：所有并发问题；问题：性能极低，适合数据一致性要求极高的场景。  


### 5. 数据库出现读性能问题如何解决  
数据库读性能问题可从以下角度优化：  

1. **索引优化**：  
   - 为高频查询字段建立合适索引（如 B+ 树索引、哈希索引），避免全表扫描。  
   - 定期优化索引（删除冗余索引、重建碎片化索引）。  

2. **查询优化**：  
   - 避免使用 `SELECT *`，只查询必要字段。  
   - 优化 `JOIN`、`GROUP BY` 等操作，减少子查询嵌套。  
   - 使用 `EXPLAIN` 分析查询计划，定位低效语句。  

3. **缓存机制**：  
   - 引入 Redis 等缓存中间件，缓存热点数据（如首页推荐、高频查询结果）。  
   - 开启数据库查询缓存（如 MySQL Query Cache，需注意缓存失效策略）。  

4. **读写分离**：  
   - 主库负责写操作，从库负责读操作，通过主从复制同步数据，分散读压力。  

5. **分库分表**：  
   - 水平分表：将大表按行拆分（如按用户 ID 哈希），减少单表数据量。  
   - 垂直分表：将大表按列拆分（如将不常用字段拆分到单独表），提升查询效率。  

6. **硬件与配置优化**：  
   - 升级服务器 CPU、内存，使用 SSD 提升磁盘 IO 速度。  
   - 调整数据库配置（如增大缓冲区 `innodb_buffer_pool_size`）。  


### 6. 数据库索引类型  
数据库索引按底层结构和功能可分为以下类型：  

1. **B+ 树索引**：  
   - 最常用索引类型，底层为平衡多路查找树，叶子节点有序且连成链表。  
   - 支持范围查询、排序，适合磁盘存储（减少 IO 次数）。  
   - 包括：主键索引（主键字段，唯一且非空）、二级索引（非主键字段，需回表查询数据）。  

2. **哈希索引**：  
   - 基于哈希表实现，通过键值直接映射到存储位置，查询时间复杂度 O(1)。  
   - 优点：单值查询快；缺点：不支持范围查询、排序，适合等值查询场景（如 MongoDB 中的哈希索引）。  

3. **全文索引**：  
   - 用于文本内容（如文章、评论）的关键词检索，支持分词和模糊匹配。  
   - 如 MySQL 的 `FULLTEXT` 索引、Elasticsearch 的倒排索引。  

4. **空间索引**：  
   - 用于地理空间数据（如经纬度），支持范围查询（如“查找某区域内的地点”）。  

5. **聚簇索引与非聚簇索引**：  
   - 聚簇索引：索引结构与数据存储在一起（如 InnoDB 主键索引，叶子节点存储完整数据）。  
   - 非聚簇索引：索引与数据分离（如 MyISAM 索引，叶子节点存储数据地址）。  


### 7. Redis 数据结构  
Redis 支持多种核心数据结构，每种结构有特定应用场景：  

1. **字符串（String）**：  
   - 存储字符串、整数或二进制数据，最大 512MB。  
   - 用途：缓存、计数器（`INCR`）、分布式锁（`SET NX`）。  

2. **哈希（Hash）**：  
   - 键值对集合，适合存储对象（如用户信息）。  
   - 命令：`HSET`（设置字段）、`HGET`（获取字段）、`HGETALL`（获取所有字段）。  

3. **列表（List）**：  
   - 有序字符串列表，支持两端插入/删除（双向链表实现）。  
   - 用途：消息队列、最新列表（`LPUSH + LRANGE`）。  

4. **集合（Set）**：  
   - 无序、唯一元素集合，支持交集、并集、差集运算。  
   - 用途：去重、标签系统（`SADD`、`SINTER`）。  

5. **有序集合（Sorted Set）**：  
   - 带分数的有序集合，按分数排序（底层为跳跃表 + 哈希表）。  
   - 用途：排行榜（`ZADD`、`ZRANK`）、范围查询（`ZRANGEBYSCORE`）。  

6. **其他高级结构**：  
   - **Bitmap**：位操作，适合统计（如用户签到）。  
   - **HyperLogLog**：基数统计（如独立访客数 UV）。  
   - **Geospatial**：地理空间数据（如附近的人）。  


### 8. Redis 持久化方式  
Redis 提供两种持久化机制，用于将内存数据写入磁盘，防止重启后数据丢失：  

1. **RDB（Redis Database）**：  
   - 原理：在指定时间间隔内，将内存中的数据集快照（二进制文件）写入磁盘（默认 `dump.rdb`）。  
   - 触发方式：  
     - 手动：`SAVE`（阻塞 Redis 直至完成）、`BGSAVE`（后台异步执行，不阻塞服务）。  
     - 自动：配置文件中设置触发条件（如 `save 60 1000` 表示 60 秒内有 1000 次修改）。  
   - 优点：文件小，恢复速度快；缺点：可能丢失最后一次快照后的所有数据。  

2. **AOF（Append Only File）**：  
   - 原理：记录所有写操作命令（如 `SET`、`HSET`）到日志文件（默认 `appendonly.aof`），重启时重新执行命令恢复数据。  
   - 优点：数据安全性高（可配置每秒/每次操作同步到磁盘）；缺点：文件大，恢复速度慢。  

3. **混合持久化（Redis 4.0+）**：  
   - 结合 RDB 和 AOF 优势：AOF 文件头部为 RDB 快照，尾部为增量命令，兼顾恢复速度和数据安全性。  


### 9. Redis 读性能问题如何解决  
Redis 读性能优化可从以下方面入手：  

1. **缓存设计优化**：  
   - 合理设置过期时间，避免缓存雪崩（大量 key 同时过期）和缓存穿透（查询不存在的 key）。  
   - 热点数据预热：提前将高频访问数据加载到 Redis，避免缓存冷启动。  

2. **集群与分片**：  
   - 主从复制：主库写，从库读，分散读压力（如 1 主 3 从，读请求分配到从库）。  
   - 哨兵（Sentinel）：监控主从节点，自动故障转移，保证高可用。  
   - 集群（Cluster）：将数据分片存储在多个节点（最多 16384 个槽），水平扩展读能力。  

3. **数据结构优化**：  
   - 避免大 key（如超大 Hash、List），拆分数据减少单次操作耗时。  
   - 合理选择数据结构（如用 Sorted Set 代替 List 做排行榜，提升查询效率）。  

4. **硬件与配置**：  
   - 使用 SSD 存储持久化文件，提升 AOF/RDB 读写速度。  
   - 调整配置（如增大 `maxmemory`、优化 `io-threads` 提升 IO 性能）。  

5. **多级缓存**：  
   - 结合本地缓存（如 Go 中的 `sync.Map`）和 Redis，减少远程访问次数（适用于超高频访问数据）。  


### 10. 进程和线程的区别  
进程和线程是操作系统中并发执行的基本单位，核心区别如下：  

| 特性               | 进程（Process）                          | 线程（Thread）                          |  
|--------------------|------------------------------------------|------------------------------------------|  
| **定义**           | 资源分配的基本单位（独立内存空间、文件描述符等） | 进程内的执行单元，共享进程资源          |  
| **资源占用**       | 大（MB 级，创建/销毁开销高）              | 小（KB 级栈内存，创建/销毁开销低）      |  
| **独立性**         | 高（一个进程崩溃不影响其他进程）          | 低（线程崩溃可能导致整个进程崩溃）      |  
| **通信方式**       | 复杂（需通过 IPC：管道、消息队列、共享内存等） | 简单（可直接访问进程共享内存）          |  
| **调度单位**       | 操作系统内核调度（切换开销大）            | 操作系统内核调度（切换开销小）          |  
| **并发能力**       | 低（受 CPU 核心数限制）                  | 高（一个进程可包含多个线程并发）        |  


### 11. 死锁的四个条件  
死锁是指两个或多个进程/线程相互等待对方释放资源而陷入无限阻塞的状态，必须同时满足以下四个条件：  

1. **互斥条件**：资源只能被一个进程/线程占用（如锁只能被一个线程持有）。  
2. **持有并等待条件**：进程/线程持有部分资源，同时等待其他资源。  
3. **不可剥夺条件**：已分配的资源不能被强制剥夺（如锁不能被其他线程强行释放）。  
4. **循环等待条件**：多个进程/线程形成环形等待链（如 A 等 B 的资源，B 等 C 的资源，C 等 A 的资源）。  

解决死锁的思路：破坏上述任一条件（如按顺序申请资源避免循环等待、设置超时释放资源等）。  


### 12. 虚拟内存的作用  
虚拟内存是操作系统通过硬件和软件结合，将物理内存和磁盘空间抽象为统一地址空间的技术，主要作用：  

1. **扩展内存容量**：允许程序使用的内存超过实际物理内存大小，将暂时不用的数据存储到磁盘（swap 分区/页面文件）。  
2. **隔离进程空间**：每个进程拥有独立的虚拟地址空间，避免进程间内存访问冲突，提高安全性。  
3. **简化内存管理**：程序员无需关心物理内存布局，只需使用连续的虚拟地址，由操作系统负责映射到物理内存（可能不连续）。  
4. **提高内存利用率**：通过页面置换算法（如 LRU）只将活跃数据保留在物理内存，不常用数据换出到磁盘，提高内存使用效率。  


### 13. Go 内存模型  
Go 内存模型定义了多 goroutine 间共享内存的可见性规则，核心是“happens-before”关系（即一个操作的结果何时对另一个操作可见）：  

1. **单 goroutine 内**：操作按代码顺序执行（编译器和 CPU 不会重排有依赖的操作），满足顺序一致性。  

2. **多 goroutine 间**：需通过同步原语建立 happens-before 关系，确保可见性：  
   - **通道通信**：向通道发送数据的操作 happens-before 从该通道接收数据的操作。  
   - **锁机制**：`sync.Mutex`/`sync.RWMutex` 的解锁操作 happens-before 后续的加锁操作。  
   - **WaitGroup**：`Add` 调用 happens-before `Wait` 返回；`Done` 调用 happens-before `Wait` 返回。  
   - **Once**：`sync.Once` 的 `Do` 函数内的操作 happens-before 任何 `Do` 调用返回。  

3. **未同步的风险**：若未通过上述机制建立关系，一个 goroutine 对变量的修改可能对其他 goroutine 不可见（因 CPU 缓存、指令重排等），导致数据竞争。  


### 14. 线性数据结构  
线性数据结构是指元素之间存在一对一线性关系的结构，常见类型：  

1. **数组（Array）**：  
   - 连续内存空间存储相同类型元素，支持下标随机访问。  
   - 优点：访问快（O(1)）；缺点：插入/删除慢（需移动元素，O(n)），长度固定。  

2. **链表（Linked List）**：  
   - 节点通过指针/引用连接，内存不连续。  
   - 优点：插入/删除快（O(1)，只需修改指针）；缺点：访问慢（O(n)，需遍历）。  
   - 类型：单链表、双链表、循环链表。  

3. **栈（Stack）**：  
   - 遵循“后进先出（LIFO）”原则，仅允许在栈顶操作。  
   - 用途：表达式求值、函数调用栈。  

4. **队列（Queue）**：  
   - 遵循“先进先出（FIFO）”原则，允许在队尾插入、队头删除。  
   - 用途：消息队列、广度优先搜索（BFS）。  

5. **字符串（String）**：  
   - 由字符组成的线性结构，可视为特殊的数组（只读）。  


### 15. 哈希表如何解决哈希冲突  
哈希表通过哈希函数将键映射到数组索引，当不同键映射到同一索引时，产生哈希冲突，解决方式如下：  

1. **链地址法（Chaining）**：  
   - 每个数组索引对应一个链表（或红黑树），冲突的键值对存储在链表中。  
   - 查找时，先通过哈希函数定位索引，再遍历链表查找目标键。  
   - 优点：实现简单，处理冲突高效；Java HashMap、Go map 采用此方式。  

2. **开放地址法（Open Addressing）**：  
   - 冲突时，通过探测函数（如线性探测、二次探测、双重哈希）寻找下一个空闲位置。  
   - 线性探测：冲突后依次检查下一个索引（`index+1, index+2...`）。  
   - 优点：内存连续，缓存利用率高；缺点：易产生聚集效应（连续空闲位置被占用）。  

3. **再哈希法（Rehashing）**：  
   - 冲突时，使用第二个哈希函数计算新索引，直至找到空闲位置。  
   - 优点：减少聚集效应；缺点：增加哈希计算开销。  

4. **建立公共溢出区**：  
   - 主表存储无冲突的键值对，冲突的键值对统一存储到溢出表。  
   - 优点：主表查询效率高；缺点：溢出表可能成为性能瓶颈。
  
### 16. Linux 移动文件夹及所有文件的命令  
使用 `mv` 命令，格式为：  
```bash
mv 源文件夹路径 目标路径
```  
- 示例：将 `/home/user/docs` 移动到 `/home/user/backup` 目录下：  
  ```bash
  mv /home/user/docs /home/user/backup
  ```  
- 说明：`mv` 会移动文件夹及其包含的所有子文件和子文件夹，若目标路径已存在同名文件夹，会将源文件夹合并到目标文件夹中（或覆盖，取决于系统配置）。  


### 17. Linux 查看内存和 CPU 的命令  
#### 查看内存  
1. **`free`**：显示内存使用概况（单位：KB/MB/GB）  
   ```bash
   free -h  # -h 以人类可读的单位（如G、M）显示
   ```  
   输出包含总内存（total）、已使用（used）、空闲（free）、缓冲/缓存（buff/cache）等信息。  

2. **`top` 或 `htop`**：动态查看内存占用（按 `M` 键按内存使用率排序）  
   ```bash
   top   # 基础版，按q退出
   htop  # 增强版，支持鼠标操作（需安装）
   ```  

#### 查看 CPU  
1. **`top` 或 `htop`**：动态查看 CPU 使用率（按 `P` 键按 CPU 使用率排序），显示每个进程的 CPU 占用率。  

2. **`mpstat`**：查看多核心 CPU 使用率（需安装 `sysstat` 包）  
   ```bash
   mpstat -P ALL  # 显示所有核心的 CPU 使用率
   ```  

3. **`vmstat`**：显示 CPU 整体负载（用户态、系统态、空闲等）  
   ```bash
   vmstat 1  # 每秒刷新一次
   ```  


### 18. 虚拟内存是怎么用的，优点是什么  
#### 工作原理  
虚拟内存是操作系统将物理内存和磁盘空间（如 Linux 的 swap 分区、Windows 的页面文件）结合的技术：  
1. **地址映射**：每个进程使用独立的虚拟地址空间，操作系统通过页表将虚拟地址映射到物理内存或磁盘。  
2. **页面置换**：当物理内存不足时，操作系统将不常用的内存页（4KB 或更大）换出到磁盘（“换出”），需要时再换入物理内存（“换入”），通过 LRU 等算法决定置换哪些页面。  

#### 优点  
1. **扩展内存容量**：允许程序使用的内存超过实际物理内存，支持运行大型程序（如数据库、虚拟机）。  
2. **隔离进程空间**：每个进程的虚拟地址空间独立，避免相互干扰，提高系统安全性。  
3. **简化编程**：程序员无需关心物理内存布局，可使用连续的虚拟地址，降低内存管理复杂度。  
4. **提高内存利用率**：只保留活跃数据在物理内存，不常用数据存磁盘，减少内存浪费。  


### 19. 线程、进程、协程的区别；协程为什么快，轻量在哪里  
| 类型   | 定义与资源     | 调度方式               | 核心区别点                     |  
|--------|----------------|------------------------|--------------------------------|  
| 进程   | 资源分配单位（独立内存、文件描述符） | 内核调度（抢占式）     | 资源最重，隔离性最强，切换开销大（MB级） |  
| 线程   | 进程内执行单元，共享进程资源 | 内核调度（抢占式）     | 资源中等，共享内存，切换开销中等（KB级栈） |  
| 协程   | 用户态轻量级线程，共享线程资源 | 用户态调度（协作式）   | 资源最轻，由程序控制，切换开销极小（字节级栈） |  

#### 协程为什么快？轻量在哪里？  
1. **用户态调度**：协程切换无需陷入内核态，仅需保存/恢复少量寄存器（如程序计数器、栈指针），开销远低于线程（线程切换需内核参与，涉及上下文保存、调度器选择等）。  
2. **栈内存动态伸缩**：协程初始栈很小（如 Go 协程默认 2KB），且可动态扩容/缩容，而线程栈固定大小（通常 1MB+），内存占用低。  
3. **无内核调度 overhead**：协程调度由程序或 runtime 控制（如 Go 的 GMP 模型），避免内核调度的复杂逻辑和开销。  
4. **协作式执行**：协程主动让出 CPU（如通过 `yield` 或 IO 操作），减少不必要的切换，提高 CPU 利用率。  


### 20. Go 主协程等待子协程执行完毕的方法  
1. **`sync.WaitGroup`**（最常用）：  
   ```go
   import "sync"

   func main() {
       var wg sync.WaitGroup
       wg.Add(2) // 注册2个子协程

       go func() {
           defer wg.Done() // 子协程完成，计数器-1
           // 任务逻辑
       }()

       go func() {
           defer wg.Done()
           // 任务逻辑
       }()

       wg.Wait() // 等待所有子协程完成
   }
   ```  

2. **channel 阻塞等待**：  
   ```go
   func main() {
       ch := make(chan struct{}, 2) // 缓冲大小等于子协程数

       go func() {
           // 任务逻辑
           ch <- struct{}{} // 完成后发送信号
       }()

       go func() {
           // 任务逻辑
           ch <- struct{}{}
       }()

       // 等待所有信号
       <-ch
       <-ch
   }
   ```  

3. **`context.Context`**（适合需要超时控制的场景）：  
   ```go
   import (
       "context"
       "time"
   )

   func main() {
       ctx, cancel := context.WithCancel(context.Background())
       var count int
       total := 2

       go func() {
           // 任务逻辑
           count++
           if count == total {
               cancel() // 所有子协程完成，触发取消
           }
       }()

       go func() {
           // 任务逻辑
           count++
           if count == total {
               cancel()
           }
       }()

       <-ctx.Done() // 等待取消信号
   }
   ```  


### 21. HTTP 和 HTTPS 的区别  
| 特性               | HTTP                                  | HTTPS                                  |  
|--------------------|---------------------------------------|----------------------------------------|  
| **安全层**         | 无（明文传输）                        | 基于 TLS/SSL 加密（加密传输）          |  
| **端口**           | 默认 80 端口                          | 默认 443 端口                          |  
| **数据传输**       | 明文，易被窃听、篡改                  | 加密数据，防止窃听和篡改                |  
| **证书**           | 无需证书                              | 需要 CA 颁发的数字证书（验证服务器身份） |  
| **性能**           | 较高（无加密开销）                    | 较低（需加密/解密、证书验证开销）        |  
| **URL 前缀**       | `http://`                             | `https://`                             |  


### 22. HTTPS 的加密过程  
1. **客户端发起请求**：客户端向服务器发送支持的 TLS 版本、加密套件（如 ECDHE、AES 等）。  
2. **服务器返回证书**：服务器返回数字证书（含公钥、服务器域名、CA 签名等），并选择加密套件。  
3. **客户端验证证书**：  
   - 客户端验证证书合法性（检查 CA 签名、有效期、域名匹配），若无效则警告用户。  
   - 验证通过后，客户端生成随机的**会话密钥**（对称加密密钥）。  
4. **密钥协商**：  
   - 客户端用服务器公钥加密会话密钥（或通过 ECDHE 等算法协商密钥），发送给服务器。  
   - 服务器用私钥解密（或通过协商算法）获取会话密钥。  
5. **对称加密通信**：后续所有 HTTP 数据均使用会话密钥进行对称加密（如 AES），双方通过该密钥加密/解密数据。  

核心：非对称加密（用于安全交换对称密钥）+ 对称加密（用于高效传输数据），兼顾安全性和性能。  


### 23. HashMap 原理（Go 中的 map）、哈希冲突解决、拉链过大怎么办  
#### Go 中 map 的原理  
Go 的 map 底层是**哈希表 + 链表**（链地址法），结构如下：  
- **哈希表**：数组（称为“桶”，`bucket`），每个桶存储多个键值对（`key-value`）。  
- **哈希函数**：将 key 哈希为一个整数，取模后得到桶索引。  
- **桶结构**：每个桶包含 8 个键值对，若溢出则通过链表指向“溢出桶”。  

#### 哈希冲突解决方法  
Go 采用**链地址法**：当多个 key 哈希到同一桶时，将这些键值对存储在同一桶中，若桶满则链接到溢出桶，形成链表。  

#### 拉链过大怎么办？  
当桶内键值对过多（拉链过长），查询效率会下降（从 O(1) 趋近 O(n)）。Go 通过以下机制优化：  
1. **扩容（rehash）**：当 map 中元素数量（`len`）与桶数量（`cap`）的比值（负载因子）超过阈值（默认 6.5），会触发扩容：  
   - 新建一个容量为原 2 倍的桶数组。  
   - 将旧桶中的键值对重新哈希到新桶，分散元素，缩短拉链。  
2. **渐进式扩容**：避免一次性扩容耗时过长，Go 分多次迁移旧桶数据（每次操作 map 时迁移部分），直到完成。  


### 24. 数据库聚簇索引与非聚簇索引的区别  
| 特性               | 聚簇索引（Clustered Index）            | 非聚簇索引（Non-Clustered Index）      |  
|--------------------|----------------------------------------|----------------------------------------|  
| **数据存储**       | 索引结构与数据存储在一起（叶子节点存储完整数据行） | 索引与数据分离（叶子节点存储数据行地址） |  
| **数量限制**       | 一个表只能有一个（通常为主键索引）      | 一个表可以有多个                        |  
| **查询效率**       | 基于索引列查询时效率高（无需回表）      | 需通过索引找到数据地址，再查数据（回表） |  
| **插入顺序**       | 数据按索引顺序存储，无序插入可能导致页分裂 | 数据存储顺序与索引无关                  |  
| **适用场景**       | 主键查询、范围查询（如按时间排序的日志） | 非主键字段的高频查询（如用户名查询）    |  

示例：MySQL InnoDB 的主键索引是聚簇索引，二级索引（非主键）是非聚簇索引；MyISAM 所有索引都是非聚簇索引。  


### 25. 索引的存储结构  
数据库索引的底层存储结构主要有以下几种：  

1. **B+ 树索引**（最常用）：  
   - 平衡多路查找树，叶子节点有序且连成双向链表。  
   - 非叶子节点仅存储索引键，叶子节点存储完整数据（聚簇索引）或数据地址（非聚簇索引）。  
   - 优势：支持范围查询、排序，适合磁盘存储（减少 IO 次数）。  

2. **哈希索引**：  
   - 基于哈希表，键通过哈希函数映射到数组索引，适合等值查询（O(1)）。  
   - 缺点：不支持范围查询、排序，如 MySQL Memory 引擎支持哈希索引。  

3. **B 树索引**：  
   - 与 B+ 树类似，但非叶子节点也存储数据，导致查询时 IO 次数更多，不如 B+ 树常用。  

4. **R 树索引**：  
   - 用于地理空间数据（如经纬度），支持空间范围查询（如“查找半径 1km 内的地点”）。  

5. **倒排索引**：  
   - 全文检索专用（如 Elasticsearch），以“关键词”为键，映射包含该关键词的文档 ID。  


### 26. 索引的优点和缺点  
#### 优点  
1. **加速查询**：大幅减少查询时扫描的数据量（如从全表扫描 O(n) 优化为 O(logn)）。  
2. **支持排序和分组**：索引本身有序，可避免查询时的额外排序操作（如 `ORDER BY`、`GROUP BY`）。  
3. **加速连接查询**：多表 `JOIN` 时，索引可快速定位关联数据（如通过外键索引匹配）。  

#### 缺点  
1. **增加存储开销**：索引需额外存储空间（通常为数据量的 10%-30%）。  
2. **降低写入性能**：插入、更新、删除数据时，需同步维护索引（如 B+ 树的分裂、合并），增加操作耗时。  
3. **索引失效风险**：不当的查询语句（如使用 `!=`、`OR`、函数操作索引列）可能导致索引失效，退化为全表扫描。  
4. **维护成本高**：过多索引会增加数据库维护负担，需定期优化（删除冗余索引、重建碎片化索引）。  


### 27. Go 的调度模型（GMP 模型）  
Go 的调度模型是 **GMP 模型**，通过三级结构（G、M、P）实现高效的 goroutine 调度：  

- **G（Goroutine）**：待执行的协程，包含栈、程序计数器、状态等信息。  
- **M（Machine）**：操作系统线程，负责执行 G（实际的 CPU 执行单元）。  
- **P（Processor）**：逻辑处理器，作为 G 和 M 的桥梁，包含本地 goroutine 队列、调度器状态等。  

#### 核心机制  
1. **本地队列与全局队列**：  
   - P 维护一个本地 G 队列（优先调度），全局队列存储未分配到 P 的 G。  
   - M 绑定 P 后，优先从 P 的本地队列取 G 执行，若为空则从全局队列或其他 P 的本地队列“窃取”G（工作窃取机制）。  

2. **调度时机**：  
   - G 执行完毕、主动让出 CPU（`runtime.Gosched()`）、发生系统调用或阻塞时，触发调度。  

3. **系统调用处理**：  
   - G 执行系统调用时，M 会与 P 解绑，P 可绑定其他 M 执行剩余 G；系统调用完成后，G 重新进入队列等待调度。  

优势：充分利用多核 CPU，通过工作窃取平衡负载，支持百万级 goroutine 高效调度。  


### 28. Go 的 GC 垃圾回收及版本演进  
Go 的 GC 是**并发标记-清除算法**，目标是低延迟、高吞吐量，核心过程：  

1. **标记阶段**：  
   - **初始标记（STW）**：暂停所有 goroutine，标记根对象（全局变量、栈对象），耗时极短（微秒级）。  
   - **并发标记**：恢复 goroutine，后台线程并发遍历对象引用，标记可达对象。  
   - **重新标记（STW）**：再次短暂暂停，处理并发标记期间的引用变化（如新增/删除的引用）。  

2. **清除阶段**：并发回收未标记的对象（不可达对象），无需 STW。  

#### 版本演进  
- **Go 1.3**：引入标记-清除算法，全量 STW（延迟高）。  
- **Go 1.5**：实现并发标记-清除，大幅减少 STW 时间；引入三色标记法和写屏障。  
- **Go 1.8**：优化写屏障，支持栈上对象并发标记，STW 时间降至毫秒级。  
- **Go 1.12**：引入“混合写屏障”，进一步缩短重新标记阶段的 STW 时间。  
- **Go 1.19**：默认启用非分代并发 GC，减少内存开销，优化大堆场景性能。  

核心趋势：逐步降低 STW 时间（从毫秒级到微秒级），提升并发效率，适应高吞吐场景。  


### 29. Go 的线程同步方式及 sync 包内容  
#### 线程（goroutine）同步方式  
Go 中通过以下机制实现 goroutine 同步：  

1. **channel**：通过发送/接收数据实现同步（如无缓冲 channel 用于握手，带缓冲 channel 用于信号量控制）。  
2. **sync 包**：提供多种同步原语。  

#### sync 包核心组件  
1. **`sync.Mutex`**：互斥锁，确保同一时间只有一个 goroutine 访问临界区（`Lock()` 加锁，`Unlock()` 解锁）。  
2. **`sync.RWMutex`**：读写锁，允许多个读操作并发，写操作独占（`RLock()`/`RUnlock()` 读锁，`Lock()`/`Unlock()` 写锁）。  
3. **`sync.WaitGroup`**：等待多个 goroutine 完成（`Add()` 注册数量，`Done()` 减少计数，`Wait()` 阻塞等待）。  
4. **`sync.Once`**：确保函数仅执行一次（`Do(func())` 方法，线程安全）。  
5. **`sync.Cond`**：条件变量，用于等待某个条件成立（`Wait()` 等待，`Signal()` 唤醒一个，`Broadcast()` 唤醒所有）。  
6. **`sync.Map`**：协程安全的 map，适合读多写少场景（`Load()`、`Store()`、`Delete()` 方法）。  
7. **`sync.Pool`**：对象池，缓存临时对象，减少内存分配和 GC 压力（`Get()` 获取，`Put()` 放回）。
