## 京东
### 1. 说一下Go的GMP模型
GMP是Go语言goroutine的调度模型，由三个核心组件构成：
- G（Goroutine）：协程实体，包含栈、状态等信息
- M（Machine）：系统线程，负责执行G
- P（Processor）：逻辑处理器，作为G和M的桥梁，管理G队列并提供执行环境
调度逻辑：M绑定P后从P的本地队列取G执行；G阻塞时M释放P，P可绑定新M继续执行其他G；通过Work-Stealing机制平衡各P的负载。


### 2. M和P是一对一的吗
不是绝对一对一。在正常执行时，一个M会绑定一个P（M需要P才能执行G），但存在特殊情况：
- G阻塞时，M会释放P，此时M与P分离
- 当M重新可用（如阻塞解除），会尝试获取空闲P或创建新M绑定P


### 3. 如果有一个协程它是死循环，如何调度
Go 1.14+引入抢占式调度：
- 死循环协程执行超过一定时间（约10ms），会被系统调用或函数调用的间隙触发抢占
- 调度器会将其暂停，让出CPU给其他G执行
- 若纯计算无任何函数调用，仍可能长时间占用CPU（需手动调用runtime.Gosched()释放）


### 4. 如果有一个协程阻塞，如何调度
- 协程（G）阻塞时（如IO操作、锁等待），绑定的M会释放P
- P会与其他空闲M绑定，继续执行本地队列中的其他G
- 当阻塞的G恢复后，会被放入全局队列或某个P的本地队列，等待重新调度执行


### 5. Map是并发安全的吗
Go中的原生map不是并发安全的。多个协程同时读写map会导致数据竞争，可能引发panic或数据不一致。需通过sync.Mutex、sync.RWMutex或sync.Map（Go 1.9+）保证并发安全。


### 6. 多协程并发写Map，但是保证这100个key不重复，会发生什么
仍可能发生panic或数据异常。虽然key不重复，但map的底层哈希表在并发写入时会进行扩容、rehash等操作，内部结构可能被破坏，导致不可预测的结果（如panic、数据丢失）。


### 7. 讲一下乐观锁和悲观锁
- 悲观锁：认为并发操作一定会冲突，每次操作前先加锁（如MySQL的行锁、sync.Mutex），阻塞其他操作，安全性高但性能较低
- 乐观锁：认为并发操作冲突概率低，不加锁直接操作，通过版本号或CAS（Compare And Swap）机制校验是否冲突，冲突则重试，性能高但实现较复杂


### 8. 什么是读写锁
读写锁（如sync.RWMutex）是一种特殊的锁机制，区分读操作和写操作：
- 多个读操作可同时获取读锁（共享）
- 写操作需独占锁，此时读锁和其他写锁都无法获取
- 适合读多写少场景，提高并发读性能


### 9. 同一slice上的切片其底层数组是同一个吗
可能是。基于原切片通过切片表达式（如s[1:3]）创建的新切片，会共享原切片的底层数组；当对新切片执行append导致扩容时，会创建新的底层数组，此时不再共享。


### 10. append操作返回的底层数组会变吗
不一定。若原切片容量足够（len < cap），append会直接在原底层数组上操作，返回的切片仍指向原数组；若容量不足（len == cap），会触发扩容，创建新底层数组，返回的切片指向新数组。


### 11. 有缓冲和无缓冲channel有什么区别
- 无缓冲channel：发送和接收操作同步，发送方必须等待接收方接收才能返回，接收方也必须等待发送方发送
- 有缓冲channel：缓冲区未满时，发送方可直接返回；缓冲区非空时，接收方可直接获取；缓冲区满时发送阻塞，空时接收阻塞，实现异步通信


### 12. 协程泄露你知道吗
协程泄露指goroutine未正常退出且持续占用资源的现象。常见原因：
- 阻塞在无数据的channel读写
- 陷入无限循环且无退出条件
- 被永久阻塞的select（无default分支且所有case都无法触发）
- 未正确使用WaitGroup导致等待永远无法结束


### 13. 主函数中无缓冲channel只写不读，会发生什么
主协程会阻塞在发送操作上，导致程序死锁。无缓冲channel的发送操作必须有对应的接收操作才能完成，否则发送方会一直阻塞，最终触发panic（deadlock）。


### 14. Go的GC你了解吗
Go的垃圾回收是自动内存管理机制，核心特点：
- 采用并发标记-清除算法，与用户代码并行执行
- 结合三色标记法追踪存活对象
- 通过混合写屏障解决并发标记时的对象引用问题
- STW（Stop The World）时间极短（微秒级），对业务影响小
- 无需手动调用回收函数，由运行时自动触发和管理


### 15. 说一下三色标记法
三色标记法是Go GC用于标记存活对象的算法：
- 白色：未标记对象（初始状态）
- 灰色：已标记但引用的子对象未完全标记
- 黑色：已标记且所有子对象都已标记
流程：根对象置为灰色 → 从灰色对象中取出并标记其子对象为灰色，自身置为黑色 → 直至无灰色对象，剩余白色对象为垃圾


### 16. 说一下多态
多态指同一接口的不同实现，在运行时表现出不同行为。Go通过接口实现多态：
- 定义接口类型，声明方法集
- 不同结构体实现接口的所有方法（隐式实现）
- 接口变量可存储任意实现该接口的结构体实例，调用方法时会执行具体实现


### 17. 指针常量和常量指针
- 指针常量：指针本身是常量，不能改变指向，但可修改指向地址的值（如`int* const p`）
- 常量指针：指向常量的指针，可改变指向，但不能修改指向地址的值（如`const int* p`或`int const* p`）


### 18. 说一下Mysql的索引吧
MySQL索引是帮助快速查询数据的数据结构，主要类型：
- 主键索引：基于主键创建，唯一且非空，InnoDB中为主键聚簇索引
- 二级索引（辅助索引）：基于非主键字段创建，叶子节点存储主键值
- 联合索引：多个字段组合创建的索引，遵循最左前缀原则
- 全文索引：用于文本内容的模糊查询
底层数据结构：InnoDB使用B+树，MyISAM使用B树，哈希索引适用于等值查询


### 19. 联合索引在什么情况下会命中失败
- 不满足最左前缀原则（如联合索引(a,b,c)，查询条件仅用b或c）
- 查询条件中对索引列进行函数操作（如`SUBSTR(a, 1)`）
- 查询条件中使用不等于（!=、<>）、NOT IN、OR（未包含所有索引列）
- 索引列参与计算（如`a + 1 = 5`）
- 隐式类型转换（如字符串索引列用数字查询）


### 20. innodb和myisam有什么区别
| 特性         | InnoDB                  | MyISAM                  |
|--------------|-------------------------|-------------------------|
| 事务支持     | 支持ACID事务            | 不支持                  |
| 锁机制       | 行级锁、表级锁          | 表级锁                  |
| 索引类型     | 聚簇索引（主键）+二级索引 | 非聚簇索引              |
| 崩溃恢复     | 支持（基于redo/undo log）| 不支持                  |
| 全文索引     | 支持（5.6+）            | 支持                    |
| 外键支持     | 支持                    | 不支持                  |
| 表空间       | 可独立或共享            | 每个表对应三个文件      |


### 21. 事务是什么
事务是数据库中一组不可分割的操作集合，要么全部执行成功，要么全部失败，遵循ACID特性：
- 原子性（Atomicity）：操作不可分割
- 一致性（Consistency）：事务前后数据状态一致
- 隔离性（Isolation）：并发事务相互隔离
- 持久性（Durability）：事务提交后数据永久保存


### 22. 进程和线程有什么区别
- 资源分配：进程是资源分配的基本单位，拥有独立内存空间；线程共享进程资源
- 调度单位：线程是CPU调度的基本单位，进程作为线程的容器
- 切换开销：进程切换需保存整个进程状态，开销大；线程切换仅需保存线程上下文，开销小
- 独立性：进程独立运行，一个进程崩溃不影响其他进程；线程依赖进程，一个线程崩溃可能导致整个进程崩溃


### 23. 用户态与内核态
- 用户态：应用程序运行的状态，权限低，不能直接访问硬件资源，需通过系统调用进入内核态
- 内核态：操作系统内核运行的状态，权限高，可直接访问硬件资源（如内存、CPU）
- 切换：用户态通过系统调用（如文件操作、网络请求）切换到内核态，完成后返回用户态，切换有一定开销


### 24. TCP的三次握手每一次握手的目的是什么
- 第一次握手（客户端→服务器）：客户端发送SYN包，请求建立连接，告知服务器客户端的初始序列号
- 第二次握手（服务器→客户端）：服务器接收SYN，发送SYN+ACK包，确认客户端请求，告知服务器的初始序列号
- 第三次握手（客户端→服务器）：客户端接收SYN+ACK，发送ACK包，确认服务器的响应，双方确认连接建立
目的：确保双方收发能力正常，协商初始序列号，避免因网络延迟导致的旧连接请求干扰新连接


### 25. Redis的五种数据类型
- String（字符串）：二进制安全的字符串，可存储文本、数字等
- Hash（哈希）：键值对集合，适合存储对象
- List（列表）：有序字符串集合，支持两端插入/删除
- Set（集合）：无序去重集合，支持交集、并集等运算
- ZSet（有序集合）：带分数的Set，按分数排序，支持范围查询


### 26. Docker打包镜像的命令
使用`docker build`命令，基本格式：`docker build -t [镜像名:标签] [Dockerfile所在目录]`  
例如：`docker build -t myapp:v1.0 .`（当前目录的Dockerfile构建镜像）


### 27. Docker commit是干什么的
`docker commit`用于将容器的修改提交为新的镜像。通过该命令可基于运行中的容器创建自定义镜像，保存容器当前的文件系统状态和配置。  
格式：`docker commit [容器ID/名称] [新镜像名:标签]`


### 28. 容器如何跟宿主机走同一个网
通过host网络模式实现：创建容器时指定`--network host`，容器将直接使用宿主机的网络栈，与宿主机共享IP地址和端口，无需端口映射。


### 29. 怎么让容器随着Docker服务的重启而自动重启呢
创建容器时通过`--restart`参数配置，常用选项：
- `--restart always`：容器退出时总是自动重启
- `--restart unless-stopped`：除非手动停止，否则总是自动重启
- `--restart on-failure[:max-retries]`：仅在非0退出码时重启，可指定最大重试次数


### 30. Dockerfile中写多个CMD会有什么问题
Dockerfile中多个CMD指令只有最后一个生效，前面的会被忽略。CMD用于指定容器启动时执行的命令，通常只需要一个，若需多个命令可通过shell脚本或&&组合。


### 31. Go中的make和new的区别
- 适用类型：make仅用于切片（slice）、映射（map）、通道（channel）；new适用于所有类型
- 返回值：make返回类型本身（已初始化）；new返回指向类型零值的指针（未初始化复杂结构）
- 作用：make负责初始化类型的内部结构（如切片的底层数组）；new仅分配内存并置零


### 32. 如果对slice中的元素取指针，放到一个新的数组中，新数组中的值是什么样的
新数组存储的是指向原切片底层数组元素的指针。修改原切片中对应的元素，通过新数组的指针访问会看到变化；若原切片发生扩容（底层数组更换），指针仍指向旧数组的元素，不会随新数组变化。


### 33. 在defer中修改了局部变量并return，返回值为类型和(变量+类型)两种情况下会返回什么
- 返回值为类型（匿名返回值）：return先将变量值复制到临时返回值，defer修改的是原变量，不影响返回值
- 返回值为（变量+类型）（命名返回值）：defer修改的是命名返回值变量，会影响最终返回结果


### 34. 讲一下闭包
闭包是引用了外部作用域变量的函数，即使外部作用域退出，仍能访问和修改这些变量。Go中闭包通过捕获外部变量的引用实现，可将函数与其依赖的状态封装在一起。


### 35. 闭包是在解决什么问题
- 封装私有状态：实现类似类的私有变量，避免全局变量污染
- 延迟执行：保存函数执行时的上下文，在后续调用时使用
- 回调函数：传递带状态的函数作为回调，简化代码逻辑
- 函数工厂：动态生成具有不同行为的函数


### 36. Go中的Context说一下
Context是Go语言用于在goroutine之间传递上下文信息的接口，主要功能：
- 取消信号：通知相关goroutine退出
- 超时控制：设置操作超时时间
- 截止时间：指定操作的完成时间
- 值传递：携带请求相关的元数据（如追踪ID）
常用实现：Background（根上下文）、TODO（临时上下文）、WithCancel、WithTimeout、WithDeadline、WithValue


### 37. 什么场景下用Context
- 分布式系统中传递请求生命周期（如HTTP请求、RPC调用）
- 控制多个goroutine的协作（如等待所有子任务完成）
- 实现超时控制（如数据库查询、网络请求的超时设置）
- 请求追踪和日志关联（传递全局唯一标识）
- 优雅关闭服务（程序退出时通知所有goroutine清理资源）

### 38. golang的函数调用
Go函数调用通过栈实现，遵循以下流程：
- 调用前：将参数、返回地址压入调用栈，为局部变量分配栈空间
- 执行时：函数体代码在新栈帧中运行，访问参数和局部变量
- 返回时：计算返回值，释放局部变量栈空间，弹出返回地址，回到调用处
特点：默认按值传递（包括指针类型，传递的是指针副本），支持多返回值，递归调用受栈大小限制。


### 39. 有缓存的channel的接收发送流程
- 发送流程：
  1. 若缓冲区未满，直接将数据存入缓冲区，发送方不阻塞
  2. 若缓冲区已满，发送方阻塞，直到有接收方取走数据
- 接收流程：
  1. 若缓冲区非空，直接从缓冲区取数据，接收方不阻塞
  2. 若缓冲区为空，接收方阻塞，直到有发送方存入数据
本质是基于环形队列的生产者-消费者模型，通过等待队列管理阻塞的goroutine。


### 40. 关闭的channel接收发送数据
- 接收：已关闭的channel可正常接收剩余数据，数据取完后返回零值和false（`v, ok := <-ch`中ok为false）
- 发送：向已关闭的channel发送数据会触发panic
注意：重复关闭channel也会导致panic，需通过同步机制确保关闭操作唯一。


### 41. channel的底层结构
底层由`hchan`结构体实现，核心字段包括：
- `buf`：缓冲区数组（有缓冲channel）
- `sendq`：发送方等待队列（存储阻塞的goroutine）
- `recvq`：接收方等待队列（存储阻塞的goroutine）
- `lock`：互斥锁（保证并发安全）
- `closed`：关闭标志
- `sendx/recvx`：发送/接收索引（维护缓冲区的环形队列）


### 42. 进程线程协程
- 进程：系统资源分配的基本单位，拥有独立地址空间，切换开销大
- 线程：CPU调度的基本单位，共享进程资源，切换开销中等
- 协程：用户态轻量级线程，由程序调度，切换开销极小，依赖线程执行
关系：一个进程可包含多个线程，一个线程可运行多个协程。


### 43. 场景题：开辟多个写协程向一个channel中写数据，是有序吗
不一定有序。多个协程并发向channel写数据时，执行顺序由goroutine调度器决定，先调度的协程先写入，但调度顺序不确定。若需保证有序，需通过额外同步机制（如互斥锁）控制写入顺序。


### 44. gin常用中间件
- 日志中间件：`gin.Logger()`，记录请求日志
- 恢复中间件：`gin.Recovery()`，捕获panic并返回500错误
- 路由中间件：针对特定路由或分组添加，如认证、限流
- CORS中间件：处理跨域请求
- 静态文件中间件：`gin.Static()`，提供静态资源访问
- 自定义中间件：通过`func(c *gin.Context)`实现，可处理请求前/后的逻辑（`c.Next()`调用后续处理）


### 45. 反射原理以及那些场景会用到反射
- 原理：程序运行时动态获取变量类型信息（`reflect.Type`）和值信息（`reflect.Value`），通过反射包操作变量（如修改值、调用方法）
- 应用场景：
  - JSON序列化/反序列化（如`encoding/json`）
  - ORM框架（动态映射结构体与数据库表）
  - 依赖注入（根据类型动态创建实例）
  - 通用工具函数（处理任意类型的变量）
注意：反射会降低性能，增加代码复杂度，非必要不使用。


### 46. redis数据类型以及常用的操作命令
- String：`SET`/`GET`/`INCR`/`DECR`/`EXPIRE`
- Hash：`HSET`/`HGET`/`HGETALL`/`HDEL`/`HLEN`
- List：`LPUSH`/`RPUSH`/`LPOP`/`RPOP`/`LRANGE`
- Set：`SADD`/`SREM`/`SMEMBERS`/`SINTER`/`SUNION`
- ZSet：`ZADD`/`ZREM`/`ZRANGE`/`ZREVRANGE`/`ZSCORE`


### 47. innodb与myisam的区别
| 特性         | InnoDB                  | MyISAM                  |
|--------------|-------------------------|-------------------------|
| 事务支持     | 支持ACID事务            | 不支持                  |
| 锁机制       | 行级锁、表级锁          | 表级锁                  |
| 索引类型     | 聚簇索引（主键）+二级索引 | 非聚簇索引              |
| 崩溃恢复     | 支持（基于redo/undo log）| 不支持                  |
| 外键支持     | 支持                    | 不支持                  |
| 全文索引     | 支持（5.6+）            | 支持                    |


### 48. 三次握手 四次挥手
- 三次握手（建立连接）：
  1. 客户端发SYN（请求连接）
  2. 服务器回SYN+ACK（确认请求+请求连接）
  3. 客户端回ACK（确认连接）
- 四次挥手（断开连接）：
  1. 客户端发FIN（请求断开）
  2. 服务器回ACK（确认断开请求）
  3. 服务器发FIN（准备断开）
  4. 客户端回ACK（确认最终断开）
四次挥手因服务器可能有未发送数据，需分两次确认。


### 49. http状态码
- 1xx（信息）：100（继续）、101（协议切换）
- 2xx（成功）：200（OK）、201（创建）、204（无内容）
- 3xx（重定向）：301（永久重定向）、302（临时重定向）、304（未修改）
- 4xx（客户端错误）：400（请求错误）、401（未授权）、403（禁止）、404（未找到）
- 5xx（服务器错误）：500（服务器内部错误）、502（网关错误）、503（服务不可用）


### 50. http1.0 1.1 2.0
- HTTP/1.0：无持久连接，每次请求需建立新连接，支持GET/POST/HEAD
- HTTP/1.1：默认持久连接（Connection: keep-alive），支持管道化请求、Chunked编码、Host头，缓存机制更完善
- HTTP/2.0：二进制协议，多路复用（单连接并发请求），服务器推送，头部压缩，显著提升性能
