## 小米
### 1. Go 切片的底层
底层是包含三个字段的结构体：指向底层数组的指针、长度（len）、容量（cap）。


### 2. 切片并发安全吗？
不安全。并发读写 len/cap 或底层数组会导致数据竞争。


### 3. 切片的扩容机制
当 len 等于 cap 时触发扩容：
- 原 cap < 1024 时，新 cap 为原 cap 的 2 倍；
- 原 cap ≥ 1024 时，新 cap 为原 cap 加上原 cap 的 1/4；
- 最终新 cap 不小于所需最小容量，扩容时复制原数据到新数组。


### 4. 函数传切片带指针和不带指针有什么区别
- 不带指针：传递切片结构体副本，修改副本的 len/cap 不影响原切片，但修改底层数组元素会影响原切片；
- 带指针：传递切片指针，修改指针指向的切片的 len/cap 或底层数组，均影响原切片。


### 5. 循环中修改切片内容，切片实际上会改变吗
会。循环中通过索引修改切片元素，会直接修改底层数组，原切片内容随之改变。


### 6. map 中 key 的类型有什么限制吗
key 必须是可比较类型（如基本类型、指针、接口、数组等），不可比较类型（如切片、map、函数）不能作为 key。


### 7. 为什么 key 必须是可比较的，什么时候需要用到呢
- 原因：map 通过 key 的比较来定位元素位置，实现增删改查；
- 用到场景：判断 key 是否存在（如 `v, ok := m[key]`）、进行 key 的等值比较时。

### 8. golang内存管理，为什么要这么设计
- **减少锁竞争**：采用线程缓存（MCache）、中心缓存（MCentral）、页堆（MPageHeap）三级架构，小对象优先在无锁的MCache分配，降低并发分配时的锁开销。
- **适配Go语言特性**：针对Goroutine轻量、高并发的特点，优化小对象分配效率，减少内存碎片。
- **平衡性能与开发效率**：自动内存管理无需手动分配释放，同时通过分级缓存和内存块复用，接近手动管理的性能。
- **降低GC压力**：内存分配策略与GC配合，如内存块按大小分类，便于GC高效扫描和回收。


### 9. golang内存管理和操作系统内存管理之间的关系
- **层级依赖**：Go内存管理建立在操作系统内存管理之上，通过向操作系统申请大块内存（页堆MPageHeap向OS申请页内存），再在用户态进行细分分配。
- **减少系统调用**：Go通过预分配和缓存内存块，减少直接向OS申请内存的频率，降低系统调用开销。
- **内存单位映射**：Go的内存页（通常8KB）与操作系统的内存页对应，OS负责内存的物理分配、虚拟地址映射和页面置换，Go则在虚拟地址空间内管理用户态内存。
- **协作关系**：当Go的页堆内存不足时，通过mmap等系统调用向OS申请新内存；当内存释放时，Go会将空闲页归还给OS（或缓存复用），由OS负责底层物理内存的回收。

### 10. go slice的底层
底层是包含三个字段的结构体：指向底层数组的指针、长度（len）、容量（cap）。

### 11. go slice的扩容机制
当len等于cap时触发扩容：
- 原cap < 1024时，新cap为原cap的2倍；
- 原cap ≥ 1024时，新cap为原cap加上原cap的1/4；
- 最终新cap不小于所需最小容量，扩容时复制原数据到新数组。

### 12. go defer，return哪个先执行
return先执行（计算返回值并准备返回），defer后执行（在函数返回前执行）。

### 13. go gc原理
采用并发标记-清除算法，结合三色标记法：
- 标记阶段：从根对象出发，用白色、灰色、黑色标记对象存活状态，与用户代码并发执行；
- 清除阶段：回收未标记的白色对象，同样与用户代码并发；
- 通过混合写屏障解决并发标记时的对象引用变化问题，减少STW时间。

### 14. go new和make的区别
- new：用于所有类型，返回指向类型零值的指针，不初始化复杂类型（如切片、map的内部结构）；
- make：仅用于切片、map、channel，返回类型本身，会初始化内部结构（如切片的底层数组）。

### 15. 进程、线程和协程的区别
- 进程：资源分配的基本单位，拥有独立内存空间，切换开销最大；
- 线程：CPU调度的基本单位，共享进程资源，切换开销中等；
- 协程：用户态轻量级线程，由程序调度，切换开销极小，依赖线程执行。

### 16. go 有缓冲channel和无缓冲channel的区别
- 无缓冲：发送和接收操作同步，发送方需等待接收方接收才能返回；
- 有缓冲：发送方在缓冲区未满时可直接返回，接收方在缓冲区非空时可直接获取，缓冲区满时发送阻塞，空时接收阻塞。

### 17. goroutine内存泄漏
指goroutine未正常退出且持续占用资源的情况，常见原因：
- 阻塞在无数据的channel读写；
- 未处理的死锁；
- 无限循环且无退出条件；
- 被永久阻塞的select（无default分支且所有case都无法触发）。

### 18. redis的数据类型和底层实现
- String：简单动态字符串（SDS）；
- Hash：哈希表（字典），小数据时用压缩列表；
- List：双向链表或压缩列表；
- Set：哈希表或整数集合；
- ZSet：跳表+哈希表；
- Bitmap：动态字符串（按位操作）；
- HyperLogLog：基于概率的数据结构，用寄存器存储；
- Geospatial：ZSet（将经纬度编码为分数）。
