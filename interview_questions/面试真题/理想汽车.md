## 理想汽车

## golang后端 日常实习
### 1. 阻塞和非阻塞的channel有什么区别？
channel的阻塞/非阻塞特性由**缓冲区状态**和**操作类型**共同决定，核心区别如下：  
| 维度                | 无缓冲channel（`make(chan T)`）                | 有缓冲channel（`make(chan T, n)`，n≥1）          |
|---------------------|-----------------------------------------------|-------------------------------------------------|
| **发送（`ch <- x`）** | 阻塞：必须等待有接收方（其他goroutine）就绪，否则一直阻塞 | 非阻塞：缓冲区未满时直接存入数据；阻塞：缓冲区满时等待接收方取走数据 |
| **接收（`x <- ch`）** | 阻塞：必须等待有发送方（其他goroutine）就绪，否则一直阻塞 | 非阻塞：缓冲区非空时直接取出数据；阻塞：缓冲区空时等待发送方存入数据 |
| **核心场景**        | 强同步（如goroutine间“手拉手”协作，确保操作顺序） | 异步通信（如生产者-消费者模型，用缓冲区缓解并发压力） |

非阻塞操作还可通过`select`的`default`分支实现，避免阻塞（例：`select { case ch <- x: default: /* 处理非阻塞逻辑 */ }`）。


### 2. defer的使用，defer的执行时间，执行顺序
#### defer的使用
`defer`用于延迟执行函数调用，通常用于**资源释放**（如关闭文件、解锁、释放连接），语法为`defer 函数调用`（函数参数在声明时预计算）。  
示例：  
```go
func readFile(path string) {
    file, err := os.Open(path)
    if err != nil {
        return
    }
    defer file.Close() // 函数返回前自动关闭文件，避免资源泄漏
    // 读取文件逻辑...
}
```


#### defer的执行时间
`defer`函数在**当前函数返回前执行**，具体时机：  
1. 若函数正常执行到`return`，先执行所有`defer`，再返回结果；  
2. 若函数因`panic`终止，会先执行所有`defer`，再传播`panic`；  
3. 若`defer`中调用`runtime.Goexit()`，会终止当前goroutine，但仍会执行已声明的`defer`。


#### defer的执行顺序
`defer`遵循**栈式顺序（LIFO，后进先出）** ——后声明的`defer`先执行。  
示例：  
```go
func main() {
    defer fmt.Println(1)
    defer fmt.Println(2)
    defer fmt.Println(3)
    // 输出：3 → 2 → 1
}
```


### 3. 什么时候索引失效？
MySQL中索引失效的常见场景如下，核心是**破坏“索引匹配规则”或触发“全表扫描更优”**：  
1. **不满足最左前缀原则**：联合索引（如`(a,b,c)`）需从最左字段开始匹配，若跳过中间字段（如`where b=1 and c=2`），索引失效；  
2. **索引列参与函数/运算**：如`where SUBSTR(name,1,3)='abc'`（对`name`索引列用函数）、`where id+1=10`（索引列参与运算），索引无法使用；  
3. **索引列使用不等于（`!=`/`<>`）、`not in`、`is not null`**：这些条件可能导致MySQL认为全表扫描比走索引更快，触发索引失效；  
4. **字符串不加引号**：如`where name=123`（`name`是`varchar`类型），MySQL会隐式转换类型，导致索引失效；  
5. **`or`连接的条件中有列无索引**：如`where a=1 or b=2`（`a`有索引，`b`无索引），整个查询会走全表扫描，`a`的索引失效；  
6. **like以`%`开头**：如`where name like '%abc'`，无法使用`name`的前缀索引，索引失效（`like 'abc%'`可正常使用索引）。


### 4. gorm了解吗？怎么使用？
GORM是Go语言中主流的ORM（对象关系映射）库，用于简化MySQL等数据库的操作，支持CRUD、事务、关联查询等功能。


#### 基本使用步骤（以MySQL为例）
1. **安装GORM和数据库驱动**  
   ```bash
   go get gorm.io/gorm
   go get gorm.io/driver/mysql
   ```

2. **定义模型（对应数据库表）**  
   模型结构体字段与表列通过标签映射（默认`SnakeCase`命名，如`UserName`→`user_name`）：  
   ```go
   package main

   import (
       "gorm.io/gorm"
       "gorm.io/driver/mysql"
   )

   // User 模型（对应users表）
   type User struct {
       gorm.Model        // 内置字段：ID、CreatedAt、UpdatedAt、DeletedAt（软删除）
       Name     string   `gorm:"column:name;type:varchar(50);not null"` // 自定义列属性
       Age      int      `gorm:"column:age;default:0"`
   }

   // TableName 自定义表名（默认是结构体复数，如User→users）
   func (u User) TableName() string {
       return "users"
   }
   ```

3. **连接数据库**  
   ```go
   func main() {
       // DSN格式：user:password@tcp(host:port)/dbname?charset=utf8mb4&parseTime=True&loc=Local
       dsn := "root:123456@tcp(127.0.0.1:3306)/testdb?charset=utf8mb4&parseTime=True&loc=Local"
       db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
       if err != nil {
           panic("连接数据库失败：" + err.Error())
       }

       // 自动迁移（根据模型创建/更新表结构，生产环境慎用，建议用SQL脚本）
       db.AutoMigrate(&User{})
   }
   ```

4. **核心CRUD操作**  
   - 创建：`db.Create(&User{Name: "Alice", Age: 20})`  
   - 查询：`var user User; db.First(&user, "name = ?", "Alice")`（按条件查第一条）  
   - 更新：`db.Model(&user).Update("age", 21)`  
   - 删除：`db.Delete(&user, 1)`（按ID删除，默认软删除，需`Unscoped()`物理删除）


### 5. 用的什么http框架？
Go语言中常用的HTTP框架有以下几种，选择需结合场景（轻量/高性能/生态）：  
1. **Gin**（最主流）  
   - 优势：基于Radix树路由，性能接近原生；支持中间件（日志、认证、跨域等）、参数绑定、内置渲染（JSON/HTML）；轻量简洁，学习成本低。  
   - 适用场景：后端API服务、高并发接口（如微服务、网关）。  

2. **Echo**  
   - 优势：性能与Gin接近，API设计更优雅；支持上下文扩展、自动生成Swagger文档；内置验证器。  
   - 适用场景：对API规范性要求高的服务。  

3. **Beego**  
   - 优势：全栈框架，集成ORM、缓存、日志、监控等功能；支持热重载，适合快速开发。  
   - 适用场景：中小型项目、快速原型开发（生态较Gin略重）。  

4. **Iris**  
   - 优势：功能丰富，支持Websocket、GraphQL、国际化；性能优秀，文档完善。  
   - 适用场景：复杂Web应用（如后台管理系统、实时服务）。  

实际项目中，**Gin**因性能、生态、社区支持等优势，是大多数Go后端开发的首选。


### 6. 介绍一下mdp
MDP（Markov Decision Process，马尔可夫决策过程）是**强化学习（Reinforcement Learning）的核心数学模型**，用于描述“智能体（Agent）在环境中通过决策最大化收益”的过程，适用于状态具有“马尔可夫性”的场景（即未来状态仅依赖当前状态，与历史无关）。


#### MDP的核心组成
1. **状态集合（S）**：环境中所有可能的状态（如游戏中的“角色位置”“血量”）；  
2. **动作集合（A）**：智能体可执行的所有动作（如“向左移动”“攻击”）；  
3. **状态转移概率（P）**：`P(s'|s,a)`表示在状态`s`执行动作`a`后，转移到状态`s'`的概率；  
4. **奖励函数（R）**：`R(s,a,s')`表示在状态`s`执行动作`a`转移到`s'`时，智能体获得的即时奖励（可正可负，如“吃到食物+10分”“掉血-5分”）；  
5. **折扣因子（γ）**：`0≤γ≤1`，用于权衡即时奖励和未来奖励（γ=0只关注当下，γ=1更关注长期收益）。


#### 核心目标
MDP的目标是找到一个**策略（Policy，π）** ——即“状态到动作的映射（π(s)→a）”，使得智能体在该策略下的**累积折扣奖励（Return）最大化**。  
常见求解算法：动态规划（DP）、时序差分学习（TD）、Q-Learning、策略梯度（Policy Gradient）等。


### 7. 强化学习算法有哪些分类？
强化学习算法可按“学习方式”“目标形式”等维度分类，核心分类如下：  

#### 1. 按“策略表示方式”分类
- **价值-based算法**：不直接学习策略，而是学习“状态/状态-动作的价值”，通过价值间接推导最优策略。  
  - 代表算法：Q-Learning、SARSA、Deep Q-Network（DQN，深度Q网络）；  
  - 核心：学习Q函数`Q(s,a)`（表示在状态`s`执行动作`a`的长期价值），选择Q值最大的动作。  

- **策略-based算法**：直接学习策略`π(a|s)`（表示在状态`s`选择动作`a`的概率），通过优化策略直接最大化收益。  
  - 代表算法：策略梯度（Policy Gradient，PG）、 proximal policy optimization（PPO，近端策略优化）；  
  - 优势：适合动作空间连续的场景（如机器人控制）。  

- **Actor-Critic算法**：结合前两者，“Actor（执行者）”学习策略，“Critic（评价者）”学习价值函数并评价Actor的动作，两者协同优化。  
  - 代表算法：A2C（Advantage Actor-Critic）、DDPG（Deep Deterministic Policy Gradient）、SAC（Soft Actor-Critic）。  


#### 2. 按“是否依赖模型”分类
- **有模型算法（Model-Based）**：先学习环境模型（状态转移概率P、奖励函数R），再基于模型规划最优策略。  
  - 代表算法：动态规划（DP）、蒙特卡洛树搜索（MCTS）；  
  - 优势：数据效率高，适合环境可建模的场景。  

- **无模型算法（Model-Free）**：不学习环境模型，直接通过与环境交互的经验（样本）学习策略/价值。  
  - 代表算法：Q-Learning、PG、PPO；  
  - 优势：无需环境先验知识，适合复杂环境（如游戏、机器人）。  


#### 3. 其他常见分类
- 按动作空间：离散动作算法（Q-Learning）、连续动作算法（DDPG）；  
- 按学习方式：在线学习（SARSA，边交互边学习）、离线学习（DQN，用经验回放离线学习）。


### 8. 平时使用git的流程
日常开发中，Git流程需结合团队协作规范，主流流程有**Git Flow**和**Trunk-Based Development（主干开发）**，以下是最通用的协作流程（以Git Flow为例）：  

#### 1. 初始化与分支管理
- 主分支：`main`（生产环境代码，仅合并`release`或`hotfix`分支）、`develop`（开发主分支，集成功能开发）；  
- 临时分支：`feature/*`（功能开发，从`develop`创建，完成后合并回`develop`）、`release/*`（版本发布，从`develop`创建，测试后合并到`main`和`develop`）、`hotfix/*`（生产bug修复，从`main`创建，修复后合并到`main`和`develop`）。


#### 2. 日常开发步骤
1. **克隆仓库**：首次参与项目时，克隆远程仓库到本地：`git clone <远程仓库地址>`；  
2. **创建功能分支**：从`develop`分支创建功能分支：`git checkout develop && git pull && git checkout -b feature/user-login`；  
3. **本地开发与提交**：  
   - 编写代码后，查看修改：`git status`；  
   - 添加修改到暂存区：`git add <文件名>`（或`git add .`添加所有修改）；  
   - 提交到本地仓库：`git commit -m "feat: 实现用户登录接口"`（规范提交信息，如`feat`/`fix`/`docs`）；  
4. **同步远程分支**：若开发周期长，定期拉取`develop`分支的最新代码，解决冲突：`git fetch origin develop && git merge origin/develop`；  
5. **推送分支与提PR**：功能完成后，推送分支到远程：`git push origin feature/user-login`，然后在Git平台（GitHub/GitLab）提PR（Pull Request），请求合并到`develop`；  
6. **代码审核与合并**：团队成员审核代码，通过后合并到`develop`，删除临时`feature`分支。


#### 3. 版本发布与bug修复
- 发布版本：从`develop`创建`release/v1.0.0`分支，测试修复后，合并到`main`（打标签`git tag v1.0.0 && git push origin v1.0.0`）和`develop`；  
- 生产bug修复：从`main`创建`hotfix/v1.0.1`分支，修复后合并到`main`（打标签）和`develop`。


### 9. 分支如何线性合并？
“线性合并”指合并分支后，Git提交历史保持**无分叉的线性结构**（避免复杂的合并记录，便于追溯和回滚），核心通过`git rebase`（变基）实现，而非`git merge`（默认创建合并提交）。


#### 线性合并步骤（以“合并feature分支到develop”为例）
1. **确保目标分支（develop）最新**：  
   切换到`develop`分支，拉取远程最新代码：  
   ```bash
   git checkout develop
   git pull origin develop
   ```

2. **切换到待合并分支（feature），执行变基**：  
   将`feature`分支的提交“重新应用”到最新的`develop`分支上，消除分叉：  
   ```bash
   git checkout feature/user-login
   git rebase develop
   ```

3. **解决变基冲突**：  
   若变基过程中出现冲突（如同一文件的同一行被修改），Git会暂停变基，提示冲突文件；  
   - 手动修改冲突文件，保留正确代码；  
   - 标记冲突已解决：`git add <冲突文件>`；  
   - 继续变基：`git rebase --continue`（若需放弃变基，执行`git rebase --abort`）。

4. **推送变基后的分支到远程**：  
   变基会修改本地分支的提交历史，需强制推送（仅在个人开发分支使用，避免影响他人）：  
   ```bash
   git push origin feature/user-login --force-with-lease  # --force-with-lease比--force更安全，避免覆盖他人修改
   ```

5. **合并到目标分支（develop）**：  
   此时`feature`分支已基于最新`develop`，合并时无冲突，可执行“快进合并”（fast-forward），保持历史线性：  
   ```bash
   git checkout develop
   git merge --ff-only feature/user-login  # --ff-only确保仅快进合并，不创建合并提交
   git push origin develop
   ```

6. **清理临时分支**：  
   合并完成后，删除本地和远程的`feature`分支：  
   ```bash
   git branch -d feature/user-login
   git push origin --delete feature/user-login
   ```


#### 关键注意事项
- 仅对**个人开发的临时分支**（如`feature/*`、`hotfix/*`）使用`rebase`，避免对公共分支（`main`、`develop`）执行变基（会破坏他人提交历史）；  
- 变基前确保本地分支的提交已推送远程（或备份），防止变基失败导致提交丢失；  
- 若团队习惯保留合并记录，可使用`git merge --squash`（将feature分支的提交压缩为一个，再合并到develop），同样能保持历史简洁。
