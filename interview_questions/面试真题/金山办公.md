## 金山办公
### 1. Go GMP 调度机制
Go 的 GMP 调度是 Go 语言并发模型的核心，用于高效管理 goroutine（G）的执行，由三个核心组件构成：  
- **G（Goroutine）**：轻量级线程，代表一个待执行的任务，包含栈、程序计数器等信息。  
- **M（Machine）**：操作系统线程，负责执行 G（真正的执行载体）。  
- **P（Processor）**：逻辑处理器，作为 G 和 M 的桥梁，维护一个本地 goroutine 队列，同时管理资源（如内存缓存、锁等）。  

**调度流程**：  
1. G 创建后优先加入 P 的本地队列，若本地队列满则放入全局队列。  
2. M 需绑定 P 才能运行 G（M 从 P 的本地队列或全局队列获取 G 执行）。  
3. 当 G 发生阻塞（如 I/O 操作），M 会释放 P，由其他 M 接管 P 继续执行队列中的 G；阻塞结束后，G 被放入全局队列等待重新调度。  
4. 工作窃取（Work Stealing）：若 P 的本地队列空，会从其他 P 的队列或全局队列“窃取”G 执行，平衡负载。  

**优势**：通过 P 隔离资源，减少锁竞争；结合工作窃取机制，充分利用多核 CPU，实现高并发。  


### 2. Go string 和 []byte 的区别
| 维度         | string                          | []byte                          |
|--------------|---------------------------------|---------------------------------|
| **可变性**   | 不可变（底层字节数组只读，修改会创建新字符串） | 可变（直接修改底层字节数组）     |
| **内存结构** | 指向字节数组的指针 + 长度（len） | 指向字节数组的指针 + 长度（len） + 容量（cap） |
| **用途**     | 存储文本（如字符串常量、配置）   | 存储二进制数据（如文件内容、网络字节流） |
| **转换成本** | `string([]byte)` 需复制字节（O(n)） | `[]byte(string)` 需复制字节（O(n)） |

**示例**：  
```go
s := "hello"
s[0] = 'H' // 编译错误：string不可变

b := []byte("hello")
b[0] = 'H' // 合法，b变为["H","e","l","l","o"]
```  


### 3. 操作系统中零拷贝
零拷贝（Zero-Copy）是指**避免 CPU 将数据从一块内存复制到另一块内存**的技术，减少内核态与用户态之间的数据拷贝，提升 I/O 性能。  

**常见实现**：  
- **mmap + write**：将文件内存映射到用户态地址空间，用户直接操作映射区域，避免一次内核到用户态的拷贝（但仍有内核态内部的拷贝）。  
- **sendfile**：Linux 系统调用，直接在内核态将文件数据从磁盘缓冲区传输到套接字缓冲区，全程无用户态参与（仅一次内核态内部拷贝）。  
- **DPDK（数据平面开发套件）**：绕过内核，应用程序直接操作网卡，实现真正的零拷贝（适用于高性能网络场景）。  

**应用场景**：大文件传输（如 Nginx 静态资源服务）、日志收集系统等，显著降低 CPU 占用和延迟。  


### 4. MySQL InnoDB 的存储结构，B+树
#### InnoDB 存储结构  
- **表空间（Tablespace）**：最高级存储单位，分为系统表空间（存储数据字典、Undo 日志等）、独立表空间（每张表一个 `.ibd` 文件）。  
- **段（Segment）**：表空间由段组成，分为数据段（聚簇索引）、索引段（二级索引）、回滚段（Undo 日志）等。  
- **区（Extent）**：段由区组成，每个区固定 1MB（64 个连续页，每页 16KB）。  
- **页（Page）**：InnoDB 最小 I/O 单位，默认 16KB，存储数据行、索引页、undo 日志页等。  
- **行（Row）**：数据的最小逻辑单位，包含隐藏列（`DB_TRX_ID`、`DB_ROLL_PTR`）和用户定义列。  


#### B+树索引结构  
InnoDB 索引基于 B+树实现，分为：  
- **聚簇索引（主键索引）**：叶子节点存储完整数据行，按主键顺序排列，表中必须有且仅有一个聚簇索引。  
- **二级索引（非主键索引）**：叶子节点存储主键值，查询时需先通过二级索引找到主键，再通过聚簇索引获取数据（回表）。  

B+树的层级通常为 2-4 层，确保查询只需 2-4 次磁盘 I/O，高效支持单值查询和范围查询。  


### 5. K8S 的金丝雀部署  
金丝雀部署（Canary Deployment）是一种**灰度发布策略**，通过将少量流量路由到新版本服务，验证其稳定性后逐步扩大流量比例，最终完成全量切换。  

**实现方式**：  
1. 部署新版本服务（与旧版本并行，标签不同）。  
2. 通过 Service 或 Ingress 配置流量规则（如 5% 流量到新版本，95% 到旧版本）。  
3. 监控新版本的错误率、响应时间等指标，无异常则逐步提高流量比例（如 10%→50%→100%）。  
4. 若新版本异常，立即将流量切回旧版本，实现快速回滚。  

**工具支持**：K8s 原生可通过标签选择器 + Service 实现，更复杂的流量控制可结合 Istio、Linkerd 等服务网格。  


### 6. 对 Map 并发读写会有问题吗  
会有问题。Go 中的原生 `map` 不是线程安全的，**并发读写时会触发 panic**（底层检测到并发访问会抛出 `fatal error: concurrent map read and map write`）。  

**原因**：map 的底层哈希表在扩容或 rehash 时，结构会发生变化，并发读写可能导致数据不一致、指针越界等问题。  


### 7. 怎么安全并发读写 Map（sync.Map，锁）  
#### 方案 1：使用互斥锁（sync.Mutex）或读写锁（sync.RWMutex）  
- **互斥锁**：适合读写频率相近的场景，每次读写都加锁，保证独占访问。  
  ```go
  var m = make(map[int]int)
  var mu sync.Mutex

  // 写操作
  mu.Lock()
  m[1] = 100
  mu.Unlock()

  // 读操作
  mu.Lock()
  v := m[1]
  mu.Unlock()
  ```  

- **读写锁**：适合读多写少场景，读操作共享（`RLock()`），写操作独占（`Lock()`），提升读性能。  


#### 方案 2：使用 sync.Map（Go 1.9+ 内置）  
专为并发场景设计的 map，底层通过“读写分离”优化性能：  
- 读操作优先访问只读映射（无锁），若未命中再访问脏映射（加锁）。  
- 写操作先写入脏映射，定期将脏映射合并到只读映射。  

```go
var m sync.Map

// 写操作
m.Store(1, 100)

// 读操作
v, ok := m.Load(1)

// 遍历
m.Range(func(key, value interface{}) bool {
    // 处理键值对
    return true
})
```  

**适用场景**：读多写少、键值对频繁删除的场景，性能优于普通 map+锁。  


### 8. Go 的锁使用怎么写，信号量有什么了解  
#### Go 锁的基本使用  
1. **互斥锁（sync.Mutex）**：  
   ```go
   var mu sync.Mutex
   mu.Lock()   // 加锁
   // 临界区操作
   mu.Unlock() // 解锁
   ```  

2. **读写锁（sync.RWMutex）**：  
   ```go
   var rwmu sync.RWMutex
   // 读操作
   rwmu.RLock()
   // 读临界区
   rwmu.RUnlock()

   // 写操作
   rwmu.Lock()
   // 写临界区
   rwmu.Unlock()
   ```  

3. **原子操作（sync/atomic）**：适用于简单变量（如计数器），性能优于锁：  
   ```go
   var count int32
   atomic.AddInt32(&count, 1) // 原子加1
   ```  


#### 信号量（Semaphore）  
信号量用于控制并发访问资源的数量（如限制同时访问数据库的连接数）。Go 中无原生信号量，但可通过 `channel` 模拟：  
```go
// 初始化信号量，允许3个并发
sem := make(chan struct{}, 3)

// 获取信号量（若满则阻塞）
sem <- struct{}{}
// 访问资源
// ...
// 释放信号量
<-sem
```  

**用途**：限制并发量（如限流）、协调多个 goroutine 同步执行。  


### 9. channel 有了解过吗  
channel 是 Go 中用于**goroutine 间通信**的核心机制，实现“通过通信共享内存，而非通过共享内存通信”。  

#### 特性  
- **类型化**：channel 必须指定传递的数据类型（如 `chan int`）。  
- **方向**：可定义单向 channel（`chan<- int` 只写，`<-chan int` 只读）。  
- **缓冲**：分为有缓冲（`make(chan int, 10)`）和无缓冲（`make(chan int)`）：  
  - 无缓冲：发送和接收操作同步（需双方就绪）。  
  - 有缓冲：缓冲区未满可发送，未空可接收，异步通信。  

#### 基本操作  
```go
ch := make(chan int, 2) // 有缓冲channel

// 发送
ch <- 100

// 接收
v := <-ch

// 关闭（关闭后不能发送，可接收剩余数据）
close(ch)
```  

#### 用途  
- 数据传递：goroutine 间传递数据。  
- 同步：无缓冲 channel 可实现 goroutine 同步等待。  
- 限流：利用有缓冲 channel 的容量限制并发量（模拟信号量）。  
- 退出通知：通过 `close(ch)` 广播退出信号，多个 goroutine 可同时接收。  


### 10. 链表成环怎么判断  
判断单链表是否成环，经典解法是**快慢指针法**：  

1. **算法步骤**：  
   - 初始化两个指针 `slow`（慢指针，每次走1步）和 `fast`（快指针，每次走2步）。  
   - 若链表成环，`fast` 会追上 `slow`（两指针相遇）；若不成环，`fast` 会先到达链表尾部（`fast == nil` 或 `fast.Next == nil`）。  

2. **代码示例**：  
   ```go
   type ListNode struct {
       Val  int
       Next *ListNode
   }

   func hasCycle(head *ListNode) bool {
       if head == nil || head.Next == nil {
           return false
       }
       slow, fast := head, head.Next
       for slow != fast {
           if fast == nil || fast.Next == nil {
               return false
           }
           slow = slow.Next
           fast = fast.Next.Next
       }
       return true
   }
   ```  

**时间复杂度**：O(n)，空间复杂度：O(1)（优于哈希表法的 O(n) 空间）。  


### 11. 怎么找第 k 大个数，时间复杂度是多少，通过树结构可以处理吗  
#### 方法 1：排序法  
- 思路：对数组排序，取第 `n-k` 个元素（0 基索引）。  
- 时间复杂度：O(n log n)（排序耗时），空间复杂度：O(1) 或 O(n)（取决于排序算法）。  


#### 方法 2：快速选择算法（推荐）  
- 思路：基于快速排序的分治思想，每次 partition 后判断目标位置是否在左/右区间，递归查找。  
- 时间复杂度：平均 O(n)，最坏 O(n²)（可通过随机选择 pivot 优化）。  


#### 方法 3：堆（树结构实现）  
- 思路：用小顶堆维护前 k 大元素，堆顶即为第 k 大元素。  
  1. 遍历数组，将前 k 个元素入堆。  
  2. 剩余元素若大于堆顶，则弹出堆顶并插入该元素。  
  3. 遍历结束后，堆顶即为第 k 大元素。  
- 时间复杂度：O(n log k)（插入 k 个元素后，每次操作 O(log k)），空间复杂度：O(k)。  
- **树结构适用性**：堆本身是完全二叉树，因此可以通过树结构处理，适合大数据量（n 很大，k 较小）场景。  


### 12. Slice 的底层实现，扩容机制  
#### 底层实现  
Slice 是对数组的封装，底层结构包含三个字段：  
```go
type slice struct {
    ptr   unsafe.Pointer // 指向底层数组的指针
    len   int            // 长度（当前元素个数）
    cap   int            // 容量（最多可容纳元素个数）
}
```  


#### 扩容机制  
当 `len == cap` 时，调用 `append` 会触发扩容，规则如下：  
1. 若新容量 < 256，则新容量 = 旧容量 × 2。  
2. 若新容量 ≥ 256，则新容量 = 旧容量 + 旧容量/4（每次增加 25%），直到满足需求。  
3. 扩容时会创建新数组，复制旧元素到新数组，Slice 指针指向新数组（旧数组若无人引用则被 GC 回收）。  

**注意**：扩容后新旧 Slice 指向不同数组，修改不会相互影响；未扩容时共享底层数组，修改会相互影响。  


### 13. HTTP 和 HTTPS 的区别  
| 维度         | HTTP                           | HTTPS                          |
|--------------|--------------------------------|--------------------------------|
| **安全层**   | 无加密，数据明文传输          | 基于 TLS/SSL 加密传输          |
| **端口**     | 默认 80 端口                   | 默认 443 端口                  |
| **证书**     | 无需证书                      | 需 CA 颁发的数字证书（验证服务器身份） |
| **性能**     | 开销低（无加密解密过程）      | 开销高（握手阶段需交换密钥）    |
| **URL 标识** | 以 `http://` 开头              | 以 `https://` 开头             |
| **用途**     | 非敏感数据传输（如公开文档）  | 敏感数据传输（如登录、支付）    |  


### 14. TLS/SSL 在哪一层协议  
TLS/SSL 属于**传输层与应用层之间的安全层**，通常依附于 TCP 协议（如 HTTPS 是 HTTP + TLS/SSL over TCP）。其作用是对应用层数据进行加密后再通过 TCP 传输，不属于 OSI 七层模型的标准层，但逻辑上可视为“传输层安全协议”。  


### 15. 应用层有什么协议  
应用层协议是为特定应用设计的通信规则，常见的有：  
- **HTTP/HTTPS**：超文本传输协议（网页、API 通信）。  
- **FTP**：文件传输协议（文件上传下载）。  
- **SMTP/POP3/IMAP**：邮件传输协议（发送/接收邮件）。  
- **DNS**：域名解析协议（将域名转换为 IP 地址）。  
- **SSH**：安全外壳协议（远程登录服务器）。  
- **Telnet**：远程终端协议（明文传输，安全性差）。  
- **MQTT**：轻量级消息协议（物联网通信）。  


### 16. ICMP 是做什么的  
ICMP（Internet Control Message Protocol，互联网控制消息协议）是网络层协议，主要用于**网络诊断和错误报告**：  
- **差错报告**：如目标不可达（`Destination Unreachable`）、超时（`Time Exceeded`）等，帮助定位网络故障。  
- **控制消息**：如 ping 命令（通过 ICMP Echo Request 和 Echo Reply 检测主机可达性）、traceroute（跟踪数据包路径）。  

ICMP 报文通常封装在 IP 数据包中传输，不直接用于应用层数据传输。  


### 17. HTTPS 怎么实现安全加密  
HTTPS 通过 TLS/SSL 协议实现安全加密，核心流程包括**握手阶段**和**数据传输阶段**：  

1. **握手阶段（协商密钥）**：  
   - 客户端发送支持的加密套件和随机数 `ClientRandom`。  
   - 服务器返回数字证书（含公钥）和随机数 `ServerRandom`。  
   - 客户端验证证书有效性（通过 CA 根证书），生成预主密钥 `PreMasterSecret`，用服务器公钥加密后发送。  
   - 双方基于 `ClientRandom`、`ServerRandom`、`PreMasterSecret` 生成对称密钥 `MasterSecret`。  

2. **数据传输阶段**：  
   - 后续通信使用对称密钥加密数据（效率高），同时通过 MAC（消息认证码）验证数据完整性，防止篡改。  

**核心保障**：加密（防止窃听）、认证（防止伪装）、完整性校验（防止篡改）。  


### 18. 对称加密和非对称加密  
| 维度         | 对称加密                       | 非对称加密                     |
|--------------|--------------------------------|--------------------------------|
| **密钥**     | 加密和解密使用**同一密钥**     | 加密用公钥，解密用私钥（公钥公开，私钥保密） |
| **效率**     | 快（适合大数据量加密）         | 慢（适合小数据量加密，如密钥交换） |
| **安全性**   | 密钥分发困难（需安全通道）     | 密钥分发简单（公钥可公开）     |
| **算法示例** | AES、DES、3DES                 | RSA、ECC（椭圆曲线加密）       |

**结合使用场景**：HTTPS 握手阶段用非对称加密交换对称密钥，数据传输阶段用对称加密（兼顾安全性和效率）。  


### 19. TCP 粘包以及怎么处理  
#### 粘包原因  
TCP 是流式协议，数据无边界，若发送方连续发送小数据包，接收方可能将多个数据包合并为一个“粘包”；若数据包大于接收缓冲区，可能被拆分为多个“半包”。  


#### 处理方法  
核心是**为数据添加边界标识**，常见方案：  
1. **固定长度**：每个数据包固定大小，接收方按固定长度读取。  
2. **分隔符**：用特殊字符（如 `\r\n`）标记包尾（需注意数据中不能包含分隔符）。  
3. **长度前缀**：数据包前添加长度字段（如 4 字节整数表示数据长度），接收方先读长度，再按长度读数据。  

**示例（长度前缀法）**：  
```go
// 发送方：[4字节长度][数据]
data := []byte("hello")
length := uint32(len(data))
buf := make([]byte, 4+len(data))
binary.BigEndian.PutUint32(buf[:4], length)
copy(buf[4:], data)
conn.Write(buf)

// 接收方：先读长度，再读数据
var length uint32
binary.Read(conn, binary.BigEndian, &length)
data := make([]byte, length)
conn.Read(data)
```  


### 20. 有没有了解过 OAuth 协议吗  
OAuth 是一种**开放授权协议**，允许第三方应用在不获取用户账号密码的情况下，有限度地访问用户在某平台的资源（如用微信登录第三方应用）。  

**核心角色**：  
- 资源所有者（用户）、客户端（第三方应用）、授权服务器（如微信服务器）、资源服务器（存储用户数据的服务器）。  

**授权流程（以 OAuth 2.0 为例）**：  
1. 客户端请求用户授权，用户同意后，客户端获取授权码。  
2. 客户端用授权码向授权服务器请求访问令牌（Access Token）。  
3. 客户端用访问令牌访问资源服务器，获取用户数据。  

**应用场景**：第三方登录（微信、QQ 登录）、API 授权（如 GitHub 授权第三方应用访问代码仓库）。  


### 21. 进程的通信方式有哪些  
Linux 进程间通信（IPC）方式主要有：  
1. **管道（Pipe）**：半双工，父子进程间通信，数据单向流动。  
2. **命名管道（FIFO）**：允许无亲缘关系的进程通信，通过文件系统路径标识。  
3. **信号（Signal）**：用于通知进程事件（如 `SIGKILL` 终止进程），携带信息少。  
4. **共享内存**：多个进程共享同一块物理内存，速度最快（需配合信号量同步）。  
5. **消息队列**：内核维护的消息链表，进程可按类型发送/接收消息。  
6. **信号量（Semaphore）**：用于进程同步（如控制共享资源的并发访问）。  
7. **Socket**：支持跨主机进程通信（如网络编程中的 TCP/UDP 套接字）。  


### 22. 进程能无限开吗，有什么限制  
不能无限开进程，主要限制如下：  
1. **系统资源限制**：  
   - 内存：每个进程需分配栈空间（默认 8MB）和堆空间，内存耗尽后无法创建新进程。  
   - 文件描述符：每个进程打开的文件/套接字有限制（`ulimit -n` 控制）。  
2. **PID 上限**：Linux 系统 PID 最大值默认 32768（可通过 `kernel.pid_max` 调整，但仍有限制）。  
3. **内核参数限制**：如 `vm.max_map_count`（进程可创建的内存映射数）、`nr_open`（单个进程最大文件描述符）等。  


### 23. 线上的服务有点卡或者慢了，怎么排查服务的情况  
排查步骤：  
1. **系统层面**：  
   - 查看 CPU 使用率（`top`/`htop`）：是否有进程占用过高 CPU。  
   - 内存使用（`free -h`）：是否内存不足（Swap 频繁使用）。  
   - 磁盘 I/O（`iostat`）：是否磁盘读写繁忙（如 `%util` 接近 100%）。  
   - 网络（`iftop`/`netstat`）：是否带宽饱和、连接数过多（`TIME_WAIT` 堆积）。  

2. **应用层面**：  
   - 查看服务日志：是否有错误、超时、阻塞等关键字。  
   - 检查依赖服务：数据库、缓存、消息队列是否响应缓慢。  
   - 接口响应时间：通过 APM 工具（如 SkyWalking）监控接口耗时，定位慢接口。  


### 24. 有什么相关工具可以排查吗，如果是程序内部的问题怎么定位呢  
#### 排查工具  
- **系统工具**：`top`（CPU/内存）、`iostat`（磁盘 I/O）、`iftop`（网络）、`netstat`（连接状态）、`pidstat`（进程资源）。  
- **应用工具**：`jstack`（Java 线程栈）、`gdb`（调试 C/C++）、`pprof`（Go 性能分析）、`strace`（系统调用跟踪）。  
- **APM 工具**：SkyWalking、Pinpoint（全链路监控）。  


#### 程序内部问题定位  
1. **日志分析**：在关键流程（如数据库操作、网络请求）添加详细日志，记录耗时和异常。  
2. **性能剖析**：  
   - Go：用 `pprof` 采集 CPU 火焰图、内存分配、goroutine 阻塞情况，定位热点函数。  
   - Java：用 `jprofiler` 分析线程阻塞、内存泄漏。  
3. **调试工具**：线上可通过 `strace` 跟踪系统调用（如频繁 `read`/`write` 可能 I/O 密集），或用 `gdb`  attach 进程查看堆栈。  
4. **压力测试**：用 `ab`/`wrk` 模拟高流量，复现问题并观察程序行为。  


### 25. Go 有什么性能分析工具  
Go 内置性能分析工具 `pprof`（`net/http/pprof` 或 `runtime/pprof`），支持多种维度分析：  
- **CPU 分析**：采样函数执行时间，生成火焰图，定位耗时函数。  
- **内存分析**：记录内存分配情况，检测内存泄漏、大对象分配。  
- **goroutine 分析**：查看 goroutine 数量、状态（如阻塞在 `chan` 或锁上）。  
- **锁竞争分析**：统计锁的等待时间，定位锁竞争热点。  

**使用示例**：  
```go
import _ "net/http/pprof" // 导入后通过 HTTP 暴露分析接口

func main() {
    go func() {
        http.ListenAndServe("0.0.0.0:6060", nil)
    }()
    // 业务逻辑
}
```  
通过 `go tool pprof http://localhost:6060/debug/pprof/profile` 采集数据，生成可视化报告。  


### 26. top 的 swap 是什么意思，更大还是更小好  
- **Swap**：当物理内存不足时，操作系统将部分不常用的内存数据写入磁盘交换区（Swap 分区），释放物理内存给活跃进程。  
- **top 中的 Swap 指标**：`Si`（每秒从磁盘读入 Swap 的数据量）、`So`（每秒写入磁盘的 Swap 数据量）。  

**解读**：  
- `Si`/`So` 长期不为 0，说明物理内存不足，系统频繁进行 Swap 交换（“换页”），会导致性能下降（磁盘速度远慢于内存）。  
- **Swap 应尽可能小**：正常情况下，Swap 使用率低（如 < 20%），`Si`/`So` 接近 0 最佳。若过大，需增加物理内存或优化内存使用。  


### 27. MySQL 的事务特性  
MySQL 事务具有 ACID 四大特性：  
- **原子性（Atomicity）**：事务要么全部执行，要么全部不执行（如转账时，A 扣钱和 B 加钱要么都成功，要么都失败）。  
- **一致性（Consistency）**：事务执行前后，数据从一个合法状态转换到另一个合法状态（如转账总金额不变）。  
- **隔离性（Isolation）**：多个事务并发执行时，彼此不干扰（通过隔离级别控制，如读已提交、可重复读）。  
- **持久性（Durability）**：事务提交后，修改永久保存（即使系统崩溃，通过 redo log 恢复）。  


### 28. redo log 和 bin log 的区别  
| 维度         | redo log（重做日志）           | bin log（二进制日志）          |
|--------------|--------------------------------|--------------------------------|
| **所属层**   | InnoDB 存储引擎层              | MySQL 服务器层（所有引擎通用） |
| **作用**     | 保证事务持久性，崩溃后恢复数据  | 记录所有数据修改，用于主从同步和时间点恢复 |
| **内容**     | 物理日志（记录“在某页修改了什么”） | 逻辑日志（记录“修改了哪些数据”，如 SQL 语句） |
| **写入方式** | 循环写（固定大小，满后覆盖）    | 追加写（可通过 `rotate` 切割） |
| **事务关联** | 与事务绑定（随事务提交写入）    | 事务提交后写入（可配置同步时机） |  


### 29. 索引的底层数据结构是怎么样的  
MySQL 索引主要使用 **B+树** 作为底层数据结构，特点：  
- **层级低**：非叶子节点仅存储索引键，单个节点可容纳大量索引项，树高通常 2-4 层，减少磁盘 IO。  
- **有序性**：叶子节点按索引键排序，通过双向链表连接，支持高效范围查询。  
- **聚簇索引特性**：InnoDB 主键索引的叶子节点存储完整数据行，二级索引叶子节点存储主键值（需回表查询）。  

其他数据结构：  
- **哈希索引**：Memory 引擎支持，适用于等值查询，不支持范围查询。  
- **R 树**：用于空间索引（如地理位置数据）。  


### 30. 联合索引条件 A 不等于会用索引吗  
联合索引（如 `(A, B, C)`）中，若条件包含 `A != 值` 或 `A not in (...)`，**通常不会使用索引**，会走全表扫描。  

**原因**：联合索引按 A、B、C 顺序排序，`A != 值` 会匹配大量分散的记录，索引定位效率低，优化器更倾向全表扫描。  

**例外**：若 `A != 值` 的结果集很小（如 `A != 0` 但大部分 A 都是 0），优化器可能选择使用索引。  


### 31. Redis 怎么实现分布式锁  
Redis 实现分布式锁的核心是利用 **SET 命令的原子性**，步骤如下：  

1. **获取锁**：  
   ```redis
   SET lock_key unique_value NX PX 30000
   ```  
   - `NX`：仅当 `lock_key` 不存在时才设置（保证原子性，避免并发抢锁）。  
   - `PX 30000`：设置 30 秒过期时间（防止进程崩溃导致锁永久持有）。  
   - `unique_value`：随机字符串（标识锁的持有者，避免误释放）。  

2. **释放锁**：  
   通过 Lua 脚本原子验证并删除锁（避免释放其他进程的锁）：  
   ```lua
   if redis.call("GET", KEYS[1]) == ARGV[1] then
       return redis.call("DEL", KEYS[1])
   else
       return 0
   end
   ```  

3. **续租锁**：若业务执行时间超过锁过期时间，通过“看门狗”线程定时延长锁有效期（如每 10 秒续期 30 秒）。  


### 32. 数据库和缓存的数据一致性怎么保证  
保证数据库与缓存一致性需平衡**一致性**和**性能**，推荐方案：  

1. **先更新数据库，再删除缓存（Cache-Aside 优化）**：  
   - 写操作：`UPDATE DB → DELETE Cache`（删除而非更新缓存，避免脏写）。  
   - 读操作：`GET Cache → 未命中 → GET DB → SET Cache`。  
   - 解决缓存与 DB 不一致：删除缓存失败时，通过重试机制或定时任务补偿。  

2. **延迟双删**：  
   - 写操作：`DELETE Cache → UPDATE DB → 休眠 N 毫秒 → DELETE Cache`。  
   - 解决：DB 更新后，若旧缓存未过期，第二次删除可清理残留的旧数据。  

3. **最终一致性方案**：  
   - 用消息队列异步更新缓存（如 DB 变更后发送消息，消费者更新/删除缓存）。  
   - 适合非实时场景，容忍短暂不一致。  

**核心原则**：避免“先更新缓存，再更新 DB”或“先删除缓存，再更新 DB”（可能导致缓存脏数据）。  


### 33. Redis 过期的 key 在内部是怎么被清理的  
Redis 采用**三种策略结合**清理过期 key：  

1. **惰性删除**：访问 key 时才检查是否过期，过期则删除（节省 CPU，可能浪费内存）。  
2. **定期删除**：每隔 `hz` 毫秒（默认 100ms）随机抽查部分过期 key 并删除，若过期比例超过 25% 则重复检查（平衡 CPU 和内存）。  
3. **内存淘汰**：当内存达到 `maxmemory` 阈值，按配置策略（如 LRU、LFU）淘汰部分 key（无论是否过期）。  

**配置参数**：`hz` 控制定期删除频率（默认 10），`maxmemory-policy` 控制内存淘汰策略（如 `allkeys-lru`）。  


### 34. 场景题：每晚 MySQL 都有大量的业务数据需要被删除，需要考虑哪些问题  
1. **性能影响**：  
   - 大量删除会触发大量 IO 操作，占用磁盘带宽，影响正常业务。  
   - InnoDB 行级锁可能导致锁等待，阻塞其他操作。  

2. **索引碎片**：  
   - 删除大量数据后，索引页可能出现空洞（碎片），降低查询效率。  

3. **事务日志压力**：  
   - 大量删除会生成大量 redo log 和 bin log，可能导致日志文件过大。  

4. **数据恢复风险**：  
   - 误删数据难以恢复（需依赖备份或 bin log 回滚）。  

5. **自增 ID 浪费**：删除的数据不会释放自增 ID，长期大量删除可能导致 ID 快速耗尽。  


### 35. 具体到删除的 SQL 语句有什么要注意的，比如有主键索引，普通索引和联合索引，应该选择哪个索引  
#### 删除语句注意事项  
1. **分批删除**：避免一次性删除大量数据（如 `DELETE FROM t WHERE create_time < '2023-01-01' LIMIT 1000`），减小事务压力。  
2. **避开业务高峰**：在凌晨等低峰期执行删除操作。  
3. **禁用索引失效写法**：如 `DELETE FROM t WHERE name LIKE '%xxx%'`（全表扫描），尽量用索引条件。  


#### 索引选择  
优先使用**主键索引**或**选择性高的索引**（过滤后的数据量少）：  
- **主键索引**：删除时定位快（B+树直接找到对应行），且 InnoDB 聚簇索引删除效率高（无需回表）。  
- **普通索引/联合索引**：若删除条件基于非主键字段，需选择过滤性最好的索引（如联合索引 `(A,B)` 中，`A` 选择性高则优先用 `A` 过滤）。  

**示例**：删除 30 天前的数据，若 `create_time` 有索引，优先使用 `DELETE FROM t WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY) LIMIT 1000`，利用 `create_time` 索引快速定位待删除数据。

## golang服务端开发-社招
### 36. 介绍一下UDP、TCP协议的区别
TCP（传输控制协议）和UDP（用户数据报协议）是传输层核心协议，核心区别集中在**连接性、可靠性、效率**三大维度：  

| 维度         | TCP（传输控制协议）            | UDP（用户数据报协议）          |
|--------------|--------------------------------|--------------------------------|
| **连接性**   | 面向连接（需三次握手建立连接）  | 无连接（直接发送数据，无需建立连接） |
| **可靠性**   | 保证可靠传输（重传、确认、排序、流量控制） | 不可靠（不保证数据到达、顺序，可能丢失/乱序） |
| **效率**     | 低（额外开销：确认帧、重传、拥塞控制） | 高（无额外开销，仅封装端口和校验和） |
| **数据边界** | 流式传输（无数据边界，可能粘包） | 数据报传输（每个数据包独立，有边界） |
| **适用场景** | 文件传输、HTTP/HTTPS、即时通讯（需可靠） | 视频/语音通话、DNS查询、实时游戏（需低延迟） |


### 37. 可以通过UDP协议实现TCP协议吗，具体说一下
**理论上可以，但工程上不推荐**，需手动实现TCP的核心机制，本质是“用UDP模拟TCP的可靠传输”，具体需实现以下功能：  

1. **连接管理**：手动设计“三次握手”逻辑（如客户端发SYN、服务器回SYN+ACK、客户端回ACK），建立虚拟连接。  
2. **可靠性保障**：  
   - 序号与确认：为每个UDP数据包分配序号，接收方收到后返回确认帧（ACK），超时未收到则重传。  
   - 重传机制：设置超时时间（如RTT动态调整），未确认的数据包定时重传。  
   - 排序与去重：接收方按序号重组数据，丢弃重复数据包（通过序号判断）。  
3. **流量控制**：模拟滑动窗口机制，接收方告知发送方可接收的最大数据量，避免发送过快导致缓冲区溢出。  
4. **拥塞控制**：模拟慢启动、拥塞避免算法，根据网络丢包情况动态调整发送速率，避免网络过载。  

**问题**：手动实现复杂度极高，且UDP的无连接特性无法完全匹配TCP的底层优化（如内核级的拥塞控制），性能和稳定性远不如原生TCP，仅用于教学或特殊场景（如穿透NAT）。


### 38. 客户端发起TCP请求到断开连接时处于什么状态？
客户端从发起请求到断开连接，状态流转如下：  
1. **CLOSED**：初始状态（无连接）。  
2. **SYN_SENT**：发送SYN报文（第一次握手）后，等待服务器的SYN+ACK。  
3. **ESTABLISHED**：收到服务器的SYN+ACK（第二次握手），发送ACK（第三次握手）后进入，此时连接建立，可收发数据。  
4. **FIN_WAIT_1**：主动发起断开，发送FIN报文（第一次挥手）后，等待服务器的ACK。  
5. **FIN_WAIT_2**：收到服务器的ACK（第二次挥手）后进入，等待服务器发送FIN报文。  
6. **TIME_WAIT**：收到服务器的FIN报文（第三次挥手），发送ACK（第四次挥手）后进入，等待2MSL（确保服务器收到ACK）。  
7. **CLOSED**：TIME_WAIT超时后，彻底关闭连接。  


### 39. TIME_WAIT状态持续多久时间？
TIME_WAIT状态持续时间为**2倍MSL（Maximum Segment Lifetime，最大报文生存时间）**，MSL是数据包在网络中可存活的最长时间（通常为30秒或1分钟，Linux默认MSL=60秒，因此TIME_WAIT默认持续120秒）。  

**核心目的**：  
- 确保被动关闭方（如服务器）收到最后一个ACK（避免ACK丢失导致服务器重传FIN）。  
- 等待网络中残留的旧数据包过期，避免干扰新连接（旧数据包的序号可能与新连接冲突）。


### 40. 过多TIME_WAIT会导致什么情况？如何解决？
#### 过多TIME_WAIT的危害  
- **端口耗尽**：每个TIME_WAIT连接占用一个客户端端口（默认端口范围1024-65535），过多时新连接无法分配端口，导致“Cannot assign requested address”错误。  
- **资源浪费**：每个TIME_WAIT连接占用内核资源（如文件描述符、内存），大量堆积会消耗系统资源。  


#### 解决方案  
1. **调整内核参数（Linux）**：  
   - `net.ipv4.tcp_tw_reuse = 1`：允许TIME_WAIT状态的端口被重新用于新连接（需开启`net.ipv4.tcp_timestamps`）。  
   - `net.ipv4.tcp_tw_recycle = 1`：快速回收TIME_WAIT连接（NAT环境慎用，可能导致连接异常）。  
   - `net.ipv4.tcp_fin_timeout = 30`：缩短TIME_WAIT超时时间（从120秒改为30秒）。  
2. **服务端优化**：  
   - 用长连接替代短连接（如HTTP/2.0、WebSocket），减少连接建立/断开频率。  
   - 增加端口范围：`net.ipv4.ip_local_port_range = 1024 65535`（扩大可用端口数）。  
3. **客户端优化**：  
   - 避免频繁创建短连接，复用现有连接（如HTTP Keep-Alive）。


### 41. 二层网络和三层网络了解吗，介绍下
二层网络和三层网络是OSI七层模型中**数据链路层（二层）** 和**网络层（三层）** 对应的网络架构，核心区别是“是否处理IP地址”：  

#### 二层网络（数据链路层）  
- **核心功能**：基于MAC地址转发数据帧，实现同一局域网（LAN）内的设备通信。  
- **关键设备**：交换机（通过MAC地址表学习设备位置，转发数据帧）。  
- **协议**：以太网协议（Ethernet）、ARP（将IP地址转换为MAC地址）。  
- **特点**：无路由功能，设备在同一广播域，无法跨网段通信。  


#### 三层网络（网络层）  
- **核心功能**：基于IP地址转发数据包，实现不同网段（跨LAN）的设备通信。  
- **关键设备**：路由器（通过路由表选择最佳路径，转发IP数据包）。  
- **协议**：IP（IPv4/IPv6）、ICMP（网络诊断）、OSPF（动态路由协议）。  
- **特点**：有路由功能，可分割广播域，支持跨网段通信（如办公室网络访问互联网）。  


### 42. HTTP1.0和HTTP2.0有什么区别？
HTTP1.0和HTTP2.0的核心差异集中在**性能优化**和**功能扩展**，具体如下：  

| 维度         | HTTP1.0                        | HTTP2.0                          |
|--------------|--------------------------------|-----------------------------------|
| **连接方式** | 短连接（默认），每次请求需建立TCP连接 | 长连接（默认），单TCP连接支持多路复用（多请求并行） |
| **数据格式** | 文本格式（ASCII码），头部冗余大 | 二进制分帧（帧结构），头部压缩（HPACK算法） |
| **并发能力** | 单连接串行执行（队头阻塞：前一个请求阻塞后续请求） | 多流并行（不同请求用“流ID”标记，无队头阻塞） |
| **服务器推送** | 不支持                          | 支持（Server Push，主动推送关联资源，如HTML+CSS） |
| **安全性**   | 无强制加密                      | 推荐与TLS结合（主流浏览器仅支持HTTPS上的HTTP2.0） |


### 43. HTTPS协议如何进行通信加密的？具体流程讲一下
HTTPS通过**TLS/SSL协议**实现加密通信，核心是“非对称加密交换对称密钥，对称加密传输数据”，具体流程（TLS1.2为例）：  

1. **客户端发起握手（Client Hello）**：  
   - 客户端发送支持的TLS版本（如TLS1.2）、加密套件（如AES+RSA）、随机数`ClientRandom`。  

2. **服务器响应（Server Hello）**：  
   - 服务器选择TLS版本和加密套件，返回服务器证书（含公钥）、随机数`ServerRandom`。  

3. **客户端验证证书与交换密钥**：  
   - 客户端用CA根证书验证服务器证书有效性（确认服务器身份）。  
   - 客户端生成“预主密钥”`PreMasterSecret`，用服务器公钥加密后发送给服务器。  

4. **双方生成对称密钥**：  
   - 服务器用私钥解密`PreMasterSecret`，双方基于`ClientRandom`、`ServerRandom`、`PreMasterSecret`，通过相同算法生成“主密钥”`MasterSecret`。  

5. **握手完成，加密通信**：  
   - 客户端和服务器用`MasterSecret`生成会话密钥（对称密钥），后续HTTP数据通过对称密钥加密传输，同时用MAC（消息认证码）验证数据完整性（防止篡改）。  


### 44. 客户端怎么确定证书是服务端提供的？
客户端通过**证书链验证**确认证书来自合法服务器，核心流程：  

1. **验证证书签名**：  
   - 服务器证书包含“证书内容+CA签名”，客户端用CA的公钥（内置在操作系统/浏览器中，如Let’s Encrypt、Verisign的公钥）解密签名，对比证书内容的哈希值，若一致则证书未被篡改。  

2. **验证证书链完整性**：  
   - 服务器证书通常是“叶子证书”，需通过中间CA证书验证，中间CA再通过根CA证书验证（形成“叶子→中间→根”的证书链），根CA证书是操作系统/浏览器信任的“根证书”，无需再验证。  

3. **验证证书有效性**：  
   - 检查证书的“有效期”（未过期）、“用途”（是否用于服务器身份认证）、“吊销状态”（通过CRL或OCSP查询证书是否被吊销）。  

若以上验证均通过，客户端确认证书来自合法服务器；否则提示“证书错误”（如浏览器显示“您的连接不是私密连接”）。


### 45. 虚拟内存的原理，实现和作用？
#### 原理  
虚拟内存是操作系统提供的**内存抽象**，核心思想：将进程的虚拟地址空间（进程看到的连续地址）与物理内存（实际硬件内存）分离，通过“部分加载”和“磁盘交换”，让进程使用比物理内存更大的地址空间。  


#### 实现  
1. **地址映射**：通过**页表**（虚拟页→物理页的映射表）和**MMU（内存管理单元）**，将进程的虚拟地址转换为物理地址。  
2. **页面交换**：当物理内存不足时，操作系统将不常用的“物理页”写入磁盘交换区（Swap分区），释放物理内存；需使用时再从磁盘换入物理内存（“页面置换”，如LRU算法）。  
3. **页面保护**：页表记录虚拟页的权限（读/写/执行），MMU检查权限，防止越权访问（如只读页面禁止写入）。  


#### 作用  
- **扩大地址空间**：进程可使用远超物理内存的地址空间（如32位系统支持4GB虚拟内存）。  
- **简化内存管理**：进程看到连续的虚拟地址，无需关心物理内存的碎片化。  
- **隔离进程内存**：不同进程的虚拟地址空间独立，互不干扰（一个进程崩溃不影响其他进程）。  
- **高效利用内存**：仅加载进程当前需要的页面，避免物理内存浪费。


### 46. 实模式了解吗？和保护模式有什么区别？
实模式和保护模式是x86 CPU的两种工作模式，核心区别是“内存访问方式”和“安全性”：  

#### 实模式（Real Mode）  
- **出现场景**：CPU上电启动时默认进入实模式（如BIOS初始化阶段），仅支持16位地址。  
- **内存访问**：地址=段基址×16+偏移量，最大可访问1MB内存（20位地址线），无内存保护（进程可访问任意内存）。  
- **特点**：简单，无权限控制，无虚拟内存，仅用于早期DOS系统或系统启动阶段。  


#### 保护模式（Protected Mode）  
- **出现场景**：现代操作系统（Windows、Linux）运行的模式，支持32位/64位地址。  
- **内存访问**：通过“段选择子”和“段描述符表”访问内存，支持虚拟内存和分页机制，可访问4GB（32位）或更大内存。  
- **核心特性**：  
  - 内存保护：通过段描述符的权限位（如特权级0-3）限制进程访问权限，防止越权。  
  - 多任务支持：不同进程的段描述符表独立，实现内存隔离。  
  - 虚拟内存：结合页表实现地址映射和页面交换。  


### 47. 进程、线程、协程的区别
| 维度         | 进程（Process）                | 线程（Thread）                  | 协程（Coroutine）              |
|--------------|--------------------------------|--------------------------------|--------------------------------|
| **资源分配** | 操作系统资源分配的基本单位（独立内存、文件描述符） | 进程内的执行单元，共享进程资源（内存、文件描述符） | 用户态轻量级“线程”，共享线程资源（栈除外） |
| **调度者**   | 操作系统内核（抢占式调度）      | 操作系统内核（抢占式调度）      | 程序自身或运行时（协作/抢占式，如Go的GMP调度） |
| **开销**     | 大（MB级栈，切换需内核参与）    | 中（KB级栈，切换需内核参与）    | 极小（字节级栈，切换在用户态） |
| **并发能力** | 低（单进程支持数千进程）        | 中（单进程支持数万线程）        | 极高（单进程支持数百万协程）  |
| **通信方式** | IPC（管道、Socket等）           | 共享内存（需加锁）              | Channel、共享内存（需加锁）    |


### 48. 线程上下文具体指的什么？
线程上下文是线程执行时**CPU寄存器状态**和**线程私有数据**的集合，是线程切换时需要保存和恢复的核心数据，具体包括：  

1. **CPU寄存器**：  
   - 通用寄存器（如EAX、EBX，存储临时数据）、程序计数器（PC，存储下一条要执行的指令地址）、栈指针（SP，指向当前栈顶）。  
2. **线程私有数据**：  
   - 线程栈（存储局部变量、函数调用栈）、线程ID、调度状态（如运行/阻塞）、优先级、信号掩码（屏蔽哪些信号）。  

**作用**：当操作系统调度线程时，需保存当前线程的上下文到内存，加载新线程的上下文到CPU，确保新线程从上次暂停的位置继续执行（“上下文切换”）。


### 49. 几种常见的IO模型介绍一下
常见IO模型（以网络IO为例）按“阻塞程度”和“内核参与方式”分为5种：  

1. **阻塞IO（Blocking IO）**：  
   - 进程发起IO请求后，一直阻塞等待内核完成“数据准备”和“数据复制”，期间无法做其他事（如`recvfrom`默认行为）。  

2. **非阻塞IO（Non-Blocking IO）**：  
   - 进程发起IO请求后，内核立即返回（数据未准备好则返回错误），进程需轮询检查数据是否就绪，消耗CPU。  

3. **IO多路复用（IO Multiplexing）**：  
   - 进程通过select/poll/epoll等系统调用，同时监听多个IO事件，内核通知就绪的IO，进程再处理（单线程管理多连接，无阻塞）。  

4. **信号驱动IO（Signal-Driven IO）**：  
   - 进程注册信号处理函数，内核数据就绪时发送SIGIO信号，进程在信号处理中完成IO，无需轮询（较少使用）。  

5. **异步IO（Asynchronous IO）**：  
   - 进程发起IO请求后立即返回，内核完成“数据准备”和“数据复制”后，主动通知进程（全程无阻塞，实现复杂，如Linux的`aio_*`函数）。  


### 50. SELECT调用支持的请求数上限多少？为什么是这个值？可以调整吗？
#### 上限  
SELECT调用支持的文件描述符（FD）上限默认是**1024**（Linux系统），且仅能监听读、写、异常三个FD集合，每个集合的上限都是1024。  


#### 原因  
SELECT的FD集合通过**位图（bitmask）** 实现，早期Linux内核用`fd_set`结构体存储FD集合，`fd_set`的大小由`FD_SETSIZE`宏定义（默认1024），位图的每一位对应一个FD，因此上限为1024。  


#### 可以调整吗？  
- **理论上可调整**：修改`FD_SETSIZE`宏定义并重新编译内核，但不推荐（会破坏系统兼容性，且SELECT的轮询机制在FD数量大时性能极差）。  
- **实际解决方案**：用epoll（Linux）或kqueue（BSD）替代SELECT，epoll无FD数量上限，且性能随FD数量增长无明显下降。


### 51. 几种IO模型的瓶颈在哪里？
1. **阻塞IO**：瓶颈是“单连接阻塞”，一个连接IO阻塞会导致整个进程无法处理其他连接，并发能力极低（仅支持数十个连接）。  
2. **非阻塞IO**：瓶颈是“轮询开销”，进程需频繁调用系统检查FD状态，CPU利用率低（FD数量大时轮询耗时）。  
3. **SELECT**：  
   - 瓶颈1：FD数量上限（默认1024）。  
   - 瓶颈2：轮询机制（每次调用需遍历所有FD，O(n)时间复杂度，FD数量大时性能差）。  
   - 瓶颈3：FD集合需从用户态复制到内核态，开销大。  
4. **POLL**：瓶颈与SELECT类似，虽无FD数量上限，但仍需轮询所有FD（O(n)），且FD集合复制开销大。  
5. **EPOLL**：瓶颈是“边缘触发（ET）的编程复杂度”，需一次性处理完FD的所有数据，否则会遗漏事件；但水平触发（LT）无此问题，整体性能最优。  
6. **异步IO**：瓶颈是“实现复杂”，不同操作系统支持不一致（如Linux的aio功能有限），工程上较少使用。


### 52. Redis为什么快？
Redis高性能的核心原因的是“**内存操作+单线程模型+高效数据结构**”，具体如下：  

1. **基于内存**：所有数据存储在内存中，避免磁盘IO的高延迟（内存访问速度约为磁盘的10万倍）。  
2. **单线程模型**：用一个主线程处理所有命令，避免多线程上下文切换和锁竞争的开销（单线程在内存操作中足够快，无需多线程）。  
3. **高效数据结构**：针对不同场景优化数据结构，如：  
   - String：用SDS（简单动态字符串）优化字符串操作。  
   - Hash：用压缩列表（小数据）或哈希表（大数据）存储。  
   - ZSet：用跳表（Skip List）实现有序存储，查询和插入效率O(logn)。  
4. **IO多路复用**：通过epoll（Linux）实现单线程管理多连接，非阻塞处理IO事件。  
5. **精简协议**：使用RESP（Redis Serialization Protocol）文本协议，解析速度快，适合网络传输。


### 53. 持久化模式有哪些？
Redis的持久化模式用于将内存数据写入磁盘，防止数据丢失，核心有两种：  

1. **RDB（Redis Database）**：  
   - 原理：按配置的时间间隔（如`save 60 1000`表示60秒内1000次写入）生成内存快照（二进制文件`dump.rdb`）。  
   - 优点：恢复速度快，文件体积小，适合备份和灾难恢复。  
   - 缺点：可能丢失最后一次快照后的数（如系统崩溃）。  

2. **AOF（Append Only File）**：  
   - 原理：记录所有写命令到日志文件（`appendonly.aof`），重启时重放日志恢复数据。  
   - 优点：数据安全性高（可配置`appendfsync always`实时同步），支持“重写”（压缩日志文件）。  
   - 缺点：日志文件体积大，恢复速度慢于RDB。  

3. **混合持久化（Redis 4.0+）**：  
   - 原理：AOF文件头部存储RDB快照，尾部存储增量AOF命令，兼顾RDB的恢复速度和AOF的数据安全性，默认开启。


### 54. Redis你刚才说了单线程，那么RDB持久化方式使用了BGSAVE指令，fork了一个子进程去持久化，父进程正常执行读写请求，这里的父子进程和刚刚说的单线程啥关系？
这里的“单线程”和“父子进程”不冲突，核心是“**主线程单线程，持久化通过子进程异步执行**”：  

1. **Redis的“单线程”定义**：指Redis的**主线程**（处理客户端命令的线程）是单线程，所有客户端的读写命令都由这一个主线程处理，避免多线程锁竞争。  

2. **BGSAVE的父子进程逻辑**：  
   - 执行`BGSAVE`时，主线程通过`fork()`系统调用创建一个子进程，子进程会复制主线程的内存数据（通过写时复制COW机制，初始不实际复制，仅在主线程修改数据时复制修改的页）。  
   - 子进程在后台异步生成RDB快照，期间主线程（单线程）继续处理客户端的读写命令，不阻塞。  
   - 子进程完成持久化后自动退出，不影响主线程的单线程模型。  

**总结**：子进程是“辅助线程”，仅用于持久化，不处理客户端命令；主线程始终是单线程，负责核心的命令处理，两者通过COW机制避免数据竞争。


### 55. AOF 持久化方式有什么缺点？
AOF持久化的核心缺点集中在**性能开销**和**日志管理**：  

1. **写入性能开销**：  
   - AOF需记录每个写命令，频繁写入磁盘会导致IO开销（尤其是`appendfsync always`模式，每次命令都刷盘，性能下降明显）。  
   - 即使是`appendfsync everysec`（每秒刷盘），仍可能在秒级故障中丢失数据。  

2. **日志文件体积大**：  
   - 大量重复命令（如`INCR count`执行1000次，AOF会记录1000条`INCR`命令）会导致日志文件急剧膨胀，占用磁盘空间。  

3. **恢复速度慢**：  
   - 重启时需重放所有AOF命令，日志文件越大，恢复时间越长（远慢于RDB的快照加载）。  

4. **重写机制的开销**：  
   - AOF重写（压缩日志）时，子进程需遍历内存数据生成新日志，期间主线程修改的数据需写入“重写缓冲区”，重写完成后合并，可能导致短暂IO峰值。


### 56. Redis集群化方案介绍下？
Redis的集群化方案主要有三种，用于解决单机容量和高可用问题：  

1. **主从复制（Master-Slave）**：  
   - 架构：一个主节点（Master）负责读写，多个从节点（Slave）复制主节点数据，仅提供读服务。  
   - 作用：实现数据备份和读负载均衡，主节点故障时需手动切换从节点为主节点。  

2. **哨兵模式（Sentinel）**：  
   - 架构：基于主从复制，增加哨兵节点（Sentinel），哨兵集群监控主从节点健康状态，主节点故障时自动选举从节点为主节点（故障转移）。  
   - 作用：实现高可用（自动故障转移），但无法解决单机容量瓶颈（所有节点存储全量数据）。  

3. **Redis Cluster（集群模式）**：  
   - 架构：多个主从节点组成集群，数据按哈希槽（16384个）分片存储到不同主节点，每个主节点有从节点备份。  
   - 作用：同时解决高可用（主节点故障时从节点晋升）和容量瓶颈（分片存储），支持水平扩展。  


### 57. 哨兵模式怎么选主的？具体流程说一下
哨兵模式的选主（故障转移）流程由哨兵集群协作完成，核心是“**主观下线→客观下线→选举Leader哨兵→选举新主节点**”：  

1. **主观下线（SDOWN）**：  
   - 单个哨兵节点通过`PING`命令检测主节点，若超过`down-after-milliseconds`（默认30秒）未响应，标记主节点为“主观下线”。  

2. **客观下线（ODOWN）**：  
   - 哨兵节点向其他哨兵发送“判断主节点是否下线”的请求，若超过`quorum`（配置的票数，如2）个哨兵认为主节点主观下线，标记主节点为“客观下线”（确认主节点故障）。  

3. **选举Leader哨兵**：  
   - 所有哨兵通过“投票”选举一个Leader哨兵，由Leader负责后续的故障转移（避免多个哨兵同时发起转移）。  

4. **选举新主节点**：  
   - Leader哨兵遍历所有从节点，按以下优先级选择新主节点：  
     1. 排除故障的从节点。  
     2. 选择`slave-priority`（从节点优先级）最高的从节点。  
     3. 优先级相同，选择复制偏移量（数据同步进度）最大的从节点（数据最完整）。  
     4. 偏移量相同，选择运行ID最小的从节点。  

5. **故障转移执行**：  
   - Leader哨兵向新主节点发送`SLAVEOF NO ONE`命令，使其成为主节点。  
   - 向其他从节点发送`SLAVEOF 新主节点IP:端口`命令，使其复制新主节点。  
   - 通知客户端新主节点地址，原主节点恢复后变为从节点。


### 58. 原先下线的主节点恢复了，系统怎么处理？
原先下线的主节点（旧主）恢复后，哨兵模式和Redis Cluster模式的处理逻辑不同：  

#### 哨兵模式  
1. 旧主节点恢复后，哨兵检测到其存活，会向其发送`SLAVEOF 新主节点IP:端口`命令，让旧主节点成为新主节点的从节点，复制新主节点的数据。  
2. 旧主节点不再承担读写服务，仅作为从节点提供读服务和数据备份，避免数据冲突（新主节点已接管写入，旧主节点的数据可能过时）。  


#### Redis Cluster模式  
1. 旧主节点恢复后，会联系集群中的其他节点，获取当前集群状态（如新主节点信息、哈希槽分配）。  
2. 旧主节点发现自己的哈希槽已分配给新主节点（故障转移时，哨兵或集群自动将旧主的槽迁移到新主），会自动转换为新主节点的从节点，复制新主节点的数据。  
3. 若需让旧主重新成为主节点，需手动调整（如迁移哈希槽到旧主），但通常无需操作，保持从节点角色即可。


### 59. 集群模式使用什么算法进行分片的？
Redis Cluster采用**哈希槽（Hash Slot）分片算法**，核心是“将数据按key哈希映射到固定数量的哈希槽，再将哈希槽分配给集群节点”：  

1. **哈希槽总数**：16384个（0~16383）。  
2. **key映射逻辑**：  
   - 对key执行`CRC16(key)`计算哈希值，再对16384取模（`CRC16(key) % 16384`），得到key所属的哈希槽。  
   - 特殊情况：若key包含“`{}`”，则仅对`{}`内的字符串计算哈希（如`key = "user:{123}:name"`，仅对“123”计算哈希，确保同一用户的不同key映射到同一槽）。  
3. **槽分配**：集群中的每个主节点负责一部分哈希槽（如3个主节点，分别负责0~5460、5461~10922、10923~16383），从节点复制主节点的槽数据。  

**优势**：分片规则简单，节点扩容/缩容时仅需迁移哈希槽（无需迁移数据），灵活性高。


### 60. 集群节点之间通过什么协议进行通信？
Redis Cluster节点之间通过**Gossip协议**（流言协议）进行通信，核心是“节点间定期交换集群状态信息，实现去中心化的集群管理”：  

1. **通信内容**：  
   - 节点的基本信息（IP、端口、运行ID）。  
   - 节点的状态（主/从、健康状态）。  
   - 哈希槽的分配情况（哪个节点负责哪些槽）。  
   - 故障节点信息（标记下线的节点）。  

2. **通信方式**：  
   - 每个节点会随机选择几个其他节点，定期（默认每100毫秒）发送“ping”消息，包含自身的状态和已知的集群状态。  
   - 接收“ping”的节点会回复“pong”消息，反馈自身状态。  
   - 节点通过交换信息，逐步同步整个集群的状态（如某个节点故障，所有节点会逐渐知晓）。  

**优势**：去中心化（无中心节点），通信开销低（随机选择节点，非广播），适合大规模集群。


### 61. Slot的上限是多少？为什么是这个值？超过了会出现什么问题吗？
#### Slot上限  
Redis Cluster的哈希槽（Slot）上限是**16384个**（0~16383）。  


#### 为什么是16384？  
1. **节省带宽**：节点间通过Gossip协议交换槽信息时，槽的分配状态用“位图”表示（16384个槽对应16384位，即2048字节=2KB），位图体积小，减少通信带宽消耗。  
2. **平衡灵活性与性能**：16384个槽足够支持中小型集群（如100个主节点，每个节点负责163个槽），且槽迁移时粒度适中（迁移一个槽的数据量不大，性能影响小）。  
3. **历史原因**：早期Redis版本选择16384（2^14），兼顾实现复杂度和实际需求，后续版本未修改（足够满足大部分场景）。  


#### 超过了会出现什么问题？  
- **无法超过**：Redis Cluster的槽数量是硬编码的（16384），无法通过配置修改。  
- **若业务需要更多槽**：说明集群规模过大（如主节点超过1000个），此时应考虑拆分集群（如按业务模块拆分为多个独立的Redis Cluster），而非增加槽数量（槽数量过多会导致Gossip协议的通信开销增加，集群管理效率下降）。


### 62. MySQL的高可用怎么实现的？
MySQL的高可用方案核心是“**数据冗余+自动故障转移**”，常见方案：  

1. **主从复制+哨兵（MHA/Orchestrator）**：  
   - 架构：一主多从（主节点读写，从节点读），MHA（Master High Availability）或Orchestrator作为管理工具，监控主节点健康状态。  
   - 高可用逻辑：主节点故障时，工具自动选举从节点（基于复制进度、优先级），提升为新主节点，更新从节点的复制关系，通知应用切换地址。  

2. **MySQL Cluster（NDB Cluster）**：  
   - 架构：无共享存储的集群，数据存储在NDB存储引擎（分布式存储），多个SQL节点提供读写服务，管理节点负责集群管理。  
   - 高可用逻辑：数据自动分片存储在多个数据节点，副本冗余，单个节点故障不影响服务，自动故障转移。  

3. **Galera Cluster（Percona XtraDB Cluster）**：  
   - 架构：多主架构（所有节点可读写），基于Galera协议实现数据同步（写操作在所有节点执行成功后才返回）。  
   - 高可用逻辑：单个节点故障不影响其他节点，故障节点恢复后自动同步数据，无需手动切换。  

4. **云原生方案（如RDS高可用版）**：  
   - 云厂商（阿里云、AWS）提供的托管服务，默认配置主从架构，自动备份、故障转移、读写分离，用户无需手动维护。  


### 63. binlog日志有什么格式，生产上常用哪一种？
MySQL的binlog（二进制日志）有三种格式，核心区别是“记录数据修改的方式”：  

1. **STATEMENT格式**：  
   - 记录执行的SQL语句（如`UPDATE user SET age=20 WHERE id=1`），不记录数据的具体变化。  
   - 优点：日志体积小，备份恢复速度快。  
   - 缺点：部分SQL语句（如`NOW()`、`RAND()`）依赖上下文，主从复制时可能导致数据不一致。  

2. **ROW格式**：  
   - 记录数据行的具体变化（如“id=1的行，age从19改为20”），不记录SQL语句。  
   - 优点：主从复制一致性高（不依赖SQL上下文），支持细粒度的数据恢复（如恢复单条数据）。  
   - 缺点：日志体积大（尤其是批量更新时），备份恢复速度慢。  

3. **MIXED格式**：  
   - 自动选择STATEMENT或ROW格式：简单SQL用STATEMENT，复杂SQL（如含`NOW()`）用ROW。  
   - 优点：兼顾日志体积和复制一致性。  
   - 缺点：格式不固定，排查问题时需区分格式。  


#### 生产上常用哪一种？  
生产上优先使用**ROW格式**，原因：  
- 主从复制一致性高，避免STATEMENT格式的“不确定性SQL”导致的数据不一致（如电商订单、金融交易等核心业务，数据一致性优先级最高）。  
- 支持“闪回”（如用binlog2sql工具恢复误删的数据），ROW格式可精确恢复单条数据，STATEMENT格式无法实现。  
- 虽日志体积大，但可通过“binlog日志轮转”（`expire_logs_days`配置过期时间）和“压缩”（如zstd）缓解磁盘压力。


### 64. 读写分离会产生什么问题？
MySQL读写分离（主节点写，从节点读）虽能提升性能，但会引入以下问题：  

1. **数据延迟（主从同步延迟）**：  
   - 主节点执行写操作后，数据需通过binlog同步到从节点，存在毫秒级/秒级延迟；若从节点读取未同步的数据，会导致“读旧数据”（如用户刚下单，从节点查不到订单）。  

2. **事务一致性问题**：  
   - 同一事务中，先写主节点再读从节点，可能读取到事务未提交或未同步的数据，破坏事务一致性。  

3. **故障转移复杂**：  
   - 主节点故障时，需将从节点提升为主节点，同时调整其他从节点的复制关系和应用的读写路由，手动操作易出错（需依赖MHA等工具自动处理）。  

4. **查询路由问题**：  
   - 应用需区分“读操作”和“写操作”，将读路由到从节点，写路由到主节点；复杂查询（如含子查询、事务内查询）可能需强制路由到主节点，增加应用复杂度。  

5. **从节点数据冗余**：  
   - 所有从节点存储全量数据，浪费磁盘空间（尤其是大表场景）。  


### 65. 设计一张表，如何设计合适的表结构？
设计MySQL表结构需遵循“**业务优先、性能优化、规范统一**”原则，具体步骤：  

1. **明确业务需求**：  
   - 确定表的核心功能（如“用户表”需存储用户基本信息、登录信息），列出所有字段及字段类型（如`id`用INT/BIGINT，`username`用VARCHAR(50)）。  
   - 区分“必填字段”（如`username`、`password`）和“可选字段”（如`avatar`、`remark`），必填字段设置`NOT NULL`并添加默认值（避免NULL值影响索引和查询）。  

2. **选择合适的字段类型**：  
   - 整数：优先用INT（4字节）、BIGINT（8字节），避免用CHAR存储数字（如`phone`用VARCHAR(20)，不用INT）。  
   - 字符串：短字符串用VARCHAR（如`username`），长文本用TEXT（如`user_desc`），避免VARCHAR(255)存储超长文本。  
   - 时间：用DATETIME（存储年月日时分秒，支持范围查询）或TIMESTAMP（自动记录创建/更新时间，依赖时区），不用VARCHAR存储时间（无法排序和范围查询）。  

3. **设计主键和索引**：  
   - 主键：用自增INT/BIGINT（如`id`）或UUID（分布式场景），避免复合主键（如`username+phone`）。  
   - 索引：为高频查询字段建索引（如`username`、`phone`），联合索引遵循“最左前缀原则”（如查询`WHERE age=20 AND gender=1`，建索引`(age, gender)`），避免过度索引（影响写入性能）。  

4. **优化表结构**：  
   - 拆分大表：字段过多时拆分表（如`user`表拆分为`user_base`（基本信息）和`user_ext`（扩展信息）），避免单表字段冗余。  
   - 避免冗余字段：如“订单表”不存储“用户名”（可通过`user_id`关联`user`表查询），减少数据不一致风险。  
   - 分表分库预留：大表（如预计数据量超1000万）需预留分表字段（如`user_id % 10`分10张表）。  

5. **添加表注释和规范**：  
   - 表和字段添加注释（如`COMMENT '用户表'`），便于维护。  
   - 遵循命名规范：表名用小写+下划线（如`user_base`），字段名用小写+下划线（如`user_name`），避免关键字（如`order`用`orders`）。  


### 66. 索引失效的场景？
MySQL索引失效的核心原因是“**查询条件破坏索引匹配规则**”或“**优化器认为全表扫描更优**”，常见场景：  

1. **不满足最左前缀原则**：  
   - 联合索引（如`(a, b, c)`）需从最左字段开始匹配，跳过中间字段会导致索引失效（如`WHERE b=2 AND c=3`，索引失效；`WHERE a=1 AND c=3`，仅`a`字段用索引）。  

2. **索引字段参与函数或运算**：  
   - 索引字段用函数（如`WHERE SUBSTR(username, 1, 3)='abc'`）或运算（如`WHERE id+1=10`），索引无法使用（优化器无法计算函数结果对应的索引键）。  

3. **使用不等于、NOT IN、IS NOT NULL**：  
   - 条件含`!=`、`<>`、`NOT IN`、`IS NOT NULL`（如`WHERE age != 20`），优化器可能认为全表扫描比走索引快，导致索引失效（结果集小时仍可能走索引）。  

4. **字符串不加引号**：  
   - 字符串字段用数字条件（如`WHERE username=123`，`username`是VARCHAR类型），MySQL会隐式转换类型（`CAST(username AS UNSIGNED)`），导致索引失效。  

5. **OR连接的条件中有字段无索引**：  
   - `OR`连接的条件中，部分字段无索引（如`WHERE a=1 OR b=2`，`a`有索引，`b`无索引），整个查询会走全表扫描，`a`的索引失效。  

6. **LIKE以%开头**：  
   - `LIKE`查询以`%`开头（如`WHERE username LIKE '%abc'`），无法使用前缀索引（索引按前缀排序，无法匹配后缀）；`LIKE 'abc%'`可正常使用索引。  

7. **使用覆盖索引但查询字段超出索引范围**：  
   - 覆盖索引（如`(a, b)`）查询时，若查询字段包含非索引字段（如`SELECT a, b, c FROM t WHERE a=1`），需回表查询，索引虽未完全失效，但性能下降（严格来说不算“失效”，但未利用覆盖索引）。  

8. **MySQL优化器选择全表扫描**：  
   - 当查询结果集占表数据量的比例较大（如`WHERE age>10`，结果集占90%），优化器认为全表扫描比走索引快，会放弃索引。  


### 67. 微服务治理的方案？
微服务治理是“**保障微服务架构稳定、高效运行**”的一系列措施，核心包括**服务注册发现、配置管理、熔断限流、监控追踪、安全控制**：  

1. **服务注册与发现**：  
   - 方案：服务启动时注册到注册中心（如Nacos、Eureka、Consul），客户端从注册中心获取服务地址，实现动态路由（避免硬编码IP）。  
   - 工具：Nacos（阿里，支持注册+配置）、Eureka（Netflix，AP架构）、Consul（HashiCorp，支持健康检查）。  

2. **配置中心**：  
   - 方案：将服务配置（如数据库地址、接口开关）集中存储在配置中心，支持动态更新（无需重启服务），避免配置分散在代码或配置文件中。  
   - 工具：Nacos、Apollo（携程）、Spring Cloud Config。  

3. **熔断与限流**：  
   - 熔断：服务依赖故障时（如超时、错误率高），触发熔断（快速返回默认值），避免级联失败（如Sentinel的熔断规则）。  
   - 限流：限制服务的QPS（如令牌桶算法），防止流量过载（如Sentinel、Guava RateLimiter）。  
   - 工具：Sentinel（阿里）、Hystrix（Netflix，已停更）、Resilience4j。  

4. **服务监控与追踪**：  
   - 监控：收集服务的CPU、内存、响应时间、错误率等指标，实时告警（如Prometheus+Grafana）。  
   - 追踪：跟踪请求链路（如用户下单→订单服务→支付服务），定位性能瓶颈（如Jaeger、Zipkin）。  
   - 工具：Prometheus+Grafana（监控）、Jaeger/Zipkin（链路追踪）、SkyWalking（全链路监控）。  

5. **API网关**：  
   - 方案：统一入口，处理路由转发、认证授权、限流、日志记录，避免客户端直接调用微服务。  
   - 工具：Spring Cloud Gateway、Kong、APISIX。  

6. **服务安全**：  
   - 认证授权：通过OAuth2.0、JWT实现服务间认证（如客户端用JWT令牌调用服务）。  
   - 接口加密：敏感接口用HTTPS加密，避免数据泄露。  
   - 工具：Spring Security OAuth2、Keycloak。  

7. **服务部署与运维**：  
   - 容器化：用Docker打包服务，K8s实现服务编排（自动扩缩容、滚动更新）。  
   - 灰度发布：通过金丝雀部署、蓝绿部署，逐步发布新版本，降低故障风险。  
   - 工具：Docker、K8s、ArgoCD（GitOps部署）。  


### 68. 了解docker和k8s吗？有没有使用过？
#### Docker  
- **了解**：Docker是容器化工具，通过Namespace（资源隔离）和Cgroups（资源限制），将应用及依赖打包为“容器”，实现“一次构建，到处运行”，解决环境一致性问题。  
- **核心概念**：镜像（Image，容器的模板）、容器（Container，镜像的运行实例）、仓库（Repository，存储镜像的地方，如Docker Hub）。  
- **使用场景**：开发环境一致性（开发和生产用相同容器）、微服务部署（每个微服务打包为独立容器）、CI/CD流水线（容器化构建和测试）。  
- **实际使用**：曾用Docker打包Go微服务（编写Dockerfile，构建镜像`docker build -t my-service:v1 .`，运行容器`docker run -p 8080:8080 my-service:v1`），用Docker Compose编排多容器应用（如服务+数据库）。  


#### K8s（Kubernetes）  
- **了解**：K8s是容器编排平台，用于管理大规模Docker容器集群，提供服务发现、负载均衡、自动扩缩容、滚动更新等能力，是微服务架构的核心运维工具。  
- **核心概念**：Pod（最小部署单元，含一个或多个容器）、Service（Pod的访问入口，实现负载均衡）、Deployment（管理Pod的创建和更新）、ConfigMap/Secret（存储配置和敏感信息）。  
- **使用场景**：生产环境微服务部署（如管理100+容器）、自动运维（CPU使用率超80%时自动扩容Pod）、灰度发布（通过Deployment的`rollout`实现）。  
- **实际使用**：曾用K8s部署Go微服务，通过YAML文件定义Deployment（指定镜像、资源限制、副本数），用`kubectl apply -f deployment.yaml`创建资源；配置Service暴露服务（NodePort或ClusterIP），用Prometheus监控Pod状态；通过HPA（Horizontal Pod Autoscaler）实现Pod自动扩缩容。
