## 网易
### 1. 不同包的多个init函数的运行时机
- 同一包内的多个init函数按源码出现顺序执行。
- 不同包的init函数，按包的导入依赖关系执行（被依赖的包先执行）。
- 所有init函数均在main函数执行前完成，属于程序初始化阶段。


### 2. init和main函数的执行顺序
- 所有init函数（按包依赖和源码顺序）先执行。
- 所有init执行完毕后，才会执行main函数。
- 一个包可包含多个init，一个程序中main函数有且仅有一个。


### 3. 如何删除切片中的某一个元素
- 常用方式：通过切片表达式和append组合，如删除索引i的元素：`a = append(a[:i], a[i+1:]...)`。
- 注意：若原切片有其他引用，可能导致内存泄漏（可手动置空被删除元素位置的值）。


### 4. sync.Map{}怎么使用
- 存储：`syncMap.Store(key, value)`。
- 获取：`value, ok := syncMap.Load(key)`（ok判断是否存在）。
- 删除：`syncMap.Delete(key)`。
- 遍历：`syncMap.Range(func(key, value interface{}) bool { ... })`（返回false停止遍历）。
- 适用于读多写少场景，无需额外加锁。


### 5. 怎么控制并发操作map
- 用`sync.Mutex`：读写均加锁，适合读写频率相近场景。
- 用`sync.RWMutex`：读操作加读锁（共享），写操作加写锁（独占），适合读多写少场景。
- 用`sync.Map`：Go 1.9+提供的并发安全map，内部优化了读写性能。


### 6. go的读写锁怎么工作
- 读写锁（`sync.RWMutex`）有两种模式：读锁（RLock/RUnlock）和写锁（Lock/Unlock）。
- 读锁：多个goroutine可同时获取，不阻塞其他读锁，但阻塞写锁。
- 写锁：仅一个goroutine可获取，阻塞其他所有读锁和写锁。
- 规则：写锁释放前，所有等待的读锁或写锁需排队；读锁释放后，优先唤醒写锁（避免写饥饿）。


### 7. 如何保存程序崩溃时的数据
- 用`defer + recover`捕获panic，在崩溃前保存关键数据（如写入文件、数据库）。
- 示例：
  ```go
  defer func() {
      if err := recover(); err != nil {
          // 保存数据逻辑
      }
  }()
  ```
- 配合日志框架记录崩溃上下文，便于事后分析。


### 8. 多个并发操作对map进行读写，程序会发生什么
- 会触发panic（程序崩溃）。Go原生map不支持并发读写，检测到数据竞争时会直接崩溃，属于有意设计的“快速失败”机制。


### 9. 超时处理
- 用`context.WithTimeout`：创建带超时的context，传递给子协程，超时后通过`ctx.Done()`通知退出。
- 用`time.After`：结合select，超时后执行特定逻辑，需注意避免goroutine泄漏。
- 推荐用context，更适合在复杂调用链中传递超时信号。


### 10. 对一个已经关闭的channel读写会发生什么
- 读操作：若channel有剩余数据，可正常读取；数据读完后，返回对应类型的零值和`false`（`v, ok := <-ch`中ok为false）。
- 写操作：向已关闭的channel发送数据会立即触发panic。
- 注意：重复关闭channel也会导致panic。


### 11. 开五个协程全部执行一个函数，怎么保证协程执行完全部打印
- 用`sync.WaitGroup`：
  1. 初始化`wg := sync.WaitGroup{}`，调用`wg.Add(5)`设置计数。
  2. 每个协程启动前`wg.Add(1)`（或统一在启动前Add(5)），执行完毕后调用`wg.Done()`。
  3. 主协程调用`wg.Wait()`阻塞，直到所有协程执行完毕再继续。

### 12. goroutine 异常退出能释放 Redis 分布式锁吗
不一定。  
- 若分布式锁设置了过期时间，即使 goroutine 异常退出，锁到期后会自动释放（依赖 Redis 过期机制）。  
- 若未设置过期时间，且异常退出前未执行释放锁的逻辑（如 `DEL` 命令），锁会永久残留，导致死锁。  

因此，Redis 分布式锁必须设置合理的过期时间，并结合看门狗机制（定期续期），以应对 goroutine 异常退出的情况。

### 13. redis的大key问题
大key指占用redis中占用内存过大的键（通常认为单key内存超过100MB或元素数量过多，如哈希表含10万+字段）。  
危害：  
- 占用大量内存，可能导致内存溢出；  
- 读写时阻塞Redis主线程，影响响应速度；  
- 序列化/反序列化耗时，增加CPU负担；  
- 过期删除或淘汰时耗时过长，引发性能波动。  


### 14. 怎么查出大key
- **使用Redis自带命令**：  
  - `MEMORY USAGE key`：查看单个key的内存占用；  
  - `DEBUG OBJECT key`：查看key的详细信息（如序列化方式、元素数量）；  
  - 扫描所有键：`SCAN 0 COUNT 1000` 结合 `MEMORY USAGE` 批量检查（避免阻塞）。  
- **工具辅助**：  
  - Redis-cli的`--bigkeys`参数：`redis-cli --bigkeys`，统计各类型中元素最多的key；  
  - 第三方工具：如redis-rdb-tools（解析RDB文件分析大key）、Redis Insight。  


### 15. 怎么解决大key问题
- **拆分大key**：  
  - 哈希表（Hash）：按字段拆分到多个小哈希表（如按ID范围分片）；  
  - 列表（List）：拆分为多个小列表，按序号命名（如list_1、list_2）；  
  - 集合（Set/ZSet）：类似列表拆分，按元素特征分片。  
- **优化存储结构**：  
  - 用`ziplist`编码（小数据时Redis自动使用），减少内存开销；  
  - 避免存储冗余数据（如只存必要字段）。  
- **其他措施**：  
  - 大key过期时间错开峰值，避免集中删除；  
  - 读写大key时限制频率，避免阻塞主线程。  


### 16. redis的架构怎么选主
Redis主从架构中，选主（主节点故障后从节点晋升为主）主要通过**哨兵（Sentinel）机制**实现：  
1. 哨兵集群持续监控主从节点健康状态；  
2. 当主节点故障，哨兵通过**投票机制**（超过半数哨兵确认故障）判定主节点下线；  
3. 从候选从节点中选择新主：优先选优先级高（`slave-priority`）、复制进度最接近原主、运行时间较久的从节点；  
4. 新主产生后，哨兵通知其他从节点切换复制目标，客户端更新主节点地址。  


### 17. 内存容量怎么使用
- **合理设置内存上限**：通过`maxmemory`配置Redis最大可用内存，避免占用过多系统资源。  
- **内存淘汰策略**：当内存达到上限，根据业务场景选择淘汰策略（如`allkeys-lru`淘汰最近最少使用的键，`volatile-ttl`淘汰即将过期的键）。  
- **内存碎片优化**：  
  - 启用`activedefrag yes`自动碎片整理；  
  - 定期重启Redis（适用于非持久化场景）。  
- **监控与预警**：通过`INFO memory`查看内存使用情况（如`used_memory`、`mem_fragmentation_ratio`），设置内存使用率阈值预警。  


### 18. 缓存怎么持久化
Redis提供两种持久化方式：  
- **RDB（Redis Database）**：  
  - 原理：按指定时间间隔生成内存数据的快照（二进制文件，如dump.rdb）；  
  - 配置：`save 900 1`（900秒内有1次写入则触发）；  
  - 优势：文件小、恢复快；劣势：可能丢失最后一次快照后的 data。  
- **AOF（Append Only File）**：  
  - 原理：记录所有写命令到日志文件（文本格式），重启时重放命令恢复数据；  
  - 配置：`appendonly yes`，同步策略（`appendfsync everysec`每秒同步一次）；  
  - 优势：数据安全性高（最多丢失1秒数据）；劣势：文件大、恢复慢。  
- **混合持久化（4.0+）**：RDB+AOF结合，既保证恢复速度，又减少数据丢失风险。
