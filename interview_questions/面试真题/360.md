## 360
### 1. golang GC 回收介绍 (标记清除, 三色标记法, 混合写屏障)
Golang 的垃圾回收（GC）采用**并发标记-清除**算法，并结合多种三色标记法**和**混合写屏障**优化，核心机制如下：

- **标记-清除（Mark-Sweep）**：  
  - **标记阶段**：从根对象（全局变量、栈变量、寄存器引用）出发，遍历所有可达对象并标记，确认存活内存。  
  - **清除阶段**：回收未标记的垃圾对象，将空闲内存加入空闲链表，供后续分配使用。  

- **三色标记法**：  
  为解决并发标记时的对象引用变化问题，通过三色标记区分对象状态：  
  - 白色：未标记（初始状态）。  
  - 灰色：待标记（已发现但未遍历其引用）。  
  - 黑色：已标记（及其引用均已遍历）。  
  标记过程中，通过颜色转换确保所有可达对象最终被标记为黑色。  

- **混合写屏障**：  
  结合“插入写屏障”和“删除写屏障”的优势，在并发标记时：  
  - 当向黑色对象添加白色引用时（插入），将白色对象标记为灰色。  
  - 当从灰色/白色对象删除引用时（删除），若被删除对象为白色，将其标记为灰色。  
  以此避免并发标记时的漏标问题，减少 STW（Stop The World）时间。  


### 2. 什么时候会触发 golang GC 呢
Golang GC 触发时机主要有三种：  

1. **内存阈值触发**：当堆内存增长达到“上次 GC 后堆大小的 2 倍”（默认阈值）时自动触发，避免内存过度增长。  

2. **定时触发**：若长期未达内存阈值，每 2 分钟强制触发一次 GC，防止内存泄漏累积。  

3. **手动触发**：通过 `runtime.GC()` 函数手动触发，通常用于测试或特殊场景（不建议线上频繁调用，会增加性能开销）。  


### 3. golang channel 你会用在什么地方 (一个是控制 goroutine数量 一个是主main 控制关闭 子 goroutine)
Channel 是 Golang 中 goroutine 通信的核心机制，常见使用场景包括：  

1. **控制 goroutine 数量**：  
   通过带缓冲的 channel 实现“信号量”，限制并发 goroutine 数量。例如：  
   ```go
   limit := make(chan struct{}, 10) // 限制最多10个并发
   for i := 0; i < 100; i++ {
       limit <- struct{}{} // 获取信号量，满则阻塞
       go func() {
           defer func() { <-limit }() // 释放信号量
           // 业务逻辑
       }()
   }
   ```  

2. **主 goroutine 控制子 goroutine 关闭**：  
   通过关闭 channel 发送“退出信号”，子 goroutine 监听 channel 状态退出。例如：  
   ```go
   stop := make(chan struct{})
   go func() {
       for {
           select {
           case <-stop: // 收到关闭信号
               return
           default:
               // 业务逻辑
           }
       }
   }()
   // 主 goroutine 关闭子 goroutine
   close(stop)
   ```  

3. **数据传递与同步**：  
   实现 goroutine 间的安全数据交换（无锁通信），或通过无缓冲 channel 实现同步等待（如 `<-ch` 等待另一方发送数据）。  


### 4. golang 如何做超时控制 ? (time.After 和 context.WithTimeOut)
Golang 常用两种超时控制方式：  

1. **`time.After` 结合 `select`**：  
   适用于简单场景，通过 `time.After(d)` 生成一个超时 channel，超时后发送信号。例如：  
   ```go
   select {
   case res := <-resultCh: // 正常接收结果
       fmt.Println("Result:", res)
   case <-time.After(3 * time.Second): // 3秒超时
       fmt.Println("Timeout")
   }
   ```  

2. **`context.WithTimeout`**：  
   适用于复杂场景（如多层 goroutine 传递超时信号），通过 context 管理超时。例如：  
   ```go
   ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
   defer cancel() // 确保资源释放

   go func(ctx context.Context) {
       // 子 goroutine 监听超时
       <-ctx.Done()
       fmt.Println("Sub goroutine timeout:", ctx.Err())
   }(ctx)

   // 主逻辑等待超时
   <-ctx.Done()
   fmt.Println("Main timeout:", ctx.Err())
   ```  


### 5. golang select 一般使用在什么场景
`select` 语句用于同时监听多个 channel 的操作，常见场景：  

1. **多 channel 等待**：同时等待多个 channel 的数据发送/接收，任意一个就绪则执行对应分支。  

2. **超时控制**：结合 `time.After` 实现操作超时（如网络请求、任务执行超时）。  

3. **优雅退出**：监听“业务 channel”和“退出信号 channel”，实现 goroutine 优雅退出。  

4. **默认操作**：通过 `default` 分支避免阻塞，实现“非阻塞发送/接收”（如尝试发送数据，失败则立即返回）。  

示例：  
```go
select {
case msg := <-ch1:
    fmt.Println("Received from ch1:", msg)
case ch2 <- "hello":
    fmt.Println("Sent to ch2")
case <-time.After(1 * time.Second):
    fmt.Println("Timeout")
default:
    fmt.Println("No operation ready")
}
```  


### 6. golang 如何比较两个 map 使用相等
Golang 中 map 无法直接通过 `==` 比较（仅能与 `nil` 比较），判断两个 map 相等需手动校验：  

1. 检查两个 map 的**长度是否相等**（长度不等则必然不相等）。  
2. 遍历其中一个 map 的所有键值对，检查另一个 map 中是否存在相同的键，且对应的值**深度相等**（需注意值为引用类型的情况）。  

示例（使用 `reflect.DeepEqual` 辅助比较值）：  
```go
func mapsEqual(a, b map[string]int) bool {
    if len(a) != len(b) {
        return false
    }
    for k, vA := range a {
        vB, ok := b[k]
        if !ok || vA != vB {
            return false
        }
    }
    return true
}

// 若值为引用类型（如 map、slice），需用 reflect.DeepEqual
func mapsEqualDeep(a, b map[string][]int) bool {
    if len(a) != len(b) {
        return false
    }
    for k, vA := range a {
        vB, ok := b[k]
        if !ok || !reflect.DeepEqual(vA, vB) {
            return false
        }
    }
    return true
}
```  


### 7. 介绍 k8s 基础组件 及其之间的协作 功能
Kubernetes（k8s）核心组件及协作流程如下：  

- **控制平面组件（Master 节点）**：  
  - **API Server**：所有操作的统一入口（RESTful API），负责认证、授权、数据校验，是组件间通信的枢纽。  
  - **etcd**：分布式键值存储，保存集群所有状态（如 Pod、Service 配置）。  
  - **Scheduler**：负责 Pod 的调度，根据节点资源（CPU、内存）、亲和性等规则，选择合适的节点运行 Pod。  
  - **Controller Manager**：运行各种控制器（如 Deployment Controller、Node Controller），确保集群状态与期望状态一致（如 Deployment 保证 Pod 数量符合 replicas 配置）。  
  - **Cloud Controller Manager**：对接云服务商 API（如 AWS、GCP），管理云资源（如负载均衡、存储）。  

- **节点组件（Worker 节点）**：  
  - **Kubelet**：运行在每个节点，确保容器按照 Pod 定义运行（与 API Server 通信，汇报节点和 Pod 状态）。  
  - **Kube-proxy**：维护节点网络规则，实现 Service 的负载均衡（通过 iptables 或 IPVS 转发流量到 Pod）。  
  - **容器运行时（如 Containerd）**：负责容器的生命周期管理（创建、启动、停止容器）。  

- **协作流程**：  
  用户通过 `kubectl` 向 API Server 提交请求（如创建 Deployment），API Server 将配置存入 etcd；  
  Controller Manager 监听 API Server，发现期望状态与实际状态差异后，触发调度（Scheduler 选择节点）；  
  Kubelet 监听 API Server，在指定节点创建 Pod（通过容器运行时启动容器）；  
  Kube-proxy 同步 Service 规则，实现外部流量到 Pod 的转发。  


### 8. 介绍一个 Service 有什么类型 作用?
K8s Service 是**Pod 的逻辑集合**，提供固定访问入口和负载均衡，解决 Pod 动态创建/销毁导致的 IP 变化问题。  

- **核心作用**：  
  1. 为一组 Pod 提供**固定访问地址**（ClusterIP），屏蔽 Pod IP 变化。  
  2. 实现 Pod 间的**负载均衡**（默认轮询）。  
  3. 支持**服务发现**（通过 DNS 或环境变量，Pod 可通过 Service 名称访问其他服务）。  

- **主要类型**：  
  1. **ClusterIP**：默认类型，仅在集群内部暴露 Service（分配集群内唯一 IP），供集群内 Pod 访问。  
  2. **NodePort**：在每个节点开放静态端口（30000-32767），外部通过 `节点IP:NodePort` 访问 Service，适用于测试环境。  
  3. **LoadBalancer**：对接云服务商负载均衡器，自动分配公网 IP，外部通过负载均衡器访问，适用于生产环境。  
  4. **ExternalName**：将 Service 映射到外部域名（如 `example.com`），无需选择器，直接返回 CNAME 记录。  


### 9. Ingress 和 Service 是如何搭配使用 从网络的角度上来说 分别工作于哪一层
Ingress 和 Service 配合实现**从集群外部到内部服务的 HTTP/HTTPS 流量管理**，网络层分工如下：  

- **Service**：工作在**传输层（TCP/UDP）**，为 Pod 提供固定访问端点和 4 层负载均衡（基于 IP+端口转发）。但 Service 无法处理 HTTP 路径路由、域名解析等 7 层功能。  

- **Ingress**：工作在**应用层（HTTP/HTTPS）**，通过 Ingress 资源定义 7 层路由规则（如基于域名、URL 路径转发），并依赖 Ingress Controller（如 Nginx Ingress）实现规则落地。  

- **搭配流程**：  
  1. 外部 HTTP/HTTPS 流量先到达 Ingress Controller（通常暴露为 LoadBalancer 类型 Service）。  
  2. Ingress Controller 根据 Ingress 规则，将流量转发到对应的后端 Service（如 `api.example.com` 转发到 `api-service`）。  
  3. Service 再将流量负载均衡到后端 Pod。  

例如：通过 Ingress 配置 `www.example.com/path1` 转发到 `service1`，`www.example.com/path2` 转发到 `service2`，实现单域名多路径的路由管理。  


### 10. TCP/IP 五层
TCP/IP 协议栈分为五层（从下到上），每层负责不同的网络功能：  

1. **物理层**：负责**比特流传输**（如电信号、光信号），定义硬件接口（如网线、光纤、网卡），不涉及数据格式。  

2. **数据链路层**：负责**相邻设备间的数据帧传输**，实现 MAC 地址寻址（如以太网的 MAC 帧）、差错检测（CRC 校验）、流量控制。典型协议：以太网（Ethernet）、Wi-Fi。  

3. **网络层**：负责**跨网络的数据包路由**，实现 IP 地址寻址、路由选择（通过路由表）、分片/重组。核心协议：IP（IPv4/IPv6）、ICMP（ping 命令）、ARP（IP 转 MAC）。  

4. **传输层**：负责**端到端的数据传输**，提供可靠/不可靠传输、流量控制、拥塞控制。核心协议：  
   - TCP（可靠传输，面向连接，如 HTTP、FTP）；  
   - UDP（不可靠传输，无连接，如 DNS、视频流）。  

5. **应用层**：直接为应用程序提供服务，定义数据格式和交互逻辑。常见协议：HTTP（网页）、DNS（域名解析）、FTP（文件传输）、SMTP（邮件）。  

数据传输时，每层对上层数据添加头部（封装），接收时逐层拆封头部，最终传递到应用程序。

### 11. 最复杂的数据处理涉及的数据量级有多少
### 12. 数据源是什么？
### 13. 有没有遇到过什么性能问题，是怎么解决的？
### 14. ORM 框架的理解  
ORM（Object-Relational Mapping，对象关系映射）是**连接面向对象代码与关系型数据库的中间层**，核心是将数据库表结构映射为代码中的“模型对象”，表字段映射为对象属性，SQL 操作转化为对象方法调用。  

- **核心价值**：  
  1. **简化开发**：无需手动编写 SQL，通过对象方法（如 `user.Create()`、`db.Where("id = ?", 1).First(&user)`）实现 CRUD，降低数据库操作的学习和编码成本。  
  2. **跨库兼容**：同一套 ORM 代码可适配多种关系型数据库（MySQL、PostgreSQL、SQL Server 等），切换数据库时无需大量修改业务代码。  
  3. **安全防护**：自动实现参数化查询，避免 SQL 注入风险（如将 `WHERE name = '${name}'` 转为 `WHERE name = ?`，参数单独传递）。  

- **局限性**：  
  1. **性能损耗**：复杂查询（如多表联查、自定义函数、子查询）的 ORM 自动生成 SQL 可能冗余（如多余的字段查询、低效的 JOIN 顺序），效率低于手写优化 SQL。  
  2. **灵活性不足**：极端场景（如分库分表、复杂事务、存储过程调用）需突破 ORM 封装，手动编写原生 SQL。  

- **常见框架**：Golang 的 GORM、Java 的 MyBatis（半 ORM，需写 XML 映射）/Hibernate（全 ORM）、Python 的 SQLAlchemy。  


### 15. 一条语句执行情况的查询（如何使用 explain 及其参数）  
`EXPLAIN` 是 MySQL 提供的**SQL 执行计划分析工具**，通过它可查看 SQL 的索引使用、表扫描方式、数据读取行数等信息，快速定位查询效率瓶颈。  

#### 1. 使用方法  
在需分析的 SQL 前添加 `EXPLAIN` 关键字，示例：  
```sql
EXPLAIN SELECT id, name, price FROM goods WHERE category_id = 10 AND status = 1 ORDER BY sale_count DESC;
```  


#### 2. 核心参数解析  
执行后返回的结果集中，关键列含义如下：  
| 列名       | 核心含义                                                                 |
|------------|--------------------------------------------------------------------------|
| `id`       | SQL 执行顺序标识（子查询会生成多个 id，id 越大先执行；id 相同则按从上到下顺序执行） |
| `type`     | 访问类型（索引使用效率），优先级：`system > const > eq_ref > ref > range > index > ALL` <br> - `const/eq_ref`：主键/唯一索引匹配，效率最高；<br> - `range`：范围查询（如 `>`, `<`, `IN`），走索引；<br> - `ALL`：全表扫描，需优化 |
| `key`      | 实际使用的索引（若为 `NULL`，表示未使用任何索引）                         |
| `key_len`  | 使用的索引长度（越长表示使用的索引字段越多，如联合索引使用前 2 个字段，长度会更长） |
| `rows`     | MySQL 预估的扫描行数（值越小越好，代表查询范围越精准）                     |
| `Extra`    | 额外执行信息（关键提示）：<br> - `Using index`：索引覆盖，无需回表；<br> - `Using filesort`：需额外排序（未走索引排序，效率低）；<br> - `Using temporary`：使用临时表（如 `GROUP BY` 未走索引，需优化）；<br> - `Using where`：需过滤数据（可能走索引或全表扫描） |  


### 16. 什么情况下索引会失效？  
索引失效指 SQL 未按预期使用索引，转而触发全表扫描或低效扫描，常见场景如下：  

1. **索引列参与运算或函数**：  
   - 运算：如 `WHERE price + 50 > 200`（改为 `WHERE price > 150`，让索引列单独在条件左侧）；  
   - 函数：如 `WHERE SUBSTR(name, 1, 2) = '张'`（函数破坏索引的有序性，无法利用前缀匹配）。  

2. **隐式类型转换**：  
   索引列类型与查询值类型不匹配，触发自动转换。例如：索引列 `phone` 为 `VARCHAR` 类型，查询 `WHERE phone = 13800138000`（数字转字符串，索引失效，需改为 `WHERE phone = '13800138000'`）。  

3. **模糊查询前缀为 `%`**：  
   如 `WHERE name LIKE '%小明'`（`%` 在前，无法利用索引的前缀有序性）；而 `WHERE name LIKE '小明%'`（`%` 在后）可正常使用索引。  

4. **`OR` 连接非索引列**：  
   若 `OR` 两侧字段有一个无索引，整体查询会走全表扫描。例如：`WHERE id = 1 OR age = 25`（`age` 无索引，导致 `id` 的索引失效）。  

5. **不符合联合索引“最左前缀原则”**：  
   联合索引（如 `idx_a_b_c`）需从最左字段开始匹配，跳过左侧字段会导致索引失效。例如：`WHERE b = 2 AND c = 3`（跳过 `a`，索引失效）；`WHERE a = 1 AND c = 3`（仅 `a` 字段用索引，`c` 字段无法利用）。  

6. **MySQL 优化器判定全表扫描更优**：  
   当查询结果占表数据量比例较大（如 `WHERE status = 1` 匹配 30% 以上数据），优化器会认为全表扫描比走索引更快，主动放弃索引。  


### 17. 联合索引和单键索引的区别和优缺点，什么情况下使用联合索引  
#### 1. 定义与核心区别  
- **单键索引**：仅对单个字段创建的索引（如 `idx_user_id`、`idx_goods_price`），仅优化该字段的查询。  
- **联合索引**：对多个字段按顺序组合创建的索引（如 `idx_user_id_status`、`idx_a_b_c`），优化“最左前缀”相关的多字段组合查询。  


#### 2. 优缺点对比  
| 维度         | 单键索引                                 | 联合索引                                 |
|--------------|------------------------------------------|------------------------------------------|
| **查询优化** | 仅优化单个字段的查询（如 `WHERE id = ?`） | 优化“最左前缀”的多字段查询（如 `WHERE a=? AND b=?`），可减少回表 |
| **索引体积** | 小（仅存储单个字段值+主键），占用磁盘少   | 大（存储多个字段值+主键），占用磁盘多，维护成本高 |
| **写入影响** | 插入/更新/删除时，仅需维护一个索引，开销低 | 需维护多字段索引，写入性能比单键索引差     |
| **排序支持** | 仅支持单个字段排序（如 `ORDER BY id`）    | 支持“最左前缀”相关的多字段排序（如 `WHERE a=? ORDER BY b`），避免文件排序 |


#### 3. 联合索引的适用场景  
1. **高频多字段组合查询**：  
   若业务中频繁出现 `WHERE a = ? AND b = ?` 这类多字段条件查询，创建联合索引 `idx_a_b` 比分别创建 `idx_a`、`idx_b` 更高效（减少索引数量，避免多次索引查询）。  

2. **需利用索引覆盖或排序**：  
   - 索引覆盖：若查询字段（`SELECT` 后的字段）均在联合索引中，可避免回表。例如：联合索引 `idx_a_b_c`，查询 `SELECT a, b FROM table WHERE a = ? AND b = ?`，直接从索引获取数据。  
   - 排序优化：若查询需按多字段排序且包含前序查询条件，联合索引可避免文件排序。例如：`WHERE a = ? ORDER BY b, c`，联合索引 `idx_a_b_c` 可直接按索引顺序返回结果。  

3. **减少索引冗余**：  
   若已有联合索引 `idx_a_b_c`，则无需再创建 `idx_a`（联合索引的最左前缀 `a` 可单独作为索引使用），减少索引维护成本。  


### 18. 讲下索引覆盖  
索引覆盖（Covering Index）是指**查询所需的所有字段（`SELECT` 子句中的字段）均包含在索引中**，无需通过索引回表查询主键索引获取完整数据，从而大幅减少磁盘 IO，提升查询效率。  

#### 1. 原理（以 InnoDB 为例）  
InnoDB 的索引分为“聚簇索引”（主键索引，叶子节点存储完整数据行）和“二级索引”（非主键索引，叶子节点存储“索引字段值 + 主键值”）：  
- 若查询字段仅包含“二级索引字段 + 主键”，则直接从二级索引获取数据，无需访问聚簇索引（即“不回表”）；  
- 若查询字段包含非索引字段，则需先通过二级索引找到主键，再到聚簇索引中查询完整数据（即“回表”），增加一次磁盘 IO。  


#### 2. 示例  
假设有表 `user`，字段为 `id`（主键）、`name`、`age`、`gender`，创建联合索引 `idx_name_age`（`name` + `age`）：  
- **索引覆盖场景**：`SELECT name, age, id FROM user WHERE name = 'Alice'`  
  查询字段 `name`、`age` 是索引字段，`id` 是主键（二级索引叶子节点默认存储），无需回表，`EXPLAIN` 中 `Extra` 列会显示 `Using index`。  

- **非索引覆盖场景**：`SELECT name, age, gender FROM user WHERE name = 'Alice'`  
  查询字段 `gender` 不在索引中，需先通过 `idx_name_age` 找到主键 `id`，再到聚簇索引中查询 `gender`，`EXPLAIN` 中 `Extra` 列无 `Using index`。  


#### 3. 价值与注意事项  
- **价值**：减少磁盘 IO（避免回表），尤其对高频查询的小字段组合，性能提升显著。  
- **注意事项**：不要盲目创建“全字段索引”（如 `idx_name_age_gender_address`），需平衡“索引覆盖需求”与“索引维护成本”（索引字段越多，写入性能越差，磁盘占用越大）。  


### 19. 提到了 B+ 树，B+ 树是如何优化查询效率的  
B+ 树是 MySQL InnoDB 索引的底层数据结构，通过**多路平衡、有序存储、集中数据**三大设计，大幅优化查询效率，核心优化点如下：  

1. **多路平衡结构，降低树高，减少 IO**：  
   B+ 树是“多路”查找树（非二叉树），一个节点可存储多个键值对（如一个磁盘页大小为 16KB，每个键值对占 16B，可存储 1000 个键值）。  
   - 3 层 B+ 树即可存储约 `1000（根节点）× 1000（中间节点）× 1000（叶子节点）= 10 亿` 条数据；  
   - 查询时仅需 3 次磁盘 IO（根节点→中间节点→叶子节点），远少于二叉树的 `log2(10 亿) ≈ 30` 次 IO，大幅降低延迟。  

2. **叶子节点有序且相连，高效支持范围查询**：  
   B+ 树的所有叶子节点按键值有序排列，且通过**双向链表**首尾连接：  
   - 单值查询：定位到目标叶子节点即可获取数据；  
   - 范围查询（如 `WHERE id > 100 AND id < 200`）：只需定位到起始叶子节点（id=101），沿双向链表遍历至结束节点（id=199），无需回溯上层节点，效率远高于 B 树。  

3. **非叶子节点仅存索引，叶子节点存完整数据**：  
   - 非叶子节点仅存储“键值 + 子节点指针”，不存实际数据，单个节点可容纳更多键值，进一步降低树高；  
   - InnoDB 聚簇索引的叶子节点直接存储完整数据行，查询命中时无需额外访问其他结构（二级索引需回表，但可通过索引覆盖优化）。  

4. **查询效率稳定**：  
   所有查询最终都需访问叶子节点（无论单值还是范围查询），查询时间复杂度固定为 `O(logN)`，避免 B 树因“非叶子节点存数据”导致的效率波动（B 树可能在非叶子节点命中，也可能在叶子节点命中，耗时不一致）。  


### 20. B 树除了不能满足范围查找的需求外还有哪些缺点呢？  
与 B+ 树相比，B 树的其他核心缺点集中在**查询稳定性、空间利用率、维护成本**三个方面：  

1. **查询效率不稳定**：  
   B 树的非叶子节点和叶子节点都可能存储实际数据：  
   - 若查询命中非叶子节点（如主键查询），可直接返回数据，耗时短；  
   - 若查询命中叶子节点（如范围查询的边缘数据），需遍历多层节点，耗时长；  
   导致相同查询的耗时波动大，不适合对延迟敏感的场景（如金融交易、实时推荐）。  

2. **空间利用率低，树高更高**：  
   B 树的非叶子节点需存储“键值 + 子节点指针 + 数据”，而 B+ 树非叶子节点仅存“键值 + 子节点指针”。  
   - 相同磁盘页大小下，B 树单个节点可容纳的键值数量远少于 B+ 树，导致树高更高（如存储 10 亿数据，B 树可能需要 4-5 层，B+ 树仅需 3 层）；  
   - 树高更高意味着查询时的磁盘 IO 次数更多，延迟更高。  

3. **索引维护成本高**：  
   插入或删除数据时，B 树可能引发非叶子节点的分裂或合并（因非叶子节点存数据，数据变动会直接影响节点大小）：  
   - 分裂/合并操作需移动更多数据（非叶子节点的键值 + 数据），比 B+ 树（仅移动键值）的开销更大；  
   - 频繁的分裂/合并可能导致树结构频繁调整，影响查询稳定性。  

4. **不适合大量随机读写**：  
   B 树的数据分散在整棵树（非叶子+叶子节点），随机访问不同数据时，磁盘磁头需在不同层级的节点间频繁移动，寻道时间长；而 B+ 树的数据集中在叶子节点，磁头移动范围更小，随机读写效率更高。  

因此，MySQL、PostgreSQL 等主流关系型数据库均选择 B+ 树作为索引结构，仅少数非关系型数据库（如 MongoDB 早期版本）因特定场景需求使用 B 树。
