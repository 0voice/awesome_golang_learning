## 字节跳动
### 1. Golang 中函数是值传递还是引用传递？
Golang 中函数参数传递只有值传递。基本类型传递值的拷贝，引用类型（切片、map 等）传递引用本身的拷贝，函数内通过引用修改底层数据会影响外部，但引用本身的修改不影响外部。


### 2. 如何安全读写共享变量？
- 使用互斥锁（sync.Mutex/sync.RWMutex）控制访问；
- 通过 Channel 传递数据，将共享变量访问串行化；
- 对简单类型使用 sync/atomic 原子操作；
- 避免共享状态，采用不可变数据结构。


### 3. 缓冲、无缓冲 channel 的区别？
- 无缓冲 channel：发送和接收操作必须同步，发送方阻塞直到接收方接收，接收方阻塞直到有数据发送；
- 缓冲 channel：有固定容量，发送方在缓冲区满时阻塞，接收方在缓冲区空时阻塞，可实现异步通信。


### 4. 如何用 channel、sync.WaitGroup 实现并发控制？
- channel：通过带缓冲 channel 限制并发数（缓冲大小为最大并发量），每个任务开始前获取 token，结束后释放；
- sync.WaitGroup：通过 Add() 设定任务数，每个任务完成调用 Done()，主协程用 Wait() 阻塞等待所有任务完成。


### 5. 如何用 ctx 控制超时时间？
使用 context.WithTimeout() 创建带超时的上下文，将其传入需要控制的函数，通过 select 监听 ctx.Done() 通道，当超时或上下文被取消时，退出操作。


### 6. 如何实现 deepcopy？
- 对于简单结构，可手动递归复制所有字段；
- 借助 encoding/gob、json 等序列化库，先序列化再反序列化生成新对象；
- 使用第三方库（如 github.com/mohae/deepcopy）处理复杂类型。


### 7. 如何实现单元测试与 benchmark？
- 单元测试：创建以 `_test.go` 结尾的文件，编写以 `Test` 开头的函数，使用 testing.T 断言结果；
- benchmark：编写以 `Benchmark` 开头的函数，使用 testing.B 循环执行测试逻辑，通过 `go test -bench=.` 运行。


### 8. 线上性能分析有哪些方式？
- 使用 pprof 采集并分析 CPU、内存、Goroutine 等数据；
- 通过 trace 工具记录程序执行轨迹，分析调度、GC 等行为；
- 结合监控系统（如 Prometheus）收集关键指标，排查性能瓶颈；
- 日志埋点记录耗时操作，定位慢函数。


### 9. timer.Ticker 是否精准？
不绝对精准。Ticker 依赖系统调度和当前 Goroutine 执行情况，可能因 CPU 繁忙、GC 等延迟触发，适用于对精度要求不高的场景，高精度计时需结合系统级时钟。


### 10. 请解释 Goroutine 中的调度器是如何工作的？
Goroutine 调度基于 GMP 模型：
- G（Goroutine）是待执行的协程，M（Machine）是系统线程，P（Processor）是逻辑处理器；
- P 维护本地 Goroutine 队列，M 绑定 P 后从队列中获取 G 执行；
- 当 G 阻塞时，P 释放 M 并绑定新 M 继续执行其他 G；
- 空闲 P 会通过 Work-Stealing 从其他 P 或全局队列获取 G，平衡负载。

### 11. 如何排查和解决MySQL中的慢查询问题？
- **排查**：开启慢查询日志（`slow_query_log=1`），设置阈值（`long_query_time`），通过`mysqldumpslow`或`pt-query-digest`分析日志，定位执行时间长的SQL；使用`EXPLAIN`分析SQL执行计划，查看是否走索引、扫描行数等。
- **解决**：优化索引（添加缺失索引、删除冗余索引）；改写SQL（避免全表扫描、子查询优化、分页优化）；调整数据库参数（如`innodb_buffer_pool_size`）；分库分表或读写分离减轻压力。


### 12. MySQL是如何保证其事务的ACID特性的？
- **原子性（Atomicity）**：通过 undo log 实现，事务失败时回滚到执行前状态。
- **一致性（Consistency）**：由原子性、隔离性、持久性共同保证，同时依赖业务逻辑和约束（如主键、外键）。
- **隔离性（Isolation）**：通过锁机制（行锁、表锁）和 MVCC（多版本并发控制）实现不同隔离级别。
- **持久性（Durability）**：通过 redo log 实现，事务提交后数据持久化到磁盘，即使宕机也能恢复。


### 13. MySQL的事务隔离级别有哪些？
- **读未提交（Read Uncommitted）**：允许读取未提交的事务数据，可能出现脏读、不可重复读、幻读。
- **读已提交（Read Committed）**：只能读取已提交的数据，解决脏读，仍可能出现不可重复读、幻读。
- **可重复读（Repeatable Read）**：事务期间多次读取数据一致，解决脏读、不可重复读，InnoDB通过MVCC解决幻读（默认级别）。
- **串行化（Serializable）**：最高隔离级别，事务串行执行，避免所有并发问题，但性能最差。


### 14. 解释一下什么是脏读
脏读是指一个事务读取到另一个未提交事务修改的数据。例如：事务A修改了一条记录但未提交，事务B读取到该修改后，事务A因错误回滚，导致事务B读取到的数据是“无效”的脏数据。


### 15. MySQL底层存储数据的结构是什么？
MySQL的存储引擎不同，底层结构不同：
- **InnoDB**：使用B+树作为索引和数据存储结构，数据按主键顺序存储在B+树叶子节点（聚簇索引），辅助索引叶子节点存储主键值。
- **MyISAM**：索引和数据分离，索引为B+树（叶子节点存数据地址），数据存放在独立文件中。
- 其他引擎（如Memory）可能使用哈希表等结构。


### 16. Redis为什么这么快？
- **基于内存**：数据存储在内存中，避免磁盘IO开销。
- **单线程模型**：避免多线程切换和锁竞争（IO多路复用处理并发请求）。
- **高效数据结构**：针对不同场景优化（如跳表、压缩列表）。
- **精简协议**：使用简单的RESP协议，减少网络传输开销。
- **持久化优化**：异步执行RDB/AOF持久化，不阻塞主线程。


### 17. Redis有哪些常用的数据结构？你自己在项目中用过哪些？
- 常用数据结构：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、ZSet（有序集合）、Bitmap（位图）、HyperLogLog、Geospatial（地理空间）。
- 项目中常用：String存储热点数据/计数器，Hash存储对象属性，List实现消息队列，Set实现去重，ZSet实现排行榜。


### 18. ZSet的底层数据结构是什么？
ZSet底层同时使用**跳表（skiplist）** 和**哈希表（hash）**：
- 跳表：按分数排序存储元素，支持范围查询和排序操作，平均复杂度O(log n)。
- 哈希表：映射元素值到分数，支持O(1)复杂度的分值查询、添加、删除。
两种结构共享元素数据，兼顾查询效率和排序需求。


### 19. Redis如何实现持久化？AOF和RDB有什么区别？
- **持久化方式**：
  - RDB：定时将内存中数据生成快照（二进制文件）写入磁盘。
  - AOF：记录所有写操作命令到日志文件，重启时重新执行命令恢复数据。
- **区别**：
  - 存储内容：RDB存数据快照，AOF存命令日志。
  - 性能：RDB写入快（阻塞或子进程执行），AOF可能因频繁写入影响性能（可配置刷盘策略）。
  - 恢复速度：RDB恢复快，AOF恢复慢（需重放命令）。
  - 数据安全性：AOF更安全（可每秒刷盘），RDB可能丢失最近数据。

### 20. 线程和进程的关系
- 进程是操作系统资源分配的基本单位，拥有独立内存、文件描述符等；线程是调度的基本单位，共享所属进程的资源，仅拥有独立栈和寄存器。
- 一个进程可包含多个线程，线程依赖进程存在；进程崩溃不影响其他进程，单个线程崩溃可能导致整个进程崩溃。


### 21. 线程之间、进程之间的同步机制
- **线程间同步**：互斥锁（pthread_mutex_t）、条件变量（pthread_cond_t）、信号量、读写锁、线程局部存储（TLS）。
- **进程间同步**：管道、消息队列、共享内存（需配合互斥锁/信号量）、信号、Socket、文件锁。


### 22. 子网掩码的作用
- 用于划分IP地址的网络部分和主机部分，判断两个IP是否在同一子网。
- 通过与IP地址进行“按位与”运算，得到网络地址；剩余位为主机地址，限制子网内可容纳的主机数量。


### 23. IP报文的头部有哪些
- 固定头部（20字节）：版本号、头部长度、服务类型、总长度、标识、标志、片偏移、生存时间（TTL）、协议号、头部校验和、源IP、目的IP。
- 可选头部（0-40字节）：如源路由、记录路由等，按需添加。


### 24. TCP怎么就可靠了
- 基于三次握手建立连接、四次挥手关闭连接，确保连接状态可控；
- 采用序列号和确认号，保证数据有序接收、不丢失（超时重传丢失报文）；
- 滑动窗口机制控制发送速率，避免数据拥塞；
- 校验和验证数据完整性，丢弃损坏报文并触发重传。


### 25. 怎么实现事务的原子性
- 数据库层面：通过 undo log（回滚日志）实现，事务执行时记录操作反向逻辑，若失败则执行回滚日志，恢复到事务前状态；
- 应用层面：采用“补偿机制”，事务失败时执行反向操作（如转账失败则撤销扣款/收款）。


### 26. 说说最左匹配原则
- 是MySQL中B+树索引的查询规则：索引匹配需从索引最左侧字段开始，不跳过中间字段。
- 若查询条件不包含索引最左字段，或跳过中间字段，索引无法生效；例如索引（a,b,c），查询条件含a可匹配，含b/c或a/c则无法完全利用索引。


### 27. redis字符串底层原理
- 底层基于`SDS`（简单动态字符串）结构，包含len（已用长度）、free（空闲长度）、buf（字节数组）。
- 支持动态扩容（小于1MB时翻倍，大于1MB时每次增1MB），避免内存浪费；二进制安全，可存储任意字节数据（如图片、视频）。


### 28. 字符串如何设置过期时间
- Redis中通过`EXPIRE key seconds`（秒级）、`PEXPIRE key milliseconds`（毫秒级）设置过期时间；
- 也可在设置字符串时直接指定过期时间，如`SET key value EX seconds`或`SET key value PX milliseconds`；
- 过期键通过惰性删除、定期删除、内存淘汰机制清理。


### 29. 讲下defer关键字
- Go语言中用于延迟执行函数调用，在当前函数返回前（无论正常返回还是panic）执行；
- 多个defer按“后进先出”顺序执行，常用于释放资源（如关闭文件、解锁）、记录日志；
- 需注意循环中defer会延迟到循环结束后执行，可能导致资源泄漏；延迟函数的参数在定义时求值。


### 30. 讲一下panic
- Go语言中表示运行时错误（如数组越界、空指针引用），会中断当前 Goroutine 执行，触发defer函数，若未被recover捕获，程序会崩溃；
- 可通过`panic("error msg")`手动触发；`recover()`需在defer中调用，用于捕获panic，恢复程序执行，返回panic信息。


### 31. go并发的实现方式
- 基于Goroutine（轻量级协程），通过`go 函数名`启动；
- 用Channel实现Goroutine间通信与同步；
- 借助`sync`包工具（WaitGroup、Mutex、RWMutex等）控制并发；
- 通过`context`包传递取消信号、超时时间，管理并发任务生命周期。

### 32. 为什么golang适合io密集型，为什么并发能力强
- **适合IO密集型**：IO操作（如网络请求、磁盘读写）会导致阻塞，Golang的Goroutine在阻塞时会释放底层线程（M），让其他Goroutine继续执行，避免CPU闲置；且Goroutine轻量（初始栈2KB），可创建大量协程处理并发IO任务。
- **并发能力强**：基于GMP模型的用户态调度，减少内核线程切换开销；Work-Stealing机制平衡负载；抢占式调度防止单个Goroutine独占资源；原生Channel和sync包简化并发控制，降低开发成本。


### 33. 给一个golang适用于io密集型能力强的例子，里面各个协程之间是怎么调度的
**例子**：用1000个Goroutine并发发起HTTP请求。

**调度过程**：
1. 启动1000个Goroutine（G），每个负责一个HTTP请求，初始被放入P的本地队列。
2. P绑定M后，从本地队列取出G执行，当G发起HTTP请求（IO操作）时，G进入阻塞状态，M释放P。
3. P重新绑定其他空闲M，继续从队列取出下一个G执行，实现CPU高效利用。
4. 当某个HTTP请求完成（IO就绪），阻塞的G被唤醒，放入P的本地队列或全局队列，等待M调度执行后续逻辑。
5. 若某个P的本地队列空，会通过Work-Stealing从其他P偷取G，平衡各P的负载。

整个过程中，IO阻塞时G不占用线程，大量Goroutine可高效处理并发请求，体现IO密集型场景优势。
