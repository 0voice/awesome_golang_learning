## 联想
### 1. 进程和线程的定义和区别  
#### 定义  
- **进程**：操作系统资源分配的基本单位，是一个正在运行的程序实例，拥有独立的内存空间、文件描述符、进程ID等系统资源。  
- **线程**：进程内的执行单元，是CPU调度的基本单位，共享所属进程的资源，多个线程协同完成进程的任务。  

#### 区别  
| 维度         | 进程                     | 线程                     |  
|--------------|--------------------------|--------------------------|  
| 资源分配     | 独立资源（内存、文件描述符等） | 共享进程资源             |  
| 独立性       | 高（一个进程崩溃不影响其他进程） | 低（线程崩溃可能导致进程崩溃） |  
| 切换开销     | 大（需切换内存空间、页表等） | 小（仅需切换寄存器、栈等） |  
| 通信方式     | 复杂（需IPC机制）         | 简单（直接访问共享内存） |  
| 数量上限     | 少（受系统资源限制）     | 多（一个进程可包含数千线程） |  


### 2. Golang的线程模型和操作系统的内核线程模型的联系  
Go的线程模型（GMP模型）是**用户态线程（goroutine）与内核线程（OS thread）的映射管理模型**，与操作系统内核线程模型的联系如下：  
- **内核线程是基础**：Go的M（Machine）本质是操作系统内核线程，是实际执行代码的载体，由操作系统调度器调度到CPU核心运行。  
- **用户态调度层**：Go通过P（Processor）和G（Goroutine）在用户态实现了一层调度逻辑，将goroutine（轻量级用户线程）映射到M（内核线程）上执行，避免了直接依赖内核调度的高开销。  
- **协作与内核调度结合**：当goroutine执行系统调用（如IO操作）时，M会与P解绑，此时内核会调度其他M执行P上的剩余goroutine；系统调用完成后，goroutine重新进入调度队列，由Go runtime分配M继续执行。  
- 简言之：Go的线程模型是**基于内核线程的用户态调度抽象**，既利用了内核线程的CPU执行能力，又通过用户态调度降低了线程切换开销。  


### 3. 一个进程中的多个线程共享哪些资源，哪些资源是线程独立拥有的  
#### 共享资源  
- **内存空间**：进程的堆内存、全局变量、静态变量等（所有线程可读写）。  
- **文件描述符表**：打开的文件、网络连接（socket）等，线程可共享使用。  
- **信号处理**：进程的信号处理方式（如信号处理器函数）对所有线程生效。  
- **进程级信息**：进程ID、环境变量、工作目录等。  
- **同步原语**：进程内的锁（如mutex）、条件变量等，用于线程间同步。  

#### 线程独立拥有的资源  
- **栈空间**：每个线程有独立的栈（用于函数调用、局部变量存储），默认大小为1-8MB（不同系统不同）。  
- **寄存器状态**：包括程序计数器（PC）、栈指针（SP）等，记录线程当前执行位置。  
- **线程ID（TID）**：标识线程的唯一ID（内核分配）。  
- **错误码（errno）**：线程执行系统调用后的错误状态，独立存储。  
- **信号掩码**：线程可设置自己的信号屏蔽集（哪些信号不响应）。  


### 4. 哪些场景导致进程切换开销变小，线程切换开销变大  
#### 进程切换开销变小的场景  
- **进程处于相同内存空间**：如使用共享内存的进程，切换时无需大量修改页表（内存映射关系不变），减少TLB（地址转换缓存）失效开销。  
- **进程长时间阻塞**：如进程因IO阻塞（未占用CPU），切换时无需保存大量CPU状态（仅需更新进程控制块PCB）。  
- **内核优化**：现代操作系统通过优化进程调度算法（如CFS）、减少上下文切换时的资源拷贝，降低切换开销。  

#### 线程切换开销变大的场景  
- **线程私有数据量大**：线程栈空间过大（如几MB），切换时需保存/恢复大量栈数据，增加内存操作开销。  
- **频繁的内核态切换**：线程频繁执行系统调用（进入内核态），导致内核调度器频繁介入，增加线程切换的内核开销。  
- **缓存失效严重**：不同线程访问的数据差异大，切换时CPU缓存（L1/L2）命中率低，需重新加载数据，表现为切换开销变大。  
- **锁竞争激烈**：线程因争夺锁频繁阻塞/唤醒，触发大量上下文切换，叠加锁操作本身的开销。  


### 5. 进程之间通信（IPC）的方式  
1. **管道（Pipe）**：  
   - 半双工通信，用于父子进程或兄弟进程间，数据单向流动（如`|`命令符）。  
   - 扩展：命名管道（FIFO）支持无亲缘关系的进程通信。  

2. **消息队列**：  
   - 内核中的消息链表，进程可按类型发送/接收消息，避免管道的流式数据无边界问题。  

3. **共享内存**：  
   - 多个进程映射同一块物理内存，直接读写内存实现通信，效率最高（无内核中转）。  
   - 需配合同步机制（如信号量）避免数据竞争。  

4. **信号量（Semaphore）**：  
   - 用于进程间同步（如控制共享资源的访问次数），本质是计数器，非直接传递数据。  

5. **信号（Signal）**：  
   - 进程间传递异步事件（如`kill`命令发送信号），用于通知异常（如终止、暂停）。  

6. **套接字（Socket）**：  
   - 用于跨网络或本地进程通信（如`AF_UNIX`域套接字用于本地进程，`AF_INET`用于网络）。  


### 6. 线程池shutdown时，正在进行网络I/O的线程的socket状态分析  
线程池调用`shutdown`后，通常会停止接收新任务，并等待正在执行的任务完成（`shutdown()`）或强制终止所有任务（`shutdownNow()`）。对于正在进行网络I/O的线程，其socket状态取决于具体实现和操作阶段：  

1. **若线程正在执行阻塞的读/写操作（如`recv`/`send`）**：  
   - **`shutdown()`（优雅关闭）**：线程池等待任务完成，socket会继续完成当前I/O操作，直到数据传输完毕或发生错误（如对方关闭连接），最终socket可能处于`CLOSED`状态。  
   - **`shutdownNow()`（强制关闭）**：线程被中断（如Java的`interrupt()`），但**阻塞的系统调用（如`recv`）不会被直接中断**，socket会继续阻塞，直到超时或外部事件（如对方关闭）触发返回，最终可能处于`CLOSED`或`TIME_WAIT`状态。  

2. **若线程正在执行非阻塞I/O（如使用`epoll`/`select`）**：  
   - 线程池可通过唤醒事件循环（如设置唤醒fd）中断I/O等待，线程退出前可能主动关闭socket，使其处于`CLOSED`状态。  

3. **若线程未正确关闭socket**：  
   - 线程被强制终止后，若未显式调用`close(socket)`，socket会成为**孤儿句柄**，直到进程退出后由内核自动关闭（此时可能处于`TIME_WAIT`或`CLOSED`状态）。  

4. **特殊情况**：  
   - 若socket设置了`SO_LINGER`选项且超时为0，强制关闭时会发送`RST`包，socket直接进入`CLOSED`状态（无`TIME_WAIT`）。  


### 7. TCP保证可靠传输的机制  
1. **校验和**：每个TCP报文段包含校验和字段，接收端通过校验和检测数据是否在传输中损坏，若损坏则丢弃并要求重传。  

2. **序号与确认机制**：  
   - 发送端为每个字节分配唯一序号（Sequence Number），确保数据按序传输。  
   - 接收端收到数据后返回确认序号（Acknowledgment Number），表示已正确接收至该序号的数据。  

3. **超时重传**：  
   - 发送端发送数据后启动计时器，若超时未收到确认，则重传该数据。  
   - 超时时间基于往返时间（RTT）动态调整，避免不必要的重传。  

4. **滑动窗口机制**：  
   - 接收端通过窗口大小（Window Size）告知发送端自己的接收缓冲区容量，控制发送速率，避免缓冲区溢出。  
   - 未被确认的数据暂存于发送窗口，超时则重传。  

5. **拥塞控制**：  
   - 发送端通过慢启动、拥塞避免、快速重传、快速恢复等算法，根据网络拥塞程度动态调整发送速率，避免网络过载导致数据丢失。  

### 8. 常用的数据结构  
在 Go 中，常用的数据结构包括：  
- **基础类型**：数组（Array）、切片（Slice）、字符串（String）。  
- **容器类型**：映射（Map）、结构体（Struct）、链表（通过 `container/list` 实现）。  
- **同步类型**：通道（Channel）、`sync.Map`（并发安全 map）。  
- **其他**：栈（通过切片模拟，`append` 入栈、`len-1` 出栈）、队列（通过切片或链表实现）。  


### 9. Slice、Map、Struct 的详解  
#### Slice（切片）  
- **定义**：动态数组，由指针（指向底层数组）、长度（`len`，当前元素数）、容量（`cap`，底层数组大小）组成。  
- **特性**：  
  - 动态扩容：当 `len == cap` 时，新增元素会触发扩容（容量翻倍，小切片扩至 1024 后每次扩 1.25 倍）。  
  - 引用类型：修改切片会影响底层数组，复制切片时仅复制指针（浅拷贝）。  
- **示例**：  
  ```go
  s := []int{1, 2, 3}       // 初始化
  s = append(s, 4)          // 追加元素
  sub := s[1:3]             // 切片（左闭右开，sub 指向 s 的底层数组）
  ```  

#### Map（映射）  
- **定义**：键值对集合，底层通过哈希表 + 链表实现（链地址法解决哈希冲突）。  
- **特性**：  
  - 无序性：遍历顺序不固定（Go 1.12+ 随机化遍历顺序）。  
  - 引用类型：赋值或传递时仅复制指针。  
  - 非并发安全：多协程读写会触发 panic。  
- **示例**：  
  ```go
  m := make(map[string]int)  // 初始化
  m["a"] = 1                 // 设置键值对
  v, ok := m["b"]            // 查询（ok 判断键是否存在）
  delete(m, "a")             // 删除键
  ```  

#### Struct（结构体）  
- **定义**：自定义复合类型，包含多个字段（不同类型），用于封装数据。  
- **特性**：  
  - 值类型：赋值或传递时会拷贝所有字段（深拷贝）。  
  - 支持方法绑定：可给结构体定义方法，实现面向对象风格的逻辑。  
  - 可嵌套：结构体字段可是另一个结构体，实现复杂数据模型。  
- **示例**：  
  ```go
  type User struct {
      Name string
      Age  int
  }
  u := User{Name: "Alice", Age: 20}  // 初始化
  func (u User) Greet() string {      // 绑定方法
      return "Hello, " + u.Name
  }
  ```  


### 10. Interface（接口）的用途  
Go 的接口是**方法签名的集合**，用于定义行为规范，核心用途：  
1. **多态**：不同类型实现同一接口后，可通过接口变量统一调用，无需关心具体类型。  
   ```go
   type Shape interface { Area() float64 }
   type Circle struct { Radius float64 }
   func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius }
   
   var s Shape = Circle{Radius: 2}
   fmt.Println(s.Area())  // 多态调用，无需知道 s 是 Circle
   ```  

2. **解耦**：接口定义与实现分离，降低模块间依赖（如依赖注入）。  

3. **适配**：不同类型通过实现接口，可被同一套逻辑处理（如 `io.Reader`/`io.Writer` 适配各种输入输出源）。  

4. **空接口（`interface{}`）**：可接收任意类型数据，用于泛型场景（Go 1.18 前替代泛型）。  


### 11. Go 的内存分配机制（以切片和 map 为例）  
Go 的内存分配基于 **TCMalloc（线程缓存分配器）** 思想，通过三级缓存（`mcache`、`mcentral`、`mheap`）管理内存，避免频繁系统调用：  

1. **内存层级**：  
   - **`mcache`**：每个 P（逻辑处理器）私有缓存，存储小对象（< 32KB），分配无需锁。  
   - **`mcentral`**：全局缓存，按对象大小分类，`mcache` 不足时从中获取，需加锁。  
   - **`mheap`**：管理大对象（≥ 32KB）和向操作系统申请的内存（通过 `mmap`）。  

2. **切片（Slice）分配**：  
   - 底层数组内存从堆分配（小切片从 `mcache`，大切片从 `mheap`）。  
   - 初始化时根据容量申请内存（如 `make([]int, 0, 10)` 申请 40B 内存，因 `int` 占 8B）。  
   - 扩容时若新容量 ≤ 1024，直接翻倍；否则扩至 1.25 倍，并复制旧数据到新内存。  

3. **Map 分配**：  
   - 初始化时（`make(map[K]V, n)`），根据预估大小分配哈希表（桶数组），每个桶可存 8 个键值对。  
   - 桶内存从堆分配，小 map 用 `mcache`，大 map 用 `mheap`。  
   - 当负载因子（元素数/桶数）超过 6.5 时，触发扩容（桶数翻倍，重新哈希）。  


### 12. Go 的 GC 机制及触发条件  
#### GC 工作原理（并发标记-清除算法）  
1. **标记阶段**：  
   - **初始标记（STW）**：暂停所有协程，标记根对象（全局变量、栈对象），耗时极短（微秒级）。  
   - **并发标记**：恢复协程，后台线程并发遍历对象引用，标记可达对象（使用三色标记法：白色未标记、灰色待处理、黑色已标记）。  
   - **重新标记（STW）**：再次短暂暂停，处理并发标记期间的引用变化（如写屏障记录的修改）。  

2. **清除阶段**：并发回收未标记的白色对象（不可达），无需 STW。  

#### 触发条件  
- **堆内存达到阈值**：当新分配内存占已使用内存的比例超过阈值（默认 100%，即堆翻倍时触发）。  
- **定时触发**：即使内存增长缓慢，也会定期（约 2 分钟）触发一次，避免内存泄漏累积。  
- **手动触发**：通过 `runtime.GC()` 强制触发（一般用于测试）。  


### 13. Goroutine 的应用场景  
Goroutine 是轻量级协程，适合以下场景：  
1. **并发任务处理**：如批量请求接口、并行计算（利用多核 CPU）。  
2. **IO 密集型操作**：网络请求（HTTP、RPC）、文件读写、数据库查询等（IO 等待时释放 CPU 给其他协程）。  
3. **实时服务**：如 Web 服务器（每个请求对应一个协程）、消息队列消费者（多协程并发消费）。  
4. **定时任务**：结合 `time.Ticker` 或 `time.AfterFunc` 实现周期性任务。  
5. **异步处理**：非核心流程（如日志上报、数据统计）异步执行，不阻塞主逻辑。  


### 14. 主协程等待其他协程完成的方法  
1. **`sync.WaitGroup`**（最常用）：  
   ```go
   var wg sync.WaitGroup
   wg.Add(2)  // 注册 2 个协程
   
   go func() {
       defer wg.Done()  // 完成后计数器减 1
       // 任务 1
   }()
   
   go func() {
       defer wg.Done()
       // 任务 2
   }()
   
   wg.Wait()  // 等待所有协程完成
   ```  

2. **Channel 阻塞**：  
   ```go
   ch := make(chan struct{}, 2)  // 缓冲大小等于协程数
   
   go func() {
       // 任务 1
       ch <- struct{}{}  // 发送完成信号
   }()
   
   go func() {
       // 任务 2
       ch <- struct{}{}
   }()
   
   <-ch  // 等待两个信号
   <-ch
   ```  

3. **`context.Context`**（带超时控制）：  
   ```go
   ctx, cancel := context.WithCancel(context.Background())
   var done int
   total := 2
   
   go func() {
       // 任务 1
       done++
       if done == total { cancel() }
   }()
   
   go func() {
       // 任务 2
       done++
       if done == total { cancel() }
   }()
   
   <-ctx.Done()  // 等待取消信号
   ```  


### 15. 协程（Goroutine）的工作机制  
Go 协程基于 **GMP 模型** 调度，核心组件：  
- **G（Goroutine）**：协程本身，包含栈、程序计数器、状态等。  
- **M（Machine）**：操作系统内核线程，执行 G 的实际载体。  
- **P（Processor）**：逻辑处理器，绑定 M 并管理 G 队列（本地队列 + 全局队列）。  

#### 调度流程：  
1. 协程创建后，被放入 P 的本地队列或全局队列。  
2. M 绑定 P 后，从 P 的本地队列取 G 执行；若本地队列为空，从全局队列或其他 P 的队列“窃取”G（工作窃取机制）。  
3. 当 G 执行阻塞操作（如系统调用、channel 操作）：  
   - 若为**可阻塞操作**（如 `time.Sleep`），G 被放入等待队列，M 继续执行其他 G。  
   - 若为**系统调用**，M 与 P 解绑，P 绑定新 M 执行剩余 G；系统调用完成后，G 重新进入队列等待调度。  


### 16. Channel 的使用场景  
Channel 是协程间通信的核心机制，常用场景：  
1. **数据传递**：协程间发送/接收数据（如生产者-消费者模型）。  
   ```go
   ch := make(chan int)
   go func() { ch <- 42 }()  // 生产者
   fmt.Println(<-ch)         // 消费者接收 42
   ```  

2. **同步控制**：无缓冲 channel 用于协程同步（如“握手”）。  
   ```go
   ready := make(chan struct{})
   go func() {
       // 准备工作
       close(ready)  // 通知主协程准备完成
   }()
   <-ready  // 主协程等待信号
   ```  

3. **限制并发**：带缓冲 channel 作为信号量（如限制 5 个并发）。  
   ```go
   sem := make(chan struct{}, 5)
   for i := 0; i < 10; i++ {
       sem <- struct{}{}  // 获取信号量
       go func() {
           defer func() { <-sem }()  // 释放信号量
           // 并发任务
       }()
   }
   ```  

4. **事件通知**：通过 `close(ch)` 广播事件（所有等待的协程被唤醒）。  


### 17. Defer 的执行顺序及与 return 的关系  
- **执行顺序**：`defer` 语句按“后进先出（LIFO）”执行（最后声明的 `defer` 最先执行）。  
  ```go
  func main() {
      defer fmt.Println(1)
      defer fmt.Println(2)
      defer fmt.Println(3)  // 输出：3 2 1
  }
  ```  

- **与 return 的关系**：`defer` 在 `return` 之后、函数真正退出之前执行。  
  - `return` 先将结果赋值给返回变量，再执行 `defer`，最后函数退出。  
  - 若返回值是命名变量，`defer` 可修改该变量（影响最终返回值）。  
  ```go
  func f() (x int) {
      defer func() { x++ }()  // 修改命名返回值
      return 1  // 实际返回 2
  }
  ```  


### 18. 常用锁及区别  
Go 中常用的锁来自 `sync` 包，核心区别：  

| 锁类型          | 特点                                                                 | 适用场景                     |  
|-----------------|----------------------------------------------------------------------|------------------------------|  
| `sync.Mutex`    | 互斥锁，同一时间仅允许一个协程访问临界区（`Lock()`/`Unlock()`）。      | 读写频率相近，或写操作频繁。 |  
| `sync.RWMutex`  | 读写锁，允许多个读协程并发（`RLock()`/`RUnlock()`），写协程独占（`Lock()`/`Unlock()`）。 | 读多写少（如缓存查询）。     |  
| `sync.Once`     | 确保函数仅执行一次（`Do(func())`），线程安全。                        | 初始化操作（如单例模式）。   |  
| `sync.Cond`     | 条件变量，通过 `Wait()` 等待条件，`Signal()`/`Broadcast()` 唤醒协程。 | 复杂同步场景（如生产者-消费者队列满/空时等待）。 |  


### 19. Go 的原子操作实现  
Go 通过 `sync/atomic` 包提供原子操作，底层基于 CPU 指令（如 `LOCK` 前缀），确保操作不可中断：  

- **支持类型**：`int32`、`int64`、`uint32`、`uint64`、`uintptr`、`Pointer`（指针）。  
- **常用操作**：  
  - `Add`：原子增减（如 `atomic.AddInt32(&x, 1)`）。  
  - `Load`/`Store`：原子读取/写入（如 `atomic.LoadInt64(&x)`）。  
  - `CompareAndSwap`（CAS）：比较并交换（如 `atomic.CompareAndSwapInt32(&x, 0, 1)`）。  

- **优势**：比锁开销小，适合简单计数器、标志位等场景。  


### 20. Map 的并发安全性及并发访问后果  
- **非并发安全**：Go 的原生 `map` 不支持多协程并发读写，会触发运行时 panic（错误信息：`concurrent map writes`）。  

- **并发访问后果**：  
  - 写-写冲突：两个协程同时写入，可能导致哈希表结构损坏（如链表断裂）。  
  - 读-写冲突：读取时恰逢扩容或修改，可能读取到脏数据或触发 panic。  


### 21. 除加锁外，并发安全访问变量的方式  
1. **Channel 通信**：通过 channel 传递数据，避免直接共享变量（“不要通过共享内存通信，而要通过通信共享内存”）。  
   ```go
   ch := make(chan int)
   go func() { ch <- 1 }()  // 发送更新后的值
   x := <-ch  // 接收值，避免直接读写 x
   ```  

2. **原子操作**：使用 `sync/atomic` 包（适合简单类型，如计数器）。  

3. **`sync.Map`**：Go 1.9+ 提供的并发安全 map，内置锁机制，适合读多写少场景。  

4. **无状态设计**：变量仅由单个协程读写，其他协程通过 channel 发送请求，该协程处理后返回结果（序列化访问）。  

5. **不可变数据**：变量初始化后不再修改，多协程只读访问（天然安全）。
6. **重复数据处理**：  
   - 接收端通过序号识别重复数据（已接收过的序号），直接丢弃，避免数据重复。  

7. **连接管理**：  
   - 通过三次握手建立连接、四次挥手关闭连接，确保双方状态同步，避免数据在连接未就绪或已关闭时传输。
  

### 22. 开发中常用的lib有哪些  
开发中常用的库可分为**标准库**和**第三方库**，核心场景覆盖Web开发、数据处理、配置管理等：  

#### 1. 标准库（Go 内置，无需额外安装）  
- **`net/http`**：构建HTTP服务器与客户端，如创建API接口、发送HTTP请求。  
- **`encoding/json`**：JSON数据的序列化与反序列化，处理接口请求/响应数据。  
- **`database/sql`**：数据库操作基础库，配合MySQL、PostgreSQL等驱动实现SQL查询。  
- **`sync`/`sync/atomic`**：并发控制工具，如锁（`Mutex`）、原子操作（`AddInt32`），保证协程安全。  
- **`time`**：时间处理，如定时器（`Ticker`）、时间格式化、时区转换。  

#### 2. 第三方库（需通过 `go get` 安装）  
- **Web框架**：`gin`（轻量级高性能，支持中间件、路由分组）、`echo`（极简API设计，适合微服务）。  
- **ORM工具**：`gorm`（支持多数据库，自动生成SQL，简化CRUD）、`xorm`（轻量ORM，性能优异）。  
- **配置管理**：`viper`（读取JSON/YAML/环境变量，动态更新配置）、`dotenv`（加载`.env`文件）。  
- **身份认证**：`jwt-go`（生成/验证JWT令牌，实现接口授权）、`casbin`（权限控制框架）。  
- **工具类**：`go-playground/validator`（结构体字段校验）、`zap`（高性能日志库）。  


### 23. go-zero 你用在了什么项目中，解决了什么问题  
#### 1. 应用项目场景  
主要用于**高并发微服务项目**，例如：  
- 电商系统：订单服务（处理下单、支付回调）、商品服务（库存管理、价格查询）、用户服务（登录、权限）。  
- 后台管理系统：数据统计服务（实时指标计算）、消息推送服务（短信/邮件分发）。  

#### 2. 解决的核心问题  
- **快速搭建微服务**：通过 `goctl` 代码生成工具，自动生成API接口、数据模型、配置文件，减少重复编码（如定义 `.api` 文件后，一键生成路由、请求结构体）。  
- **保障系统稳定性**：内置熔断（基于熔断器模式）、限流（令牌桶算法）、超时控制，避免单服务故障扩散，应对高并发峰值（如秒杀场景）。  
- **简化运维与监控**：集成链路跟踪（Jaeger/Zipkin）、指标上报（Prometheus）、日志收集，支持动态配置更新，无需重启服务即可调整参数（如限流阈值）。  
- **降低分布式复杂度**：封装RPC调用、分布式事务（TCC模式）、缓存控制（Redis），简化跨服务通信与数据一致性保障。  


### 24. 微服务拆分的依据是什么  
微服务拆分需平衡“业务独立性”与“技术可行性”，核心依据如下：  

1. **业务功能边界**：按“单一职责”拆分，每个服务专注一个核心业务模块。  
   - 示例：电商系统拆分为“用户服务”（登录、信息管理）、“商品服务”（商品CRUD、分类）、“订单服务”（下单、支付），服务间通过API/RPC通信，避免功能耦合。  

2. **数据边界**：按“数据归属”拆分，一个服务对应一套独立的数据库（或数据表），减少跨服务数据依赖。  
   - 原则：若两个模块频繁操作同一张表，优先合并；若数据交互少且独立（如“用户表”与“商品表”），则拆分到不同服务。  

3. **性能与扩展需求**：高并发、高资源消耗的模块单独拆分，便于针对性优化。  
   - 示例：电商的“搜索服务”（需Elasticsearch，高CPU/内存）、“实时推荐服务”（需机器学习模型），单独部署可独立扩容，不影响其他服务。  

4. **团队组织架构**：遵循“康威定律”，按团队职责拆分服务，每个团队负责1-3个服务的全生命周期（开发、测试、运维）。  
   - 优势：减少跨团队协作成本，团队自主决策服务迭代节奏。  

5. **技术栈差异**：若模块需特殊技术栈（如数据处理用Flink、前端用Node.js），可拆分独立服务，避免技术栈冲突。  


### 25. 你平时编程会用到哪一些设计模式  
日常编程中常用的设计模式，多围绕“解耦”“复用”“可扩展”展开：  

1. **单例模式**：确保一个类仅一个实例，用于全局资源管理。  
   - 场景：配置管理器（全局仅需一个实例加载配置）、日志工厂（避免多实例创建多个日志文件）。  
   - Go实现：通过 `sync.Once` 保证初始化唯一，如 `var instance *Config; var once sync.Once; func GetConfig() *Config { once.Do(func() { instance = loadConfig() }); return instance }`。  

2. **工厂模式**：隐藏对象创建逻辑，按条件生成不同类型实例。  
   - 场景：数据库驱动创建（根据配置的“mysql”“postgres”生成对应客户端）、支付方式工厂（根据“alipay”“wechat”生成对应支付接口）。  

3. **代理模式**：通过代理对象控制对原对象的访问，添加额外逻辑。  
   - 场景：RPC调用代理（在代理中添加超时重试、日志记录）、权限代理（调用接口前校验用户权限）。  

4. **观察者模式**：对象状态变化时通知依赖它的“观察者”，实现事件驱动。  
   - 场景：消息订阅（如订单状态变更时，通知库存服务、物流服务）、配置更新（配置变更时，通知所有依赖模块刷新配置）。  

5. **策略模式**：定义多种算法，按条件切换，避免大量 `if-else`。  
   - 场景：排序算法选择（根据数据量“小/中/大”选择“插入排序/快排/归并排序”）、缓存策略（根据数据类型选择“LRU”“LFU”缓存）。  


### 26. 你平时项目里CICD会怎么做，自己的个人项目怎么去做一些持续开发或者一些集成或者打包？大概会是怎么样的  
#### 1. 公司项目的CICD流程（基于GitLab CI/Jenkins + Docker + K8s）  
- **代码提交阶段**：  
  1. 开发者提交代码到GitLab，触发CI流水线；  
  2. 执行代码检查：`golint` 语法校验、`go test` 单元测试、SonarQube 代码质量扫描（检查漏洞、重复率）。  
- **构建部署阶段**：  
  1. 代码检查通过后，用 `Dockerfile` 构建镜像（如 `docker build -t app:v1.0 .`），推送到私有镜像仓库（Harbor）；  
  2. 调用K8s API，更新Deployment（如 `kubectl set image deployment/app app=harbor.com/app:v1.0`），采用“滚动更新”策略，避免服务中断；  
  3. 部署后执行健康检查（`livenessProbe`/`readinessProbe`），失败则自动回滚到上一版本。  
- **监控与告警**：集成Prometheus监控服务指标，Grafana可视化，异常时通过AlertManager发送邮件/钉钉告警。  

#### 2. 个人项目的CICD（基于GitHub Actions + Docker + 轻量服务器）  
- **流程设计**：  
  1. **代码提交触发**：在GitHub仓库创建 `.github/workflows/ci.yml`，配置“push到main分支时触发流水线”；  
  2. **依赖与测试**：使用GitHub Actions的Go环境，执行 `go mod tidy` 安装依赖，`go test -v` 跑单元测试；  
  3. **打包镜像**：测试通过后，用 `docker build` 构建镜像，登录Docker Hub并推送（如 `docker push username/app:latest`）；  
  4. **部署到个人服务器**：通过SSH连接服务器，拉取最新镜像，停止旧容器，启动新容器（如 `ssh user@server "docker pull username/app:latest && docker stop app || true && docker run -d --name app -p 8080:8080 username/app:latest"`）。  
- **优势**：零成本（GitHub Actions免费额度满足个人需求）、配置简单（YAML文件约50行即可完成）、自动化程度高（提交代码后无需手动操作）。  


### 27. 你用过docker，k8s相关的云原生平台吗  
用过，日常工作与个人项目中均有实践，核心场景如下：  

- **Docker**：  
  1. 项目容器化：将应用与依赖（如Go编译后的二进制、配置文件）打包成镜像，确保“开发环境=测试环境=生产环境”，避免“在我这能跑”问题；  
  2. 本地多服务测试：通过 `docker-compose` 启动MySQL、Redis、Elasticsearch等依赖服务，无需手动安装配置。  

- **Kubernetes（K8s）**：  
  1. 公司项目：用于微服务部署与管理，通过Deployment管理容器副本（如“3个订单服务副本”）、Service实现负载均衡、Ingress配置域名路由，支持自动扩缩容（根据CPU使用率扩容）；  
  2. 个人项目：在云服务器（如阿里云ECS）搭建单节点K8s（Minikube/K3s），实践“滚动更新”“配置挂载”等功能，学习云原生运维。  

- **配套工具**：使用Helm管理K8s应用（打包Deployment、Service为Chart，一键部署）、Prometheus+Grafana监控容器资源、ELK收集容器日志。  


### 28. docker的工作原理有了解过吗  
Docker的核心是**基于Linux内核技术实现“轻量级隔离”**，本质是“进程的隔离与资源限制”，核心原理依赖三大技术：  

1. **Namespaces（命名空间）：实现环境隔离**  
   - 作用：为容器内的进程创建独立的“环境视图”，使其看不到宿主机的其他进程、网络、文件系统。  
   - 关键Namespace：  
     - `PID Namespace`：容器内的PID从1开始，与宿主机PID隔离（如容器内的“PID 1”对应宿主机的某个PID）；  
     - `Network Namespace`：容器有独立的网卡、IP、端口，通过“桥接”与宿主机网络通信；  
     - `Mount Namespace`：容器有独立的文件系统挂载点，仅能看到自己的目录（如`/bin`/`/etc`是宿主机的子集）。  

2. **cgroups（控制组）：实现资源限制**  
   - 作用：限制容器对CPU、内存、磁盘IO、网络带宽等资源的使用，避免单个容器占用过多资源。  
   - 示例：通过 `--memory=1G` 限制容器最大内存为1GB，超过则触发OOM；通过 `--cpus=0.5` 限制容器使用50%的CPU核心。  

3. **UnionFS（联合文件系统）：实现镜像分层**  
   - 作用：镜像由多个只读层叠加而成，容器启动时在最上层添加一个“可写层”，所有修改仅作用于可写层，实现“镜像复用”与“容器隔离”。  
   - 示例：`ubuntu:20.04` 镜像包含“基础层”“系统库层”，容器启动后，用户创建的文件仅在“可写层”，删除容器后可写层被清理，镜像不变。  

4. **核心组件交互**：  
   - Docker Daemon：后台守护进程，接收客户端（`docker` 命令）请求，管理镜像、容器、网络；  
   - 镜像（Image）：只读模板，包含应用与依赖，是容器的“蓝图”；  
   - 容器（Container）：镜像的运行实例，是“被Namespace隔离、被cgroups限制资源的进程”。
