## 美团
### 1. DNS是什么？有什么作用？
DNS（Domain Name System，域名系统）是互联网的核心基础设施，作用是将域名（如www.example.com）解析为对应的IP地址（如192.168.1.1）。  
- 核心功能：解决IP地址难以记忆的问题，实现域名与IP的映射，支撑网络通信的寻址；  
- 扩展作用：提供负载均衡（通过解析到不同IP）、缓存加速（本地缓存减少重复解析）等能力。


### 2. 如何查看网络状态？netstat的具体用法？
- **查看网络状态工具**：Linux常用`netstat`、`ss`、`lsof`；Windows用`netstat`或PowerShell的`Get-NetTCPConnection`。  
- **netstat常用用法**：  
  - `netstat -tuln`：显示监听的TCP（-t）、UDP（-u）端口，以数字（-n）显示，不解析域名；  
  - `netstat -anp`：显示所有连接（-a），数字形式（-n），并关联进程ID（-p，需root权限）；  
  - `netstat -s`：统计各协议（TCP/UDP）的数据包收发情况；  
  - `netstat -r`：显示路由表信息。


### 3. 数据库四种隔离级别，会出现什么问题？
- **读未提交（Read Uncommitted）**：允许读取未提交数据。问题：脏读、不可重复读、幻读。  
- **读已提交（Read Committed）**：仅读取已提交数据。问题：不可重复读、幻读。  
- **可重复读（Repeatable Read）**：事务内多次读取结果一致。问题：理论上存在幻读（MySQL InnoDB通过MVCC+间隙锁解决）。  
- **串行化（Serializable）**：事务串行执行。问题：无并发问题，但性能极差。  


### 4. Golang中的goroutine是什么，如何创建和使用？
- **goroutine**：Go的轻量级协程，由运行时管理，初始栈2KB且可动态伸缩，创建成本极低（支持百万级并发）。  
- **创建**：通过`go`关键字启动，如`go func() { /* 逻辑 */ }()`。  
- **使用**：  
  - 配合`channel`实现协程间通信；  
  - 用`sync.WaitGroup`等待多个协程完成；  
  - 通过`context.Context`控制生命周期（超时、取消）。  


### 5. Golang中的类型断言是什么，有什么作用？
- **类型断言**：判断接口变量的实际类型，语法为`x.(T)`（`x`为接口，`T`为目标类型）。  
- **作用**：  
  - 检查接口是否持有特定类型的值；  
  - 提取具体类型的值以使用其方法或字段。  
- **安全用法**：`v, ok := x.(T)`，通过`ok`判断是否成功，避免panic。  


### 6. 如何设计一个高可用的缓存系统，考虑一致性和故障恢复？
- **高可用**：  
  - 集群部署：主从复制+哨兵模式（如Redis），自动故障转移；  
  - 多副本存储：避免单点故障，均衡负载；  
  - 负载均衡：通过代理（如Redis Cluster）分发请求。  

- **一致性**：  
  - 更新策略：“更新数据库+删除缓存”或“先删缓存+再更数据库”（加锁防并发）；  
  - 过期机制：设置合理TTL，定期同步；  
  - 分布式锁：保证缓存更新的原子性。  

- **故障恢复**：  
  - 持久化：开启RDB/AOF（Redis），崩溃后快速恢复；  
  - 监控告警：实时监控节点状态、命中率，异常时报警；  
  - 降级策略：缓存故障时临时切换到数据库，避免雪崩。

### 7. 为什么要做分库分表？
- **解决性能瓶颈**：单库单表数据量过大（如千万级以上）会导致查询变慢、索引失效、写入性能下降，分库分表可分散数据到多个库表，降低单库单表压力。
- **突破硬件限制**：单库受限于服务器的CPU、内存、磁盘IO，分库后可将数据分布到多台服务器，充分利用集群资源。
- **适配业务增长**：随着用户和数据量增长，分库分表可水平扩展，避免单库架构的扩展性瓶颈。
- **隔离业务场景**：将不同业务模块或冷热数据分离存储，减少相互影响（如订单表与用户表分开存储）。


### 8. 分库分表可能带来什么问题？比如跨库跨表的事务和联合查询如何解决？
- **潜在问题**：跨库跨表事务一致性难保证、联合查询复杂、全局ID生成复杂、数据迁移和扩容困难。
- **解决方案**：
  - **跨库事务**：采用分布式事务（如TCC、SAGA、2PC），或最终一致性方案（事件通知+补偿机制）；
  - **联合查询**：通过中间件（如ShardingSphere）自动路由并聚合结果，或提前冗余数据避免跨表查询；
  - **全局ID**：使用雪花算法、UUID、数据库自增ID+步长等生成唯一ID；
  - **扩容迁移**：采用预分片、动态扩容中间件（如MyCat），避免停机迁移。


### 9. MySQL主从同步怎么实现的？
- **核心流程**：基于binlog（二进制日志）的异步复制。
  1. 主库开启binlog，将所有写操作（DDL、DML）记录到binlog；
  2. 从库启动IO线程，连接主库并请求binlog，将接收到的binlog写入本地relay log（中继日志）；
  3. 从库启动SQL线程，读取relay log并解析执行，同步数据到从库，保持与主库一致。
- **关键配置**：主库需开启`log_bin`，从库需配置主库地址、账号密码及同步起点（binlog文件名和位置）。


### 10. 主从同步，什么情况可能会有比较大的同步延迟？
- **主库写入压力大**：高并发写入产生大量binlog，从库IO线程来不及同步。
- **大事务影响**：主库执行长事务（如批量插入/更新），生成大型binlog，从库SQL线程执行耗时久。
- **从库性能不足**：从库硬件配置（CPU、内存、磁盘）低于主库，或有慢查询占用资源，导致SQL线程执行慢。
- **网络延迟**：主从库跨机房部署，网络带宽不足或波动，导致binlog传输延迟。
- **锁冲突**：从库SQL线程执行时遇锁等待（如从库有写操作占用锁），阻塞同步进程。


### 11. 简历中写了kafka，有了解过其他的MQ、以及它们的区别吗？
- **常见MQ及区别**：
  - **RabbitMQ**：基于AMQP协议，支持复杂路由（交换机、队列模式），可靠性高（支持事务、死信队列），但吞吐量较低，适合业务复杂的中小规模场景。
  - **Kafka**：基于分区的分布式架构，高吞吐（百万级/秒）、低延迟，适合大数据日志采集、流处理，但消息可靠性配置复杂，适合高吞吐场景。
  - **RocketMQ**：阿里开源，支持事务消息、定时消息，吞吐介于RabbitMQ和Kafka之间，适合金融级业务，生态贴合Java。
  - **Pulsar**：云原生MQ，融合队列与流处理，支持多租户、分层存储，适合云环境，但社区成熟度较低。


### 12. MQ主要是来做什么的？
- **异步通信**：解耦上下游服务，避免同步调用导致的阻塞（如订单创建后异步通知库存、物流）。
- **削峰填谷**：缓冲高并发请求（如秒杀场景），避免下游服务被瞬间流量压垮。
- **流量控制**：通过MQ的消费速率控制，调节下游服务的处理压力。
- **数据同步**：作为数据管道，实现跨服务、跨系统的数据同步（如数据库变更通过MQ同步到缓存）。
- **系统解耦**：降低服务间直接依赖，提高系统容错性和可扩展性。


### 13. 高并发的场景下，MQ上有大量积压如何解决？
- **临时扩容消费能力**：增加消费节点（如Kafka增加消费者组的分区数和消费者实例），短时间内提高消费速率。
- **优化消费逻辑**：简化消费处理流程（如暂时关闭非核心逻辑），批量处理消息，减少单条消息处理耗时。
- **消息分流**：将积压消息导入临时队列，由专门的消费集群处理，避免影响正常业务。
- **限流保护**：暂时停止或降低上游生产者的发送速率，先消化积压消息。
- **事后优化**：调整MQ分区/队列数量，优化消费端性能，设置合理的重试机制，避免消息重复积压。

### 14. Golang 最大的特点在哪里？
- 语法简洁，无冗余特性，编译速度快，易于维护；
- 原生支持并发，通过 Goroutine 和 Channel 简化并发编程；
- 内存安全与性能平衡，自带 GC 且执行效率接近 C；
- 静态类型保证编译时安全，同时支持接口隐式实现等灵活特性；
- 跨平台编译，可生成独立二进制文件，部署无需依赖运行时。


### 15. goroutine 和 线程有什么区别？
- **调度层面**：Goroutine 是用户态调度（Go 运行时管理），线程是内核态调度（操作系统管理）；
- **资源消耗**：Goroutine 初始栈 2KB 且可动态伸缩，线程初始栈 1-8MB 且固定；
- **创建数量**：Goroutine 单机可创建数百万个，线程通常上限为数千个；
- **切换开销**：Goroutine 切换仅需保存用户态上下文，开销远低于线程的内核态切换；
- **依赖关系**：Goroutine 依赖线程执行，多个 Goroutine 可共享一个线程，线程直接映射到 CPU 核心。


### 16. 那么 goroutine 有没有什么缺陷？
- 调试难度高，并发逻辑复杂时难以复现竞态条件等问题；
- 存在资源泄漏风险，如阻塞在无数据 Channel 上的 Goroutine 会持续占用资源；
- 抢占式调度有局限，长时间纯计算任务可能阻塞其他 Goroutine；
- 跨平台调度存在差异，不同操作系统的线程模型可能影响效率。


### 17. 不考虑内存的前提下，想要利用多核 CPU，goroutine 还会有优势吗？
有优势。  
- 用户态调度避免内核态切换开销，同等任务调度成本低于线程；
- GMP 模型自动将 Goroutine 均衡分配到多核（P 数量等于 CPU 核心数），实现负载均衡；
- 内置并发工具（Channel、sync 包）简化多核协作，无需手动管理线程亲和性。


### 18. 上下文切换，到底切换了哪些信息？
- CPU 寄存器状态：程序计数器（PC）、栈指针（SP）、通用寄存器等；
- 内存管理信息：页表、内存映射表（进程切换时需切换）；
- 控制块信息：进程/线程状态、优先级、调度信息、文件描述符等；
- 栈空间：函数调用栈数据。  
Goroutine 切换仅需保存用户态上下文，比线程切换少内核态信息，开销更低。


### 19. 为什么内核态的上下文切换开销会大？
- 需切换 CPU 特权级，触发硬件保护机制，耗时较高；
- 存在多次数据拷贝（用户态到内核空间，再到新线程），增加内存操作开销；
- 切换后 CPU 缓存失效，需重新加载数据，降低访问效率；
- 内核调度器逻辑复杂（优先级判断、队列管理等），比用户态调度更耗时。


### 20. 为什么用 gRPC ？
- 基于 Protobuf 序列化，体积小、解析快，性能优于 JSON/XML；
- 支持多语言，方便异构系统通信；
- 基于 HTTP/2，支持多路复用和流式通信，性能优于 HTTP/1.1；
- 强类型接口定义，编译时检查错误，减少运行时问题；
- 内置认证、负载均衡、超时控制等特性，简化微服务开发。


### 21. 除了 protobuf，还知道哪些序列化方式，各有什么优势？
- **JSON**：文本格式，可读性强、跨语言兼容，适合 HTTP API，但体积大、解析慢；
- **MessagePack**：二进制格式，兼容 JSON 模型，体积小、解析快，适合高性能场景；
- **Thrift**：多语言支持，与 RPC 结合紧密，适合内部服务通信；
- **FlatBuffers**：零拷贝序列化，可直接访问数据，适合游戏、实时通信等性能敏感场景。


### 22. 如果让你自己设计序列化方式，你会考虑哪些因素？
- **性能**：序列化/反序列化速度和数据体积；
- **兼容性**：多语言支持和版本兼容（新增字段不影响旧版本）；
- **可读性**：根据场景选择文本（调试）或二进制（高性能）格式；
- **安全性**：防止恶意数据导致解析崩溃（如限制字段长度）；
- **扩展性**：支持新增类型和嵌套结构；
- **易用性**：提供简洁 API 和自动代码生成工具。
